{"version":3,"sources":["components/headroom/headroom.js"],"names":["define","dom","layoutManager","browser","requestAnimationFrame","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","Debouncer","callback","this","ticking","onHeadroomClearedExternally","state","Headroom","elems","options","Object","assign","lastKnownScrollY","scroller","debouncer","onScroll","bind","offset","initialised","initialClass","unPinnedClass","pinnedClass","add","elem","supportsCssAnimation","classList","addEventListener","push","remove","i","indexOf","splice","pause","paused","resume","destroy","length","scrollEventName","getScrollEventName","removeEventListener","capture","passive","attachEvent","getScrollY","update","clear","unpinnedClass","pin","unpin","getScrollPosition","pageYOffset","undefined","scrollTop","document","documentElement","body","shouldUnpin","currentScrollY","scrollingDown","pastOffset","shouldPin","scrollingUp","isTv","tv","toleranceExceeded","Math","abs","rafCallback","prototype","constructor","handleEvent"],"mappings":"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","file":"headroom.js","sourcesContent":["/*!\n * headroom.js v0.7.0 - Give your page some headroom. Hide your header until you need it\n * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/headroom.js\n * License: MIT\n */\n\ndefine(['dom', 'layoutManager', 'browser', 'css!./headroom'], function (dom, layoutManager, browser) {\n\n    'use strict';\n\n    /* exported features */\n\n    var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\n    /**\n     * Handles debouncing of events via requestAnimationFrame\n     * @see http://www.html5rocks.com/en/tutorials/speed/animations/\n     * @param {Function} callback The callback to handle whichever event\n     */\n    function Debouncer(callback) {\n        this.callback = callback;\n        this.ticking = false;\n    }\n    Debouncer.prototype = {\n        constructor: Debouncer,\n\n        /**\n         * dispatches the event to the supplied callback\n         * @private\n         */\n        update: function () {\n            if (this.callback) {\n                this.callback();\n            }\n            this.ticking = false;\n        },\n\n        /**\n         * Attach this as the event listeners\n         */\n        handleEvent: function () {\n            if (!this.ticking) {\n                requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));\n                this.ticking = true;\n            }\n        }\n    };\n\n    function onHeadroomClearedExternally() {\n        this.state = null;\n    }\n\n    /**\n   * UI enhancement for fixed headers.\n   * Hides header when scrolling down\n   * Shows header when scrolling up\n   * @constructor\n   * @param {DOMElement} elem the header element\n   * @param {Object} options options for the widget\n   */\n    function Headroom(elems, options) {\n        options = Object.assign(Headroom.options, options || {});\n\n        this.lastKnownScrollY = 0;\n        this.elems = elems;\n\n        this.scroller = options.scroller;\n\n        this.debouncer = onScroll.bind(this);\n        this.offset = options.offset;\n        this.initialised = false;\n\n        this.initialClass = options.initialClass;\n        this.unPinnedClass = options.unPinnedClass;\n        this.pinnedClass = options.pinnedClass;\n\n        this.state = 'clear';\n\n        this.options = {\n            offset: 0,\n            scroller: window,\n            initialClass: 'headroom',\n            unPinnedClass: 'headroom--unpinned',\n            pinnedClass: 'headroom--pinned'\n        };\n\n        this.add = function (elem) {\n\n            if (browser.supportsCssAnimation()) {\n                elem.classList.add(this.initialClass);\n                elem.addEventListener('clearheadroom', onHeadroomClearedExternally.bind(this));\n                this.elems.push(elem);\n            }\n        };\n\n        this.remove = function (elem) {\n\n            elem.classList.remove(this.unPinnedClass);\n            elem.classList.remove(this.initialClass);\n            elem.classList.remove(this.pinnedClass);\n\n            var i = this.elems.indexOf(elem);\n            if (i !== -1) {\n                this.elems.splice(i, 1);\n            }\n        };\n\n        this.pause = function () {\n            this.paused = true;\n        };\n\n        this.resume = function () {\n            this.paused = false;\n        };\n\n        /**\n         * Unattaches events and removes any classes that were added\n         */\n        this.destroy = function () {\n\n            this.initialised = false;\n\n            for (var i = 0, length = this.elems.length; i < length; i++) {\n\n                var classList = this.elems[i].classList;\n\n                classList.remove(this.unPinnedClass);\n                classList.remove(this.initialClass);\n                classList.remove(this.pinnedClass);\n            }\n\n            var scrollEventName = this.scroller.getScrollEventName ? this.scroller.getScrollEventName() : 'scroll';\n\n            dom.removeEventListener(this.scroller, scrollEventName, this.debouncer, {\n                capture: false,\n                passive: true\n            });\n        };\n\n        /**\n         * Attaches the scroll event\n         * @private\n         */\n        this.attachEvent = function () {\n            if (!this.initialised) {\n                this.lastKnownScrollY = this.getScrollY();\n                this.initialised = true;\n\n                var scrollEventName = this.scroller.getScrollEventName ? this.scroller.getScrollEventName() : 'scroll';\n\n                dom.addEventListener(this.scroller, scrollEventName, this.debouncer, {\n                    capture: false,\n                    passive: true\n                });\n\n                this.update();\n            }\n        };\n\n        /**\n         * Unpins the header if it's currently pinned\n         */\n        this.clear = function () {\n\n            if (this.state === 'clear') {\n                return;\n            }\n\n            this.state = 'clear';\n\n            var unpinnedClass = this.unPinnedClass;\n            var pinnedClass = this.pinnedClass;\n\n            for (var i = 0, length = this.elems.length; i < length; i++) {\n                var classList = this.elems[i].classList;\n\n                classList.remove(unpinnedClass);\n                //classList.remove(pinnedClass);\n            }\n        };\n\n        /**\n         * Unpins the header if it's currently pinned\n         */\n        this.pin = function () {\n\n            if (this.state === 'pin') {\n                return;\n            }\n\n            this.state = 'pin';\n\n            var unpinnedClass = this.unPinnedClass;\n            var pinnedClass = this.pinnedClass;\n\n            for (var i = 0, length = this.elems.length; i < length; i++) {\n                var classList = this.elems[i].classList;\n\n                classList.remove(unpinnedClass);\n                classList.add(pinnedClass);\n            }\n        };\n\n        /**\n         * Unpins the header if it's currently pinned\n         */\n        this.unpin = function () {\n\n            if (this.state === 'unpin') {\n                return;\n            }\n\n            this.state = 'unpin';\n\n            var unpinnedClass = this.unPinnedClass;\n            var pinnedClass = this.pinnedClass;\n\n            for (var i = 0, length = this.elems.length; i < length; i++) {\n                var classList = this.elems[i].classList;\n\n                classList.add(unpinnedClass);\n                //classList.remove(pinnedClass);\n            }\n        };\n\n        /**\n         * Gets the Y scroll position\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n         * @return {Number} pixels the page has scrolled along the Y-axis\n         */\n        this.getScrollY = function () {\n\n            var scroller = this.scroller;\n\n            if (scroller.getScrollPosition) {\n                return scroller.getScrollPosition();\n            }\n\n            var pageYOffset = scroller.pageYOffset;\n            if (pageYOffset !== undefined) {\n                return pageYOffset;\n            }\n\n            var scrollTop = scroller.scrollTop;\n            if (scrollTop !== undefined) {\n                return scrollTop;\n            }\n\n            return (document.documentElement || document.body).scrollTop;\n        };\n\n        /**\n         * determine if it is appropriate to unpin\n         * @param  {int} currentScrollY the current y scroll position\n         * @return {bool} true if should unpin, false otherwise\n         */\n        this.shouldUnpin = function (currentScrollY) {\n            var scrollingDown = currentScrollY > this.lastKnownScrollY;\n            var pastOffset = currentScrollY >= this.offset;\n\n            return scrollingDown && pastOffset;\n        };\n\n        /**\n         * determine if it is appropriate to pin\n         * @param  {int} currentScrollY the current y scroll position\n         * @return {bool} true if should pin, false otherwise\n         */\n        this.shouldPin = function (currentScrollY) {\n            var scrollingUp = currentScrollY < this.lastKnownScrollY;\n            var pastOffset = currentScrollY <= this.offset;\n\n            return scrollingUp || pastOffset;\n        };\n\n        /**\n         * Handles updating the state of the widget\n         */\n        this.update = function () {\n\n            if (this.paused) {\n                return;\n            }\n\n            var currentScrollY = this.getScrollY();\n\n            var lastKnownScrollY = this.lastKnownScrollY;\n\n            var isTv = layoutManager.tv;\n\n            if (currentScrollY <= (isTv ? 120 : 10)) {\n                this.clear();\n            } else if (this.shouldUnpin(currentScrollY)) {\n                this.unpin();\n            } else if (this.shouldPin(currentScrollY)) {\n\n                var toleranceExceeded = Math.abs(currentScrollY - lastKnownScrollY) >= 14;\n\n                if (currentScrollY && isTv) {\n                    this.unpin();\n                } else if (toleranceExceeded) {\n                    this.clear();\n                }\n            } else if (isTv) {\n                //this.clear();\n            }\n\n            this.lastKnownScrollY = currentScrollY;\n        };\n\n        if (browser.supportsCssAnimation()) {\n            for (var i = 0, length = this.elems.length; i < length; i++) {\n                this.elems[i].classList.add(this.initialClass);\n                this.elems[i].addEventListener('clearheadroom', onHeadroomClearedExternally.bind(this));\n            }\n\n            this.attachEvent();\n        }\n    }\n\n    function onScroll() {\n\n        if (this.paused) {\n            return;\n        }\n\n        requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));\n    }\n\n    /**\n     * Default options\n     * @type {Object}\n     */\n    Headroom.options = {\n        offset: 0,\n        scroller: window,\n        initialClass: 'headroom',\n        unPinnedClass: 'headroom--unpinned',\n        pinnedClass: 'headroom--pinned'\n    };\n\n    return Headroom;\n});\n"]}