{"version":3,"sources":["libraries/apiclient/connectionmanager.js"],"names":["define","events","apiClientFactory","appStorage","getServerAddress","server","mode","ConnectionMode","Local","LocalAddress","Manual","ManualAddress","Remote","RemoteAddress","resolveFailure","instance","resolve","State","updateServerInfo","systemInfo","Name","ServerName","Id","getEmbyServerUrl","baseUrl","handler","getFetchPromise","request","headers","dataType","accept","fetchRequest","method","type","credentials","contentType","data","body","paramsToString","params","values","key","value","push","encodeURIComponent","join","timeout","fetchWithTimeout","url","options","timeoutMs","console","debug","Promise","reject","setTimeout","fetch","then","response","clearTimeout","error","ajax","Error","status","json","err","replaceAll","originalString","strReplace","strWith","reg","RegExp","replace","normalizeAddress","address","trim","toLowerCase","indexOf","stringEqualsIgnoreCase","str1","str2","ConnectionManager","credentialProvider","appName","appVersion","deviceName","deviceId","capabilities","onAuthenticated","apiClient","result","saveCredentials","servers","Servers","filter","s","ServerId","length","serverInfo","updateDateLastAccessed","DateLastAccessed","Date","getTime","UserId","User","AccessToken","addOrUpdateServer","enableAutomaticBitrateDetection","afterConnected","onLocalUserSignIn","serverAddress","reportCapabilities","enableWebSocket","ensureWebSocket","serverUrl","user","self","_getOrAddApiClient","onLocalUserSignedIn","call","trigger","logoutOfServer","logoutInfo","serverId","logout","convertEndpointAddressToManualAddress","info","Address","EndpointAddress","split","parts","portString","isNaN","parseInt","tryReconnect","addresses","addressesStrings","manualAddressOnly","state","numAddresses","rejects","map","resolved","getTryConnectPromise","connectionMode","onSuccessfulConnection","afterConnectValidated","verifyLocalAuthentication","enableAutoLogin","validateAuthentication","X-MediaBrowser-Token","LastConnectionMode","ApiClient","setSystemInfo","resolveActions","getCurrentUser","this","_apiClients","_minServerVersion","getServerInfo","id","getLastUsedServer","sort","a","b","addApiClient","existingServers","existingServer","clearData","getApiClient","getOrCreateApiClient","localUser","getCurrentUserId","onLocalUserDone","e","u","image","getImageUrl","PrimaryImageTag","getUserImageUrl","tag","supportsParams","name","imageUrl","supportsImageParams","promises","i","accessToken","all","UserLinkType","j","numServers","ExchangeToken","getSavedServers","slice","getAvailableServers","onFinish","foundServers","foundServer","window","NativeShell","findServers","responses","mergeServers","list1","list2","connectToServers","firstServer","connectToServer","compareVersions","Math","max","aVal","bVal","minServerVersion","Version","connectToAddress","catch","onFail","deleteServer","ConnectServerId","onDone","prototype","connect","getApiClients","item","val","handleMessageReceived","msg","Data","JSON","parse"],"mappings":"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","file":"connectionmanager.js","sourcesContent":["define([\"events\", \"apiclient\", \"appStorage\"], function (events, apiClientFactory, appStorage) {\n    \"use strict\";\n\n    function getServerAddress(server, mode) {\n        switch (mode) {\n            case ConnectionMode.Local:\n                return server.LocalAddress;\n\n            case ConnectionMode.Manual:\n                return server.ManualAddress;\n\n            case ConnectionMode.Remote:\n                return server.RemoteAddress;\n\n            default:\n                return server.ManualAddress || server.LocalAddress || server.RemoteAddress;\n        }\n    }\n\n    function paramsToString(params) {\n        var values = [];\n\n        for (var key in params) {\n            var value = params[key];\n\n            if (null !== value && void 0 !== value && \"\" !== value) {\n                values.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return values.join(\"&\");\n    }\n\n    function resolveFailure(instance, resolve) {\n        resolve({\n            State: \"Unavailable\",\n        });\n    }\n\n    function mergeServers(credentialProvider, list1, list2) {\n        for (var i = 0, length = list2.length; i < length; i++) {\n            credentialProvider.addOrUpdateServer(list1, list2[i]);\n        }\n\n        return list1;\n    }\n\n    function updateServerInfo(server, systemInfo) {\n        server.Name = systemInfo.ServerName;\n        if (systemInfo.Id) {\n            server.Id = systemInfo.Id;\n        }\n\n        if (systemInfo.LocalAddress) {\n            server.LocalAddress = systemInfo.LocalAddress;\n        }\n    }\n\n    function getEmbyServerUrl(baseUrl, handler) {\n        return baseUrl + \"/\" + handler;\n    }\n\n    function getFetchPromise(request) {\n        var headers = request.headers || {};\n\n        if (\"json\" === request.dataType) {\n            headers.accept = \"application/json\";\n        }\n\n        var fetchRequest = {\n            headers: headers,\n            method: request.type,\n            credentials: \"same-origin\"\n        };\n        var contentType = request.contentType;\n\n        if (request.data) {\n            if (\"string\" == typeof request.data) {\n                fetchRequest.body = request.data;\n            } else {\n                fetchRequest.body = paramsToString(request.data);\n                contentType = contentType || \"application/x-www-form-urlencoded; charset=UTF-8\";\n            }\n        }\n\n        if (contentType) {\n            headers[\"Content-Type\"] = contentType;\n        }\n\n        if (request.timeout) {\n            return fetchWithTimeout(request.url, fetchRequest, request.timeout);\n        }\n\n        return fetch(request.url, fetchRequest);\n    }\n\n    function fetchWithTimeout(url, options, timeoutMs) {\n        console.debug(\"fetchWithTimeout: timeoutMs: \" + timeoutMs + \", url: \" + url);\n        return new Promise(function (resolve, reject) {\n            var timeout = setTimeout(reject, timeoutMs);\n            options = options || {};\n            options.credentials = \"same-origin\";\n            fetch(url, options).then(function (response) {\n                clearTimeout(timeout);\n                console.debug(\"fetchWithTimeout: succeeded connecting to url: \" + url);\n                resolve(response);\n            }, function (error) {\n                clearTimeout(timeout);\n                console.error(\"fetchWithTimeout: timed out connecting to url: \" + url);\n                reject();\n            });\n        });\n    }\n\n    function ajax(request) {\n        if (!request) {\n            throw new Error(\"Request cannot be null\");\n        }\n\n        request.headers = request.headers || {};\n        console.debug(\"ConnectionManager requesting url: \" + request.url);\n        return getFetchPromise(request).then(function (response) {\n            console.debug(\"ConnectionManager response status: \" + response.status + \", url: \" + request.url);\n\n            if (response.status < 400) {\n                if (\"json\" === request.dataType || \"application/json\" === request.headers.accept) {\n                    return response.json();\n                }\n\n                return response;\n            }\n\n            return Promise.reject(response);\n        }, function (err) {\n            console.error(\"ConnectionManager request failed to url: \" + request.url);\n            throw err;\n        });\n    }\n\n    function replaceAll(originalString, strReplace, strWith) {\n        var reg = new RegExp(strReplace, \"ig\");\n        return originalString.replace(reg, strWith);\n    }\n\n    function normalizeAddress(address) {\n        address = address.trim();\n\n        if (0 !== address.toLowerCase().indexOf(\"http\")) {\n            address = \"http://\" + address;\n        }\n\n        address = replaceAll(address, \"Http:\", \"http:\");\n        address = replaceAll(address, \"Https:\", \"https:\");\n\n        return address;\n    }\n\n    function stringEqualsIgnoreCase(str1, str2) {\n        return (str1 || \"\").toLowerCase() === (str2 || \"\").toLowerCase();\n    }\n\n    function compareVersions(a, b) {\n        a = a.split(\".\");\n        b = b.split(\".\");\n\n        for (var i = 0, length = Math.max(a.length, b.length); i < length; i++) {\n            var aVal = parseInt(a[i] || \"0\");\n            var bVal = parseInt(b[i] || \"0\");\n\n            if (aVal < bVal) {\n                return -1;\n            }\n\n            if (aVal > bVal) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    var defaultTimeout = 20000;\n    var ConnectionMode = {\n        Local: 0,\n        Remote: 1,\n        Manual: 2\n    };\n\n    var ConnectionManager = function (credentialProvider, appName, appVersion, deviceName, deviceId, capabilities) {\n\n        function onAuthenticated(apiClient, result, options, saveCredentials) {\n            var credentials = credentialProvider.credentials();\n            var servers = credentials.Servers.filter(function (s) {\n                return s.Id === result.ServerId;\n            });\n            var server = servers.length ? servers[0] : apiClient.serverInfo();\n\n            if (false !== options.updateDateLastAccessed) {\n                server.DateLastAccessed = new Date().getTime();\n            }\n\n            server.Id = result.ServerId;\n\n            if (saveCredentials) {\n                server.UserId = result.User.Id;\n                server.AccessToken = result.AccessToken;\n            } else {\n                server.UserId = null;\n                server.AccessToken = null;\n            }\n\n            credentialProvider.addOrUpdateServer(credentials.Servers, server);\n            credentialProvider.credentials(credentials);\n            apiClient.enableAutomaticBitrateDetection = options.enableAutomaticBitrateDetection;\n            apiClient.serverInfo(server);\n            afterConnected(apiClient, options);\n            return onLocalUserSignIn(server, apiClient.serverAddress(), result.User);\n        }\n\n        function afterConnected(apiClient, options) {\n            options = options || {};\n\n            if (false !== options.reportCapabilities) {\n                apiClient.reportCapabilities(capabilities);\n            }\n\n            apiClient.enableAutomaticBitrateDetection = options.enableAutomaticBitrateDetection;\n\n            if (false !== options.enableWebSocket) {\n                console.debug(\"calling apiClient.ensureWebSocket\");\n                apiClient.ensureWebSocket();\n            }\n        }\n\n        function onLocalUserSignIn(server, serverUrl, user) {\n            self._getOrAddApiClient(server, serverUrl);\n\n            var promise = self.onLocalUserSignedIn ? self.onLocalUserSignedIn.call(self, user) : Promise.resolve();\n            return promise.then(function () {\n                events.trigger(self, \"localusersignedin\", [user])\n            })\n        }\n\n        function validateAuthentication(server, serverUrl) {\n            return ajax({\n                type: \"GET\",\n                url: getEmbyServerUrl(serverUrl, \"System/Info\"),\n                dataType: \"json\",\n                headers: {\n                    \"X-MediaBrowser-Token\": server.AccessToken\n                }\n            }).then(function (systemInfo) {\n                updateServerInfo(server, systemInfo);\n                return Promise.resolve();\n            }, function () {\n                server.UserId = null;\n                server.AccessToken = null;\n                return Promise.resolve();\n            });\n        }\n\n        function getImageUrl(localUser) {\n            if (localUser && localUser.PrimaryImageTag) {\n                return {\n                    url: self.getApiClient(localUser).getUserImageUrl(localUser.Id, {\n                        tag: localUser.PrimaryImageTag,\n                        type: \"Primary\"\n                    }),\n                    supportsParams: true\n                };\n            }\n\n            return {\n                url: null,\n                supportsParams: false\n            };\n        }\n\n        function logoutOfServer(apiClient) {\n            var serverInfo = apiClient.serverInfo() || {};\n            var logoutInfo = {\n                serverId: serverInfo.Id\n            };\n            return apiClient.logout().then(function () {\n                events.trigger(self, \"localusersignedout\", [logoutInfo]);\n            }, function () {\n                events.trigger(self, \"localusersignedout\", [logoutInfo]);\n            });\n        }\n\n        function findServers() {\n            return new Promise(function (resolve, reject) {\n                var onFinish = function (foundServers) {\n                    var servers = foundServers.map(function (foundServer) {\n                        var info = {\n                            Id: foundServer.Id,\n                            LocalAddress: convertEndpointAddressToManualAddress(foundServer) || foundServer.Address,\n                            Name: foundServer.Name\n                        };\n                        info.LastConnectionMode = info.ManualAddress ? ConnectionMode.Manual : ConnectionMode.Local;\n                        return info;\n                    });\n                    resolve(servers);\n                };\n\n                if (window.NativeShell && typeof window.NativeShell.findServers === 'function') {\n                    window.NativeShell.findServers(1e3).then(onFinish, function () {\n                        onFinish([]);\n                    });\n                } else {\n                    resolve([]);\n                }\n            });\n        }\n\n        function convertEndpointAddressToManualAddress(info) {\n            if (info.Address && info.EndpointAddress) {\n                var address = info.EndpointAddress.split(\":\")[0];\n                var parts = info.Address.split(\":\");\n\n                if (parts.length > 1) {\n                    var portString = parts[parts.length - 1];\n\n                    if (!isNaN(parseInt(portString))) {\n                        address += \":\" + portString;\n                    }\n                }\n\n                return normalizeAddress(address);\n            }\n\n            return null;\n        }\n\n        function getTryConnectPromise(url, connectionMode, state, resolve, reject) {\n            console.debug(\"getTryConnectPromise \" + url);\n            ajax({\n                url: getEmbyServerUrl(url, \"system/info/public\"),\n                timeout: defaultTimeout,\n                type: \"GET\",\n                dataType: \"json\"\n            }).then(function (result) {\n                if (!state.resolved) {\n                    state.resolved = true;\n                    console.debug(\"Reconnect succeeded to \" + url);\n                    resolve({\n                        url: url,\n                        connectionMode: connectionMode,\n                        data: result\n                    });\n                }\n            }, function () {\n                if (!state.resolved) {\n                    console.error(\"Reconnect failed to \" + url);\n\n                    if (++state.rejects >= state.numAddresses) {\n                        reject();\n                    }\n                }\n            });\n        }\n\n        function tryReconnect(serverInfo) {\n            var addresses = [];\n            var addressesStrings = [];\n\n            if (!serverInfo.manualAddressOnly && serverInfo.LocalAddress && -1 === addressesStrings.indexOf(serverInfo.LocalAddress)) {\n                addresses.push({\n                    url: serverInfo.LocalAddress,\n                    mode: ConnectionMode.Local,\n                    timeout: 0\n                });\n                addressesStrings.push(addresses[addresses.length - 1].url);\n            }\n\n            if (serverInfo.ManualAddress && -1 === addressesStrings.indexOf(serverInfo.ManualAddress)) {\n                addresses.push({\n                    url: serverInfo.ManualAddress,\n                    mode: ConnectionMode.Manual,\n                    timeout: 100\n                });\n                addressesStrings.push(addresses[addresses.length - 1].url);\n            }\n\n            if (!serverInfo.manualAddressOnly && serverInfo.RemoteAddress && -1 === addressesStrings.indexOf(serverInfo.RemoteAddress)) {\n                addresses.push({\n                    url: serverInfo.RemoteAddress,\n                    mode: ConnectionMode.Remote,\n                    timeout: 200\n                });\n                addressesStrings.push(addresses[addresses.length - 1].url);\n            }\n\n            console.debug(\"tryReconnect: \" + addressesStrings.join(\"|\"));\n            return new Promise(function (resolve, reject) {\n                var state = {};\n                state.numAddresses = addresses.length;\n                state.rejects = 0;\n                addresses.map(function (url) {\n                    setTimeout(function () {\n                        if (!state.resolved) {\n                            getTryConnectPromise(url.url, url.mode, state, resolve, reject);\n                        }\n                    }, url.timeout);\n                });\n            });\n        }\n\n        function onSuccessfulConnection(server, systemInfo, connectionMode, serverUrl, options, resolve) {\n            var credentials = credentialProvider.credentials();\n            options = options || {};\n\n            afterConnectValidated(server, credentials, systemInfo, connectionMode, serverUrl, true, options, resolve);\n        }\n\n        function afterConnectValidated(server, credentials, systemInfo, connectionMode, serverUrl, verifyLocalAuthentication, options, resolve) {\n            options = options || {};\n            if (false === options.enableAutoLogin) {\n                server.UserId = null;\n                server.AccessToken = null;\n            } else if (verifyLocalAuthentication && server.AccessToken && false !== options.enableAutoLogin) {\n                return void validateAuthentication(server, serverUrl).then(function () {\n                    afterConnectValidated(server, credentials, systemInfo, connectionMode, serverUrl, false, options, resolve);\n                });\n            }\n\n            updateServerInfo(server, systemInfo);\n            server.LastConnectionMode = connectionMode;\n\n            if (false !== options.updateDateLastAccessed) {\n                server.DateLastAccessed = new Date().getTime();\n            }\n\n            credentialProvider.addOrUpdateServer(credentials.Servers, server);\n            credentialProvider.credentials(credentials);\n            var result = {\n                Servers: []\n            };\n            result.ApiClient = self._getOrAddApiClient(server, serverUrl);\n            result.ApiClient.setSystemInfo(systemInfo);\n            result.State = server.AccessToken && false !== options.enableAutoLogin ? \"SignedIn\" : \"ServerSignIn\";\n            result.Servers.push(server);\n            result.ApiClient.enableAutomaticBitrateDetection = options.enableAutomaticBitrateDetection;\n            result.ApiClient.updateServerInfo(server, serverUrl);\n\n            var resolveActions = function () {\n                resolve(result);\n                events.trigger(self, \"connected\", [result]);\n            };\n\n            if (\"SignedIn\" === result.State) {\n                afterConnected(result.ApiClient, options);\n                result.ApiClient.getCurrentUser().then(function (user) {\n                    onLocalUserSignIn(server, serverUrl, user).then(resolveActions, resolveActions);\n                }, resolveActions);\n            } else {\n                resolveActions();\n            }\n        }\n\n        console.debug(\"Begin ConnectionManager constructor\");\n        var self = this;\n        this._apiClients = [];\n        self._minServerVersion = \"3.2.33\";\n\n        self.appVersion = function () {\n            return appVersion;\n        };\n\n        self.appName = function () {\n            return appName;\n        };\n\n        self.capabilities = function () {\n            return capabilities;\n        };\n\n        self.deviceId = function () {\n            return deviceId;\n        };\n\n        self.credentialProvider = function () {\n            return credentialProvider;\n        };\n\n        self.getServerInfo = function (id) {\n            return credentialProvider.credentials().Servers.filter(function (s) {\n                return s.Id === id;\n            })[0];\n        };\n\n        self.getLastUsedServer = function () {\n            var servers = credentialProvider.credentials().Servers;\n            servers.sort(function (a, b) {\n                return (b.DateLastAccessed || 0) - (a.DateLastAccessed || 0);\n            });\n\n            if (servers.length) {\n                return servers[0];\n            }\n\n            return null;\n        };\n\n        self.addApiClient = function (apiClient) {\n            self._apiClients.push(apiClient);\n\n            var existingServers = credentialProvider.credentials().Servers.filter(function (s) {\n                return stringEqualsIgnoreCase(s.ManualAddress, apiClient.serverAddress()) || stringEqualsIgnoreCase(s.LocalAddress, apiClient.serverAddress()) || stringEqualsIgnoreCase(s.RemoteAddress, apiClient.serverAddress());\n            });\n            var existingServer = existingServers.length ? existingServers[0] : apiClient.serverInfo();\n\n            existingServer.DateLastAccessed = new Date().getTime();\n            existingServer.LastConnectionMode = ConnectionMode.Manual;\n            existingServer.ManualAddress = apiClient.serverAddress();\n            if (apiClient.manualAddressOnly) {\n                existingServer.manualAddressOnly = true;\n            }\n            apiClient.serverInfo(existingServer);\n            apiClient.onAuthenticated = function (instance, result) {\n                return onAuthenticated(instance, result, {}, true);\n            };\n            if (!existingServers.length) {\n                var credentials = credentialProvider.credentials();\n                credentials.Servers = [existingServer];\n                credentialProvider.credentials(credentials);\n            }\n\n            events.trigger(self, \"apiclientcreated\", [apiClient]);\n        };\n\n        self.clearData = function () {\n            console.debug(\"connection manager clearing data\");\n            var credentials = credentialProvider.credentials();\n            credentials.Servers = [];\n            credentialProvider.credentials(credentials);\n        };\n\n        self._getOrAddApiClient = function (server, serverUrl) {\n            var apiClient = self.getApiClient(server.Id);\n\n            if (!apiClient) {\n                apiClient = new apiClientFactory(serverUrl, appName, appVersion, deviceName, deviceId);\n                self._apiClients.push(apiClient);\n                apiClient.serverInfo(server);\n                apiClient.onAuthenticated = function (instance, result) {\n                    return onAuthenticated(instance, result, {}, true);\n                };\n\n                events.trigger(self, \"apiclientcreated\", [apiClient]);\n            }\n\n            console.debug(\"returning instance from getOrAddApiClient\");\n            return apiClient;\n        };\n\n        self.getOrCreateApiClient = function (serverId) {\n            var credentials = credentialProvider.credentials();\n            var servers = credentials.Servers.filter(function (s) {\n                return stringEqualsIgnoreCase(s.Id, serverId);\n            });\n\n            if (!servers.length) {\n                throw new Error(\"Server not found: \" + serverId);\n            }\n\n            var server = servers[0];\n            return self._getOrAddApiClient(server, getServerAddress(server, server.LastConnectionMode));\n        };\n\n        self.user = function (apiClient) {\n            return new Promise(function (resolve, reject) {\n                function onLocalUserDone(e) {\n                    if (apiClient && apiClient.getCurrentUserId()) {\n                        apiClient.getCurrentUser().then(function (u) {\n                            localUser = u;\n                            var image = getImageUrl(localUser);\n                            resolve({\n                                localUser: localUser,\n                                name: localUser ? localUser.Name : null,\n                                imageUrl: image.url,\n                                supportsImageParams: image.supportsParams,\n                            });\n                        }, onLocalUserDone);\n                    }\n                }\n                var localUser;\n                if (apiClient && apiClient.getCurrentUserId()) {\n                    onLocalUserDone();\n                }\n            });\n        };\n\n        self.logout = function () {\n            console.debug(\"begin connectionManager loguot\");\n            var promises = [];\n\n            for (var i = 0, length = self._apiClients.length; i < length; i++) {\n                var apiClient = self._apiClients[i];\n\n                if (apiClient.accessToken()) {\n                    promises.push(logoutOfServer(apiClient));\n                }\n            }\n\n            return Promise.all(promises).then(function () {\n                var credentials = credentialProvider.credentials();\n                var servers = credentials.Servers.filter(function (u) {\n                    return \"Guest\" !== u.UserLinkType;\n                });\n\n                for (var j = 0, numServers = servers.length; j < numServers; j++) {\n                    var server = servers[j];\n                    server.UserId = null;\n                    server.AccessToken = null;\n                    server.ExchangeToken = null;\n                }\n            });\n        };\n\n        self.getSavedServers = function () {\n            var credentials = credentialProvider.credentials();\n            var servers = credentials.Servers.slice(0);\n            servers.sort(function (a, b) {\n                return (b.DateLastAccessed || 0) - (a.DateLastAccessed || 0);\n            });\n            return servers;\n        };\n\n        self.getAvailableServers = function () {\n            console.debug(\"begin getAvailableServers\");\n            var credentials = credentialProvider.credentials();\n            return Promise.all([findServers()]).then(function (responses) {\n                var foundServers = responses[0];\n                var servers = credentials.Servers.slice(0);\n                mergeServers(credentialProvider, servers, foundServers);\n                servers.sort(function (a, b) {\n                    return (b.DateLastAccessed || 0) - (a.DateLastAccessed || 0);\n                });\n                credentials.Servers = servers;\n                credentialProvider.credentials(credentials);\n                return servers;\n            });\n        };\n\n        self.connectToServers = function (servers, options) {\n            console.debug(\"begin connectToServers, with \" + servers.length + \" servers\");\n            var firstServer = servers.length ? servers[0] : null;\n\n            if (firstServer) {\n                return self.connectToServer(firstServer, options).then(function (result) {\n                    if (\"Unavailable\" === result.State) {\n                        result.State = \"ServerSelection\";\n                    }\n\n                    console.debug(\"resolving connectToServers with result.State: \" + result.State);\n                    return result;\n                });\n            }\n\n            return Promise.resolve({\n                Servers: servers,\n                State: \"ServerSelection\"\n            });\n        };\n\n        self.connectToServer = function (server, options) {\n            console.debug(\"begin connectToServer\");\n            return new Promise(function (resolve, reject) {\n                options = options || {};\n                tryReconnect(server).then(function (result) {\n                    var serverUrl = result.url;\n                    var connectionMode = result.connectionMode;\n                    result = result.data;\n\n                    if (1 === compareVersions(self.minServerVersion(), result.Version)) {\n                        console.debug(\"minServerVersion requirement not met. Server version: \" + result.Version);\n                        resolve({\n                            State: \"ServerUpdateNeeded\",\n                            Servers: [server]\n                        });\n                    } else {\n                        if (server.Id && result.Id !== server.Id) {\n                            console.debug(\"http request succeeded, but found a different server Id than what was expected\");\n                            resolveFailure(self, resolve);\n                        } else {\n                            onSuccessfulConnection(server, result, connectionMode, serverUrl, options, resolve);\n                        }\n                    }\n                }, function () {\n                    resolveFailure(self, resolve);\n                });\n            });\n        };\n\n        self.connectToAddress = function (address, options) {\n            function onFail() {\n                console.error(\"connectToAddress \" + address + \" failed\");\n                return Promise.resolve({\n                    State: \"Unavailable\",\n                });\n            }\n\n            if (!address) {\n                return Promise.reject();\n            }\n\n            address = normalizeAddress(address);\n            var instance = this;\n            var server = {\n                ManualAddress: address,\n                LastConnectionMode: ConnectionMode.Manual\n            };\n            return self.connectToServer(server, options).catch(onFail);\n        };\n\n        self.deleteServer = function (serverId) {\n            if (!serverId) {\n                throw new Error(\"null serverId\");\n            }\n\n            var server = credentialProvider.credentials().Servers.filter(function (s) {\n                return s.Id === serverId;\n            });\n            server = server.length ? server[0] : null;\n            return new Promise(function (resolve, reject) {\n                function onDone() {\n                    var credentials = credentialProvider.credentials();\n                    credentials.Servers = credentials.Servers.filter(function (s) {\n                        return s.Id !== serverId;\n                    });\n                    credentialProvider.credentials(credentials);\n                    resolve();\n                }\n\n                if (!server.ConnectServerId) {\n                    return void onDone();\n                }\n            });\n        };\n    };\n\n    ConnectionManager.prototype.connect = function (options) {\n        console.debug(\"begin connect\");\n        var instance = this;\n        return instance.getAvailableServers().then(function (servers) {\n            return instance.connectToServers(servers, options);\n        });\n    };\n\n    ConnectionManager.prototype.getApiClients = function () {\n        var servers = this.getSavedServers();\n\n        for (var i = 0, length = servers.length; i < length; i++) {\n            var server = servers[i];\n\n            if (server.Id) {\n                this._getOrAddApiClient(server, getServerAddress(server, server.LastConnectionMode));\n            }\n        }\n\n        return this._apiClients;\n    };\n\n    ConnectionManager.prototype.getApiClient = function (item) {\n        if (!item) {\n            throw new Error(\"item or serverId cannot be null\");\n        }\n\n        if (item.ServerId) {\n            item = item.ServerId;\n        }\n\n        return this._apiClients.filter(function (a) {\n            var serverInfo = a.serverInfo();\n            return !serverInfo || serverInfo.Id === item;\n        })[0];\n    };\n\n    ConnectionManager.prototype.minServerVersion = function (val) {\n        if (val) {\n            this._minServerVersion = val;\n        }\n\n        return this._minServerVersion;\n    };\n\n    ConnectionManager.prototype.handleMessageReceived = function (msg) {\n        var serverId = msg.ServerId;\n\n        if (serverId) {\n            var apiClient = this.getApiClient(serverId);\n\n            if (apiClient) {\n                if (\"string\" == typeof msg.Data) {\n                    try {\n                        msg.Data = JSON.parse(msg.Data);\n                    } catch (err) {}\n                }\n\n                apiClient.handleMessageReceived(msg);\n            }\n        }\n    };\n\n    return ConnectionManager;\n});\n"]}