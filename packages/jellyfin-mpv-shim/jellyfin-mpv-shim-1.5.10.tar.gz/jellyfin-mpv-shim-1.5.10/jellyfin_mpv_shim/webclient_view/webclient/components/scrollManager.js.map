{"version":3,"sources":["components/scrollManager.js"],"names":["define","dom","browser","layoutManager","supportsSmoothScroll","document","documentElement","style","supportsScrollToOptions","elem","createElement","opts","Object","defineProperty","get","scrollTo","e","console","error","clamp","value","min","max","DocumentScroller","prototype","scrollLeft","window","pageXOffset","val","scroll","pageYOffset","scrollTop","scrollWidth","Math","body","scrollHeight","clientWidth","clientHeight","getBoundingClientRect","left","top","width","this","height","apply","arguments","scrollTimer","documentScroller","getScrollableParent","element","vertical","nameScroll","nameClient","nameClass","parent","parentElement","classList","contains","getScrollerData","scroller","data","scrollPos","scrollSize","clientSize","getScrollerChildPos","elementRect","scrollerRect","calcScroll","scrollerData","elementPos","elementSize","centered","maxScroll","delta","fitRange","begin1","end1","begin2","end2","delta1","delta2","round","scrollToHelper","options","scrollX","undefined","scrollY","builtinScroll","xScroller","yScroller","smooth","scrollBehavior","behavior","resetScrollTimer","cancelAnimationFrame","doScroll","useAnimatedScroll","animateScroll","start","ox","oy","dx","dy","abs","requestAnimationFrame","scrollAnim","currentTimestamp","k","ease","t","isEnabled","tv","scrollToElement","scrollCenterX","scrollCenterY","offsetParent","isFixed","getComputedStyle","position","xScrollerData","yScrollerData","xPos","yPos","bottom","minimumScrollY","topMenu","querySelector","addEventListener","setTimeout","target","useSmoothScroll","tizen","capture"],"mappings":"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","file":"scrollManager.js","sourcesContent":["define([\"dom\", \"browser\", \"layoutManager\"], function (dom, browser, layoutManager) {\n    \"use strict\";\n\n    /**\n     * Scroll time in ms.\n     */\n    var ScrollTime = 270;\n\n    /**\n     * Epsilon for comparing values.\n     */\n    var Epsilon = 1e-6;\n\n    // FIXME: Need to scroll to top of page to fully show the top menu. This can be solved by some marker of top most elements or their containers\n    /**\n     * Returns minimum vertical scroll.\n     * Scroll less than that value will be zeroed.\n     *\n     * @return {number} minimum vertical scroll\n     */\n    function minimumScrollY() {\n        var topMenu = document.querySelector(\".headerTop\");\n        if (topMenu) {\n            return topMenu.clientHeight;\n        }\n        return 0;\n    }\n\n    var supportsSmoothScroll = \"scrollBehavior\" in document.documentElement.style;\n\n    var supportsScrollToOptions = false;\n    try {\n        var elem = document.createElement(\"div\");\n\n        var opts = Object.defineProperty({}, \"behavior\", {\n            // eslint-disable-next-line getter-return\n            get: function () {\n                supportsScrollToOptions = true;\n            }\n        });\n\n        elem.scrollTo(opts);\n    } catch (e) {\n        console.error(\"error checking ScrollToOptions support\");\n    }\n\n    /**\n     * Returns value clamped by range [min, max].\n     *\n     * @param {number} value clamped value\n     * @param {number} min begining of range\n     * @param {number} max ending of range\n     * @return {number} clamped value\n     */\n    function clamp(value, min, max) {\n        return value <= min ? min : value >= max ? max : value;\n    }\n\n    /**\n     * Returns the required delta to fit range 1 into range 2.\n     * In case of range 1 is bigger than range 2 returns delta to fit most out of range part.\n     *\n     * @param {number} begin1 begining of range 1\n     * @param {number} end1 ending of range 1\n     * @param {number} begin2 begining of range 2\n     * @param {number} end2 ending of range 2\n     * @return {number} delta: <0 move range1 to the left, >0 - to the right\n     */\n    function fitRange(begin1, end1, begin2, end2) {\n        var delta1 = begin1 - begin2;\n        var delta2 = end2 - end1;\n        if (delta1 < 0 && delta1 < delta2) {\n            return -delta1;\n        } else if (delta2 < 0) {\n            return delta2;\n        }\n        return 0;\n    }\n\n    /**\n     * Ease value.\n     *\n     * @param {number} t value in range [0, 1]\n     * @return {number} eased value in range [0, 1]\n     */\n    function ease(t) {\n        return t*(2 - t); // easeOutQuad === ease-out\n    }\n\n    /**\n     * Document scroll wrapper helps to unify scrolling and fix issues of some browsers.\n     *\n     * webOS 2 Browser: scrolls documentElement (and window), but body has a scroll size\n     *\n     * webOS 3 Browser: scrolls body (and window)\n     *\n     * webOS 4 Native: scrolls body (and window); has a document.scrollingElement\n     *\n     * Tizen 4 Browser/Native: scrolls body (and window); has a document.scrollingElement\n     *\n     * Tizen 5 Browser/Native: scrolls documentElement (and window); has a document.scrollingElement\n     */\n    function DocumentScroller() {\n    }\n\n    DocumentScroller.prototype = {\n        get scrollLeft() {\n            return window.pageXOffset;\n        },\n        set scrollLeft(val) {\n            window.scroll(val, window.pageYOffset);\n        },\n\n        get scrollTop() {\n            return window.pageYOffset;\n        },\n        set scrollTop(val) {\n            window.scroll(window.pageXOffset, val);\n        },\n\n        get scrollWidth() {\n            return Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);\n        },\n\n        get scrollHeight() {\n            return Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);\n        },\n\n        get clientWidth() {\n            return Math.min(document.documentElement.clientWidth, document.body.clientWidth);\n        },\n\n        get clientHeight() {\n            return Math.min(document.documentElement.clientHeight, document.body.clientHeight);\n        },\n\n        getBoundingClientRect: function() {\n            // Make valid viewport coordinates: documentElement.getBoundingClientRect returns rect of entire document relative to viewport\n            return {\n                left: 0,\n                top: 0,\n                width: this.clientWidth,\n                height: this.clientHeight\n            };\n        },\n\n        scrollTo: function() {\n            window.scrollTo.apply(window, arguments);\n        }\n    };\n\n    var documentScroller = new DocumentScroller();\n\n    /**\n     * Returns parent element that can be scrolled. If no such, returns documentElement.\n     *\n     * @param {HTMLElement} element element for which parent is being searched\n     * @param {boolean} vertical search for vertical scrollable parent\n     */\n    function getScrollableParent(element, vertical) {\n        if (element) {\n            var nameScroll = \"scrollWidth\";\n            var nameClient = \"clientWidth\";\n            var nameClass = \"scrollX\";\n\n            if (vertical) {\n                nameScroll = \"scrollHeight\";\n                nameClient = \"clientHeight\";\n                nameClass = \"scrollY\";\n            }\n\n            var parent = element.parentElement;\n\n            while (parent) {\n                // Skip 'emby-scroller' because it scrolls by itself\n                if (!parent.classList.contains(\"emby-scroller\") &&\n                    parent[nameScroll] > parent[nameClient] && parent.classList.contains(nameClass)) {\n                    return parent;\n                }\n\n                parent = parent.parentElement;\n            }\n        }\n\n        return documentScroller;\n    }\n\n    /**\n     * @typedef {Object} ScrollerData\n     * @property {number} scrollPos current scroll position\n     * @property {number} scrollSize scroll size\n     * @property {number} clientSize client size\n     */\n\n    /**\n     * Returns scroll data for specified orientation.\n     *\n     * @param {HTMLElement} scroller scroller\n     * @param {boolean} vertical vertical scroll data\n     * @return {ScrollerData} scroll data\n     */\n    function getScrollerData(scroller, vertical) {\n        var data = {};\n\n        if (!vertical) {\n            data.scrollPos = scroller.scrollLeft;\n            data.scrollSize = scroller.scrollWidth;\n            data.clientSize = scroller.clientWidth;\n        } else {\n            data.scrollPos = scroller.scrollTop;\n            data.scrollSize = scroller.scrollHeight;\n            data.clientSize = scroller.clientHeight;\n        }\n\n        return data;\n    }\n\n    /**\n     * Returns position of child of scroller for specified orientation.\n     *\n     * @param {HTMLElement} scroller scroller\n     * @param {HTMLElement} element child of scroller\n     * @param {boolean} vertical vertical scroll\n     * @return {number} child position\n     */\n    function getScrollerChildPos(scroller, element, vertical) {\n        var elementRect = element.getBoundingClientRect();\n        var scrollerRect = scroller.getBoundingClientRect();\n\n        if (!vertical) {\n            return scroller.scrollLeft + elementRect.left - scrollerRect.left;\n        } else {\n            return scroller.scrollTop + elementRect.top - scrollerRect.top;\n        }\n    }\n\n    /**\n     * Returns scroll position for element.\n     *\n     * @param {ScrollerData} scrollerData scroller data\n     * @param {number} elementPos child element position\n     * @param {number} elementSize child element size\n     * @param {boolean} centered scroll to center\n     * @return {number} scroll position\n     */\n    function calcScroll(scrollerData, elementPos, elementSize, centered) {\n        var maxScroll = scrollerData.scrollSize - scrollerData.clientSize;\n\n        var scroll;\n\n        if (centered) {\n            scroll = elementPos + (elementSize - scrollerData.clientSize) / 2;\n        } else {\n            var delta = fitRange(elementPos, elementPos + elementSize - 1, scrollerData.scrollPos, scrollerData.scrollPos + scrollerData.clientSize - 1);\n            scroll = scrollerData.scrollPos - delta;\n        }\n\n        return clamp(Math.round(scroll), 0, maxScroll);\n    }\n\n    /**\n     * Calls scrollTo function in proper way.\n     *\n     * @param {HTMLElement} scroller scroller\n     * @param {ScrollToOptions} options scroll options\n     */\n    function scrollToHelper(scroller, options) {\n        if (\"scrollTo\" in scroller) {\n            if (!supportsScrollToOptions) {\n                var scrollX = (options.left !== undefined ? options.left : scroller.scrollLeft);\n                var scrollY = (options.top !== undefined ? options.top : scroller.scrollTop);\n                scroller.scrollTo(scrollX, scrollY);\n            } else {\n                scroller.scrollTo(options);\n            }\n        } else if (\"scrollLeft\" in scroller) {\n            if (options.left !== undefined) {\n                scroller.scrollLeft = options.left;\n            }\n            if (options.top !== undefined) {\n                scroller.scrollTop = options.top;\n            }\n        }\n    }\n\n    /**\n     * Performs built-in scroll.\n     *\n     * @param {HTMLElement} xScroller horizontal scroller\n     * @param {number} scrollX horizontal coordinate\n     * @param {HTMLElement} yScroller vertical scroller\n     * @param {number} scrollY vertical coordinate\n     * @param {boolean} smooth smooth scrolling\n     */\n    function builtinScroll(xScroller, scrollX, yScroller, scrollY, smooth) {\n        var scrollBehavior = smooth ? \"smooth\" : \"instant\";\n\n        if (xScroller !== yScroller) {\n            scrollToHelper(xScroller, {left: scrollX, behavior: scrollBehavior});\n            scrollToHelper(yScroller, {top: scrollY, behavior: scrollBehavior});\n        } else {\n            scrollToHelper(xScroller, {left: scrollX, top: scrollY, behavior: scrollBehavior});\n        }\n    }\n\n    var scrollTimer;\n\n    /**\n     * Resets scroll timer to stop scrolling.\n     */\n    function resetScrollTimer() {\n        cancelAnimationFrame(scrollTimer);\n        scrollTimer = undefined;\n    }\n\n    /**\n     * Performs animated scroll.\n     *\n     * @param {HTMLElement} xScroller horizontal scroller\n     * @param {number} scrollX horizontal coordinate\n     * @param {HTMLElement} yScroller vertical scroller\n     * @param {number} scrollY vertical coordinate\n     */\n    function animateScroll(xScroller, scrollX, yScroller, scrollY) {\n\n        var ox = xScroller.scrollLeft;\n        var oy = yScroller.scrollTop;\n        var dx = scrollX - ox;\n        var dy = scrollY - oy;\n\n        if (Math.abs(dx) < Epsilon && Math.abs(dy) < Epsilon) {\n            return;\n        }\n\n        var start;\n\n        function scrollAnim(currentTimestamp) {\n\n            start = start || currentTimestamp;\n\n            var k = Math.min(1, (currentTimestamp - start) / ScrollTime);\n\n            if (k === 1) {\n                resetScrollTimer();\n                builtinScroll(xScroller, scrollX, yScroller, scrollY, false);\n                return;\n            }\n\n            k = ease(k);\n\n            var x = ox + dx*k;\n            var y = oy + dy*k;\n\n            builtinScroll(xScroller, x, yScroller, y, false);\n\n            scrollTimer = requestAnimationFrame(scrollAnim);\n        }\n\n        scrollTimer = requestAnimationFrame(scrollAnim);\n    }\n\n    /**\n     * Performs scroll.\n     *\n     * @param {HTMLElement} xScroller horizontal scroller\n     * @param {number} scrollX horizontal coordinate\n     * @param {HTMLElement} yScroller vertical scroller\n     * @param {number} scrollY vertical coordinate\n     * @param {boolean} smooth smooth scrolling\n     */\n    function doScroll(xScroller, scrollX, yScroller, scrollY, smooth) {\n\n        resetScrollTimer();\n\n        if (smooth && useAnimatedScroll()) {\n            animateScroll(xScroller, scrollX, yScroller, scrollY);\n        } else {\n            builtinScroll(xScroller, scrollX, yScroller, scrollY, smooth);\n        }\n    }\n\n    /**\n     * Returns true if smooth scroll must be used.\n     */\n    function useSmoothScroll() {\n\n        if (browser.tizen) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if animated implementation of smooth scroll must be used.\n     */\n    function useAnimatedScroll() {\n        // Add block to force using (or not) of animated implementation\n\n        return !supportsSmoothScroll;\n    }\n\n    /**\n     * Returns true if scroll manager is enabled.\n     */\n    var isEnabled = function() {\n        return layoutManager.tv;\n    };\n\n    /**\n     * Scrolls the document to a given position.\n     *\n     * @param {number} scrollX horizontal coordinate\n     * @param {number} scrollY vertical coordinate\n     * @param {boolean} [smooth=false] smooth scrolling\n     */\n    var scrollTo = function(scrollX, scrollY, smooth) {\n\n        smooth = !!smooth;\n\n        // Scroller is document itself by default\n        var scroller = getScrollableParent(null, false);\n\n        var xScrollerData = getScrollerData(scroller, false);\n        var yScrollerData = getScrollerData(scroller, true);\n\n        scrollX = clamp(Math.round(scrollX), 0, xScrollerData.scrollSize - xScrollerData.clientSize);\n        scrollY = clamp(Math.round(scrollY), 0, yScrollerData.scrollSize - yScrollerData.clientSize);\n\n        doScroll(scroller, scrollX, scroller, scrollY, smooth);\n    }\n\n    /**\n     * Scrolls the document to a given element.\n     *\n     * @param {HTMLElement} element target element of scroll task\n     * @param {boolean} [smooth=false] smooth scrolling\n     */\n    var scrollToElement = function(element, smooth) {\n\n        smooth = !!smooth;\n\n        var scrollCenterX = true;\n        var scrollCenterY = true;\n\n        var offsetParent = element.offsetParent;\n\n        // In Firefox offsetParent.offsetParent is BODY\n        var isFixed = offsetParent && (!offsetParent.offsetParent || window.getComputedStyle(offsetParent).position === \"fixed\");\n\n        // Scroll fixed elements to nearest edge (or do not scroll at all)\n        if (isFixed) {\n            scrollCenterX = scrollCenterY = false;\n        }\n\n        var xScroller = getScrollableParent(element, false);\n        var yScroller = getScrollableParent(element, true);\n\n        var elementRect = element.getBoundingClientRect();\n\n        var xScrollerData = getScrollerData(xScroller, false);\n        var yScrollerData = getScrollerData(yScroller, true);\n\n        var xPos = getScrollerChildPos(xScroller, element, false);\n        var yPos = getScrollerChildPos(yScroller, element, true);\n\n        var scrollX = calcScroll(xScrollerData, xPos, elementRect.width, scrollCenterX);\n        var scrollY = calcScroll(yScrollerData, yPos, elementRect.height, scrollCenterY);\n\n        // HACK: Scroll to top for top menu because it is hidden\n        // FIXME: Need a marker to scroll top/bottom\n        if (isFixed && elementRect.bottom < 0) {\n            scrollY = 0;\n        }\n\n        // HACK: Ensure we are at the top\n        // FIXME: Need a marker to scroll top/bottom\n        if (scrollY < minimumScrollY() && yScroller === documentScroller) {\n            scrollY = 0;\n        }\n\n        doScroll(xScroller, scrollX, yScroller, scrollY, smooth);\n    }\n\n    if (isEnabled()) {\n        dom.addEventListener(window, \"focusin\", function(e) {\n            setTimeout(function() {\n                scrollToElement(e.target, useSmoothScroll());\n            }, 0);\n        }, {capture: true});\n    }\n\n    return {\n        isEnabled: isEnabled,\n        scrollTo: scrollTo,\n        scrollToElement: scrollToElement\n    };\n});\n"]}