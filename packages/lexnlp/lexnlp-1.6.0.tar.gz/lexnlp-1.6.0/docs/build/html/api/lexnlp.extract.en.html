
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>lexnlp.extract.en package &#8212; LexNLP 1.6.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="lexnlp-extract-en-package">
<h1>lexnlp.extract.en package<a class="headerlink" href="#lexnlp-extract-en-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="lexnlp.extract.en.addresses.html">lexnlp.extract.en.addresses package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.addresses.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lexnlp.extract.en.addresses.tests.html">lexnlp.extract.en.addresses.tests package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.addresses.tests.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.addresses.tests.html#module-lexnlp.extract.en.addresses.tests.test_addresses">lexnlp.extract.en.addresses.tests.test_addresses module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.addresses.tests.html#module-lexnlp.extract.en.addresses.tests">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.addresses.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.addresses.html#module-lexnlp.extract.en.addresses.address_features">lexnlp.extract.en.addresses.address_features module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.addresses.html#module-lexnlp.extract.en.addresses.addresses">lexnlp.extract.en.addresses.addresses module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.addresses.html#module-lexnlp.extract.en.addresses">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lexnlp.extract.en.contracts.html">lexnlp.extract.en.contracts package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.contracts.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lexnlp.extract.en.contracts.tests.html">lexnlp.extract.en.contracts.tests package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.contracts.tests.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.contracts.tests.html#module-lexnlp.extract.en.contracts.tests.test_contracts">lexnlp.extract.en.contracts.tests.test_contracts module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.contracts.tests.html#module-lexnlp.extract.en.contracts.tests">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.contracts.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.contracts.html#module-lexnlp.extract.en.contracts.detector">lexnlp.extract.en.contracts.detector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.contracts.html#module-lexnlp.extract.en.contracts">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lexnlp.extract.en.entities.html">lexnlp.extract.en.entities package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html">lexnlp.extract.en.entities.tests package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#module-lexnlp.extract.en.entities.tests.test_get_companies">lexnlp.extract.en.entities.tests.test_get_companies module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#module-lexnlp.extract.en.entities.tests.test_nltk_maxent">lexnlp.extract.en.entities.tests.test_nltk_maxent module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#module-lexnlp.extract.en.entities.tests.test_nltk_re">lexnlp.extract.en.entities.tests.test_nltk_re module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#module-lexnlp.extract.en.entities.tests.test_stanford_ner">lexnlp.extract.en.entities.tests.test_stanford_ner module</a></li>
<li class="toctree-l4"><a class="reference internal" href="lexnlp.extract.en.entities.tests.html#module-lexnlp.extract.en.entities.tests">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#module-lexnlp.extract.en.entities.nltk_maxent">lexnlp.extract.en.entities.nltk_maxent module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#module-lexnlp.extract.en.entities.nltk_re">lexnlp.extract.en.entities.nltk_re module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#module-lexnlp.extract.en.entities.nltk_tokenizer">lexnlp.extract.en.entities.nltk_tokenizer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#module-lexnlp.extract.en.entities.stanford_ner">lexnlp.extract.en.entities.stanford_ner module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.entities.html#module-lexnlp.extract.en.entities">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lexnlp.extract.en.preprocessing.html">lexnlp.extract.en.preprocessing package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.preprocessing.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.preprocessing.html#module-lexnlp.extract.en.preprocessing.span_tokenizer">lexnlp.extract.en.preprocessing.span_tokenizer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.preprocessing.html#module-lexnlp.extract.en.preprocessing">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lexnlp.extract.en.tests.html">lexnlp.extract.en.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_acts">lexnlp.extract.en.tests.test_acts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_amounts">lexnlp.extract.en.tests.test_amounts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_amounts_plain">lexnlp.extract.en.tests.test_amounts_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_citations">lexnlp.extract.en.tests.test_citations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_citations_plain">lexnlp.extract.en.tests.test_citations_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_conditions">lexnlp.extract.en.tests.test_conditions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_conditions_plain">lexnlp.extract.en.tests.test_conditions_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_constraints">lexnlp.extract.en.tests.test_constraints module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_constraints_plain">lexnlp.extract.en.tests.test_constraints_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_copyright">lexnlp.extract.en.tests.test_copyright module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_copyright_plain">lexnlp.extract.en.tests.test_copyright_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_courts">lexnlp.extract.en.tests.test_courts module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_cusip">lexnlp.extract.en.tests.test_cusip module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_dates">lexnlp.extract.en.tests.test_dates module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_dates_plain">lexnlp.extract.en.tests.test_dates_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_definitions">lexnlp.extract.en.tests.test_definitions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_definitions_template">lexnlp.extract.en.tests.test_definitions_template module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_dict_entities">lexnlp.extract.en.tests.test_dict_entities module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_distance">lexnlp.extract.en.tests.test_distance module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_distances_plain">lexnlp.extract.en.tests.test_distances_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_durations">lexnlp.extract.en.tests.test_durations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_durations_plain">lexnlp.extract.en.tests.test_durations_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_geoentities">lexnlp.extract.en.tests.test_geoentities module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_geoentities_plain">lexnlp.extract.en.tests.test_geoentities_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_introductory_words_detector">lexnlp.extract.en.tests.test_introductory_words_detector module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_money">lexnlp.extract.en.tests.test_money module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_money_plain">lexnlp.extract.en.tests.test_money_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_parsing_speed">lexnlp.extract.en.tests.test_parsing_speed module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_percent_plain">lexnlp.extract.en.tests.test_percent_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_percents">lexnlp.extract.en.tests.test_percents module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_phone_plain">lexnlp.extract.en.tests.test_phone_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_pii">lexnlp.extract.en.tests.test_pii module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_ratios">lexnlp.extract.en.tests.test_ratios module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_ratios_plain">lexnlp.extract.en.tests.test_ratios_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_regulations">lexnlp.extract.en.tests.test_regulations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_regulations_plain">lexnlp.extract.en.tests.test_regulations_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_span_tokenizer">lexnlp.extract.en.tests.test_span_tokenizer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_ssn_plain">lexnlp.extract.en.tests.test_ssn_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_trademarks">lexnlp.extract.en.tests.test_trademarks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_trademarks_plain">lexnlp.extract.en.tests.test_trademarks_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_urls">lexnlp.extract.en.tests.test_urls module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests.test_urls_plain">lexnlp.extract.en.tests.test_urls_plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexnlp.extract.en.tests.html#module-lexnlp.extract.en.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-lexnlp.extract.en.acts">
<span id="lexnlp-extract-en-acts-module"></span><h2>lexnlp.extract.en.acts module<a class="headerlink" href="#module-lexnlp.extract.en.acts" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lexnlp.extract.en.acts.get_act_list">
<code class="sig-prename descclassname">lexnlp.extract.en.acts.</code><code class="sig-name descname">get_act_list</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; List[Dict[str, str]]<a class="headerlink" href="#lexnlp.extract.en.acts.get_act_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.acts.get_acts">
<code class="sig-prename descclassname">lexnlp.extract.en.acts.</code><code class="sig-name descname">get_acts</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[Dict[str, Any], None], None]<a class="headerlink" href="#lexnlp.extract.en.acts.get_acts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.acts.get_acts_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.acts.</code><code class="sig-name descname">get_acts_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.act_annotation.ActAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.acts.get_acts_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.acts.get_acts_annotations_list">
<code class="sig-prename descclassname">lexnlp.extract.en.acts.</code><code class="sig-name descname">get_acts_annotations_list</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.common.annotations.act_annotation.ActAnnotation]<a class="headerlink" href="#lexnlp.extract.en.acts.get_acts_annotations_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.amounts">
<span id="lexnlp-extract-en-amounts-module"></span><h2>lexnlp.extract.en.amounts module<a class="headerlink" href="#module-lexnlp.extract.en.amounts" title="Permalink to this headline">¶</a></h2>
<p>Amount extraction for English.</p>
<p>This module implements basic amount extraction functionality in English.</p>
<p>This module supports converting:
- numbers with comma delimiter: “25,000.00”, “123,456,000”
- written numbers: “Seven Hundred Eighty”
- mixed written numbers: “5 million” or “2.55 BILLION”
- written ordinal numbers: “twenty-fifth”
- fractions (non written): “1/33”, “25/100”; where 1 &lt; numerator &lt; 99; 1 &lt; denominator &lt; 999
- fraction No/100 wil be treated as 00/100
- written numbers and fractions: “twenty one AND 5/100”
- written fractions: “one-third”, “three tenths”, “ten ninety-ninths”, “twenty AND one-hundredths”,</p>
<blockquote>
<div><dl class="simple">
<dt>“2 hundred and one-thousandth”;</dt><dd><p>where 1 &lt; numerator &lt; 99 and 2 &lt; denominator &lt; 99 and numerator &lt; denominator;
or 1 &lt; numerator &lt; 99 and denominator == 100, i.e. 1/99 - 99/100;
or 1 &lt; numerator &lt; 99 and denominator == 1000, i.e. 1/1000 - 99/1000;</p>
</dd>
</dl>
</div></blockquote>
<ul class="simple">
<li><p>floats starting with “.” (dot): “.5 million”</p></li>
<li><p>“dozen”: “twenty-two DOZEN”</p></li>
<li><p>“half”: “Six and a HALF Billion”, “two and a half”</p></li>
<li><p>“quarter”: “five and one-quarter”, “5 and one-quarter”, “three-quartes”</p></li>
<li><p>multiple numbers: “$25,400, 1 million people and 3.5 tons”</p></li>
</ul>
<p>Avoids:
- skip: “5.3.1.”, “1/1/2010”</p>
<dl class="function">
<dt id="lexnlp.extract.en.amounts.get_amount_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.amounts.</code><code class="sig-name descname">get_amount_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">extended_sources=True</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.amount_annotation.AmountAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.amounts.get_amount_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible amount references in the text.
:param text: text
:param extended_sources: return data around amount itself
:param float_digits: round float to N digits, don’t round if None
:return: list of amounts</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.amounts.get_amounts">
<code class="sig-prename descclassname">lexnlp.extract.en.amounts.</code><code class="sig-name descname">get_amounts</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">extended_sources=True</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[float, None], None]<a class="headerlink" href="#lexnlp.extract.en.amounts.get_amounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible amount references in the text.
:param text: text
:param return_sources: return amount AND source text
:param extended_sources: return data around amount itself
:param float_digits: round float to N digits, don’t round if None
:return: list of amounts</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.amounts.get_np">
<code class="sig-prename descclassname">lexnlp.extract.en.amounts.</code><code class="sig-name descname">get_np</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.amounts.get_np" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.amounts.text2num">
<code class="sig-prename descclassname">lexnlp.extract.en.amounts.</code><code class="sig-name descname">text2num</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">search_fraction=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.amounts.text2num" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert written amount into integer/float.
:param s: written number
:param search_fraction: extract fraction
:return: integer/float</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.citations">
<span id="lexnlp-extract-en-citations-module"></span><h2>lexnlp.extract.en.citations module<a class="headerlink" href="#module-lexnlp.extract.en.citations" title="Permalink to this headline">¶</a></h2>
<p>Citation extraction for English.</p>
<p>This module implements citation extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.citations.get_citation_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.citations.</code><code class="sig-name descname">get_citation_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.citation_annotation.CitationAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.citations.get_citation_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get citations.
:param text:
:param return_source:
:param as_dict:
:return: tuple or dict
(volume, reporter, reporter_full_name, page, page2, court, year[, source text])</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.citations.get_citations">
<code class="sig-prename descclassname">lexnlp.extract.en.citations.</code><code class="sig-name descname">get_citations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_source=False</em>, <em class="sig-param">as_dict=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.citations.get_citations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get citations.
:param text:
:param return_source:
:param as_dict:
:return: tuple or dict
(volume, reporter, reporter_full_name, page, page2, court, year[, source text])</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.conditions">
<span id="lexnlp-extract-en-conditions-module"></span><h2>lexnlp.extract.en.conditions module<a class="headerlink" href="#module-lexnlp.extract.en.conditions" title="Permalink to this headline">¶</a></h2>
<p>Condition extraction for English.</p>
<p>This module implements basic condition extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.conditions.create_condition_pattern">
<code class="sig-prename descclassname">lexnlp.extract.en.conditions.</code><code class="sig-name descname">create_condition_pattern</code><span class="sig-paren">(</span><em class="sig-param">condition_pattern_template</em>, <em class="sig-param">condition_phrases</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.conditions.create_condition_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Create condition pattern.
:param condition_pattern_template:
:param condition_phrases:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.conditions.get_condition_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.conditions.</code><code class="sig-name descname">get_condition_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">strict=True</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.condition_annotation.ConditionAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.conditions.get_condition_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible conditions in natural language.
:param text:
:param strict:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.conditions.get_conditions">
<code class="sig-prename descclassname">lexnlp.extract.en.conditions.</code><code class="sig-name descname">get_conditions</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">strict=True</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.conditions.get_conditions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.constraints">
<span id="lexnlp-extract-en-constraints-module"></span><h2>lexnlp.extract.en.constraints module<a class="headerlink" href="#module-lexnlp.extract.en.constraints" title="Permalink to this headline">¶</a></h2>
<p>Constraint extraction for English.</p>
<p>This module implements basic constraint extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.constraints.create_constraint_pattern">
<code class="sig-prename descclassname">lexnlp.extract.en.constraints.</code><code class="sig-name descname">create_constraint_pattern</code><span class="sig-paren">(</span><em class="sig-param">constraint_pattern_template</em>, <em class="sig-param">constraint_phrases</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.constraints.create_constraint_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Create constraint pattern.
:param constraint_pattern_template:
:param constraint_phrases:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.constraints.get_constraint_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.constraints.</code><code class="sig-name descname">get_constraint_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">strict=False</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.constraint_annotation.ConstraintAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.constraints.get_constraint_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible constraints in natural language.
:param text:
:param strict:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.constraints.get_constraints">
<code class="sig-prename descclassname">lexnlp.extract.en.constraints.</code><code class="sig-name descname">get_constraints</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">strict=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.constraints.get_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible constraints in natural language.
:param text:
:param strict:
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.copyright">
<span id="lexnlp-extract-en-copyright-module"></span><h2>lexnlp.extract.en.copyright module<a class="headerlink" href="#module-lexnlp.extract.en.copyright" title="Permalink to this headline">¶</a></h2>
<p>Copyright extraction for English using NLTK and NLTK pre-trained maximum entropy classifier.</p>
<p>This module implements basic Copyright extraction functionality in English relying on the pre-trained
NLTK functionality, including POS tagger and NE (fuzzy) chunkers.</p>
<p>Todo: -</p>
<dl class="class">
<dt id="lexnlp.extract.en.copyright.CopyrightEnParser">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.copyright.</code><code class="sig-name descname">CopyrightEnParser</code><a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightEnParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lexnlp.extract.common.copyrights.html#lexnlp.extract.common.copyrights.copyright_en_style_parser.CopyrightEnStyleParser" title="lexnlp.extract.common.copyrights.copyright_en_style_parser.CopyrightEnStyleParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">lexnlp.extract.common.copyrights.copyright_en_style_parser.CopyrightEnStyleParser</span></code></a></p>
<dl class="method">
<dt id="lexnlp.extract.en.copyright.CopyrightEnParser.extract_phrases_with_coords">
<em class="property">classmethod </em><code class="sig-name descname">extract_phrases_with_coords</code><span class="sig-paren">(</span><em class="sig-param">sentence: str</em><span class="sig-paren">)</span> &#x2192; List[Tuple[str, int, int]]<a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightEnParser.extract_phrases_with_coords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lexnlp.extract.en.copyright.CopyrightNPExtractor">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.copyright.</code><code class="sig-name descname">CopyrightNPExtractor</code><span class="sig-paren">(</span><em class="sig-param">grammar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightNPExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lexnlp.extract.en.utils.NPExtractor.html#lexnlp.extract.en.utils.NPExtractor" title="lexnlp.extract.en.utils.NPExtractor"><code class="xref py py-class docutils literal notranslate"><span class="pre">lexnlp.extract.en.utils.NPExtractor</span></code></a></p>
<dl class="attribute">
<dt id="lexnlp.extract.en.copyright.CopyrightNPExtractor.allowed_pos">
<code class="sig-name descname">allowed_pos</code><em class="property"> = ['IN', 'CC', 'NN']</em><a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightNPExtractor.allowed_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.copyright.CopyrightNPExtractor.allowed_sym">
<code class="sig-name descname">allowed_sym</code><em class="property"> = ['&amp;', 'and', 'of', '©']</em><a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightNPExtractor.allowed_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.copyright.CopyrightNPExtractor.strip_np">
<em class="property">static </em><code class="sig-name descname">strip_np</code><span class="sig-paren">(</span><em class="sig-param">np</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.copyright.CopyrightNPExtractor.strip_np" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.copyright.get_copyright">
<code class="sig-prename descclassname">lexnlp.extract.en.copyright.</code><code class="sig-name descname">get_copyright</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.copyright.get_copyright" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.copyright.get_copyright_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.copyright.</code><code class="sig-name descname">get_copyright_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.copyright_annotation.CopyrightAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.copyright.get_copyright_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.courts">
<span id="lexnlp-extract-en-courts-module"></span><h2>lexnlp.extract.en.courts module<a class="headerlink" href="#module-lexnlp.extract.en.courts" title="Permalink to this headline">¶</a></h2>
<p>Court extraction for English.</p>
<p>This module implements extraction functionality for courts in English, including formal names, abbreviations,
and aliases.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Add utilities for loading court data</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.courts.get_court_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.courts.</code><code class="sig-name descname">get_court_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">language: str = None</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.court_annotation.CourtAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.courts.get_court_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.courts.get_courts">
<code class="sig-prename descclassname">lexnlp.extract.en.courts.</code><code class="sig-name descname">get_courts</code><span class="sig-paren">(</span><em class="sig-param">text: str, court_config_list: List[Tuple[int, str, int, List[Tuple[str, str, bool, int]]]], priority: bool = False, text_languages: List[str] = None</em><span class="sig-paren">)</span> &#x2192; Generator[[Tuple[Tuple, Tuple], Any], Any]<a class="headerlink" href="#lexnlp.extract.en.courts.get_courts" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for courts from the provided config list and yields tuples of (court_config, court_alias).
Court config is: (court_id, court_name, [list of aliases])
Alias is: (alias_text, language, is_abbrev, alias_id)</p>
<p>This method uses general searching routines for dictionary entities from dict_entities.py module.
Methods of dict_entities module can be used for comfortable creating the config: entity_config(),
entity_alias(), add_aliases_to_entity().
:param text:
:param court_config_list: List list of all possible known courts in the form of tuples:</p>
<blockquote>
<div><p>(id, name, [(alias, lang, is_abbrev], …).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>return_source</strong> – </p></li>
<li><p><strong>priority</strong> – If two courts found with the totally equal matching aliases - then use the one with the lowest id.</p></li>
<li><p><strong>text_languages</strong> – Language(s) of the source text. If a language is specified then only aliases of this</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>language will be searched for. For example: this allows ignoring “Island” - a German language</dt><dd><p>alias of Iceland for English texts.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Generates tuples: (court entity, court alias)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.courts.setup_en_parser">
<code class="sig-prename descclassname">lexnlp.extract.en.courts.</code><code class="sig-name descname">setup_en_parser</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.courts.setup_en_parser" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.cusip">
<span id="lexnlp-extract-en-cusip-module"></span><h2>lexnlp.extract.en.cusip module<a class="headerlink" href="#module-lexnlp.extract.en.cusip" title="Permalink to this headline">¶</a></h2>
<p>Ratio extraction for English.</p>
<p>This module implements ratio extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.cusip.get_cusip">
<code class="sig-prename descclassname">lexnlp.extract.en.cusip.</code><code class="sig-name descname">get_cusip</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[Dict[str, Any], None], None]<a class="headerlink" href="#lexnlp.extract.en.cusip.get_cusip" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.cusip.get_cusip_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.cusip.</code><code class="sig-name descname">get_cusip_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.cusip_annotation.CusipAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.cusip.get_cusip_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>INFO: <a class="reference external" href="https://www.cusip.com/pdf/CUSIP_Intro_03.14.11.pdf">https://www.cusip.com/pdf/CUSIP_Intro_03.14.11.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.cusip.get_cusip_list">
<code class="sig-prename descclassname">lexnlp.extract.en.cusip.</code><code class="sig-name descname">get_cusip_list</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.cusip.get_cusip_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.cusip.is_cusip_valid">
<code class="sig-prename descclassname">lexnlp.extract.en.cusip.</code><code class="sig-name descname">is_cusip_valid</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">return_checksum=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.cusip.is_cusip_valid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.date_model">
<span id="lexnlp-extract-en-date-model-module"></span><h2>lexnlp.extract.en.date_model module<a class="headerlink" href="#module-lexnlp.extract.en.date_model" title="Permalink to this headline">¶</a></h2>
<p>Date extraction for English.</p>
<p>This module implements date extraction functionality in English.</p>
<dl class="function">
<dt id="lexnlp.extract.en.date_model.get_date_features">
<code class="sig-prename descclassname">lexnlp.extract.en.date_model.</code><code class="sig-name descname">get_date_features</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">start_index</em>, <em class="sig-param">end_index</em>, <em class="sig-param">include_bigrams=True</em>, <em class="sig-param">window=5</em>, <em class="sig-param">characters=None</em>, <em class="sig-param">norm=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.date_model.get_date_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Get features to use for classification of date as false positive.
:param text: raw text around potential date
:param start_index: date start index
:param end_index: date end index
:param include_bigrams: whether to include bigram/bicharacter features
:param window: window around match
:param characters: characters to use for feature generation, e.g., digits only, alpha only
:param norm: whether to norm, i.e., transform to proportion
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.dates">
<span id="lexnlp-extract-en-dates-module"></span><h2>lexnlp.extract.en.dates module<a class="headerlink" href="#module-lexnlp.extract.en.dates" title="Permalink to this headline">¶</a></h2>
<p>Date extraction for English.</p>
<p>This module implements date extraction functionality in English.</p>
<dl class="function">
<dt id="lexnlp.extract.en.dates.build_date_model">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">build_date_model</code><span class="sig-paren">(</span><em class="sig-param">input_examples</em>, <em class="sig-param">output_file</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dates.build_date_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a sklearn model for classifying date strings as potential false positives.
:param input_examples:
:param output_file:
:param verbose:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.check_date_parts_are_in_date">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">check_date_parts_are_in_date</code><span class="sig-paren">(</span><em class="sig-param">date: datetime.datetime, date_props: Dict[str, List[Any]]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lexnlp.extract.en.dates.check_date_parts_are_in_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that when we transformed “possible date” into date, we found
place for each “token” from the initial phrase
:param date:
:param date_string: “13.2 may”
:param date_props: {‘time’: [], ‘hours’: [] … ‘digits’: [‘13’, ‘2’] …}
:return: True if date is OK</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_date_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_date_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">base_date=None</em>, <em class="sig-param">threshold=0.5</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.date_annotation.DateAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.dates.get_date_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find dates after cleaning false positives.
:param text: raw text to search
:param strict: whether to return only complete or strict matches
:param base_date: base date to use for implied or partial matches
:param return_source: whether to return raw text around date
:param threshold: probability threshold to use for false positive classifier
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_date_features">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_date_features</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">start_index</em>, <em class="sig-param">end_index</em>, <em class="sig-param">include_bigrams=True</em>, <em class="sig-param">window=5</em>, <em class="sig-param">characters=None</em>, <em class="sig-param">norm=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dates.get_date_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Get features to use for classification of date as false positive.
:param text: raw text around potential date
:param start_index: date start index
:param end_index: date end index
:param include_bigrams: whether to include bigram/bicharacter features
:param window: window around match
:param characters: characters to use for feature generation, e.g., digits only, alpha only
:param norm: whether to norm, i.e., transform to proportion
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_dates">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_dates</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">base_date=None</em>, <em class="sig-param">return_source=False</em>, <em class="sig-param">threshold=0.5</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.dates.get_dates" title="Permalink to this definition">¶</a></dt>
<dd><p>Find dates after cleaning false positives.
:param text: raw text to search
:param strict: whether to return only complete or strict matches
:param base_date: base date to use for implied or partial matches
:param return_source: whether to return raw text around date
:param threshold: probability threshold to use for false positive classifier
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_dates_list">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_dates_list</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span> &#x2192; List<a class="headerlink" href="#lexnlp.extract.en.dates.get_dates_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_month_by_name">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_month_by_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dates.get_month_by_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_raw_date_list">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_raw_date_list</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">base_date=None</em>, <em class="sig-param">return_source=False</em><span class="sig-paren">)</span> &#x2192; List<a class="headerlink" href="#lexnlp.extract.en.dates.get_raw_date_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.get_raw_dates">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">get_raw_dates</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">strict=False</em>, <em class="sig-param">base_date=None</em>, <em class="sig-param">return_source=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.dates.get_raw_dates" title="Permalink to this definition">¶</a></dt>
<dd><p>Find “raw” or potential date matches prior to false positive classification.
:param text: raw text to search
:param strict: whether to return only complete or strict matches
:param base_date: base date to use for implied or partial matches
:param return_source: whether to return raw text around date
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dates.train_default_model">
<code class="sig-prename descclassname">lexnlp.extract.en.dates.</code><code class="sig-name descname">train_default_model</code><span class="sig-paren">(</span><em class="sig-param">save=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dates.train_default_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Train default model.
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.definition_parsing_methods">
<span id="lexnlp-extract-en-definition-parsing-methods-module"></span><h2>lexnlp.extract.en.definition_parsing_methods module<a class="headerlink" href="#module-lexnlp.extract.en.definition_parsing_methods" title="Permalink to this headline">¶</a></h2>
<p>Definition extraction for English.</p>
<p>This module implements basic definition extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="lexnlp.extract.en.definition_parsing_methods.DefinitionCaught">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">DefinitionCaught</code><span class="sig-paren">(</span><em class="sig-param">name: str, text: str, coords: Tuple[int, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.DefinitionCaught" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each definition is stored in this class with
its name, full text and “coords” within the whole document</p>
<dl class="attribute">
<dt id="lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.coords">
<code class="sig-name descname">coords</code><a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.coords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.does_consume_target">
<code class="sig-name descname">does_consume_target</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.does_consume_target" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>target</strong> – a definition that is, probably, “consumed” by the current one</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1 if self consumes the target, -1 if the target consumes self, overwise 0</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.text">
<code class="sig-name descname">text</code><a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.DefinitionCaught.text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.does_term_are_service_words">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">does_term_are_service_words</code><span class="sig-paren">(</span><em class="sig-param">term_pos: List[Tuple[str, str, int, int]]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.does_term_are_service_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Does term consist of service words only?</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.filter_definitions_for_self_repeating">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">filter_definitions_for_self_repeating</code><span class="sig-paren">(</span><em class="sig-param">definitions: List[lexnlp.extract.en.definition_parsing_methods.DefinitionCaught]</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.en.definition_parsing_methods.DefinitionCaught]<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.filter_definitions_for_self_repeating" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>definitions</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>excludes definitions that are “overlapped”, leaves unique definitions only</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.get_definition_list_in_sentence">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">get_definition_list_in_sentence</code><span class="sig-paren">(</span><em class="sig-param">sentence_coords: Tuple[int, int, str], decode_unicode=True</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.en.definition_parsing_methods.DefinitionCaught]<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.get_definition_list_in_sentence" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible definitions in natural language in a single sentence.
:param sentence_coords: sentence, sentence start, end
:param decode_unicode:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.get_quotes_count_in_string">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">get_quotes_count_in_string</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.get_quotes_count_in_string" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>text</strong> – text to calculate quotes within</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>calculates count of quotes within the text passed</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.join_collection">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">join_collection</code><span class="sig-paren">(</span><em class="sig-param">collection</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.join_collection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.regex_matches_to_word_coords">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">regex_matches_to_word_coords</code><span class="sig-paren">(</span><em class="sig-param">pattern: Pattern[str], text: str, phrase_start: int = 0</em><span class="sig-paren">)</span> &#x2192; List[Tuple[str, int, int]]<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.regex_matches_to_word_coords" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> – pattern for searching for matches within the text</p></li>
<li><p><strong>text</strong> – text to search for matches</p></li>
<li><p><strong>phrase_start</strong> – a value to be add to start / end</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuples of (match_text, start, end) out of the regex (pattern) matches in text</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.split_definitions_inside_term">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">split_definitions_inside_term</code><span class="sig-paren">(</span><em class="sig-param">term: str, src_with_coords: Tuple[int, int, str], term_start: int, term_end: int</em><span class="sig-paren">)</span> &#x2192; List[Tuple[str, int, int]]<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.split_definitions_inside_term" title="Permalink to this definition">¶</a></dt>
<dd><p>The whole phrase can be considered definition (“MSRB”, “we”, “us” or “our”),
but in fact the phrase can be a collection of definitions.
Here we split definition phrase to a list of definitions.</p>
<p>Source string could be pre-processed, that’s why we search for each
sub-phrase’s coordinates (PhrasePositionFinder)
:param term: a definition or, probably, a set of definitions (“MSRB”, “we”, “us” or “our”)
:param src_with_coords: a sentence (probably), containing the term + its coords
:param term_start: “term” start coordinate within the source sentence
:param term_end: “term” end coordinate within the source sentence
:return: [(definition, def_start, def_end), …]</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definition_parsing_methods.trim_defined_term">
<code class="sig-prename descclassname">lexnlp.extract.en.definition_parsing_methods.</code><code class="sig-name descname">trim_defined_term</code><span class="sig-paren">(</span><em class="sig-param">term: str</em>, <em class="sig-param">start: int</em>, <em class="sig-param">end: int</em><span class="sig-paren">)</span> &#x2192; Tuple[str, int, int, bool]<a class="headerlink" href="#lexnlp.extract.en.definition_parsing_methods.trim_defined_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove pair of quotes / brackets framing text
Replace N-grams of spaces with single spaces
Replace line breaks with spaces
:param term: a phrase that may contain excess framing symbols
:param start: original term’s start position, may be changed
:param end: original term’s end position, may be changed
:return: updated term, start, end and the flag indicating that the whole phrase was inside quotes</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.definitions">
<span id="lexnlp-extract-en-definitions-module"></span><h2>lexnlp.extract.en.definitions module<a class="headerlink" href="#module-lexnlp.extract.en.definitions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lexnlp.extract.en.definitions.get_definition_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.definitions.</code><code class="sig-name descname">get_definition_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">decode_unicode=True</em>, <em class="sig-param">locator_type: lexnlp.extract.common.annotation_locator_type.AnnotationLocatorType = &lt;AnnotationLocatorType.RegexpBased: 1&gt;</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.definition_annotation.DefinitionAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.definitions.get_definition_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definitions.get_definition_objects_list">
<code class="sig-prename descclassname">lexnlp.extract.en.definitions.</code><code class="sig-name descname">get_definition_objects_list</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">decode_unicode=True</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.en.definition_parsing_methods.DefinitionCaught]<a class="headerlink" href="#lexnlp.extract.en.definitions.get_definition_objects_list" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – text to search for definitions</p></li>
<li><p><strong>decode_unicode</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of found definitions - objects of class DefinitionCaught</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definitions.get_definitions">
<code class="sig-prename descclassname">lexnlp.extract.en.definitions.</code><code class="sig-name descname">get_definitions</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">decode_unicode=True</em>, <em class="sig-param">return_coords=False</em>, <em class="sig-param">locator_type: lexnlp.extract.common.annotation_locator_type.AnnotationLocatorType = &lt;AnnotationLocatorType.RegexpBased: 1&gt;</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.definitions.get_definitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible definitions in natural language in text.
The text will be split to sentences first.
:param return_coords: returns a (x, y) tuple in each record. x - definition’s text start, y - definition’s text end
:param decode_unicode:
:param return_sources: returns a tuple with the extracted term and the source sentence
:param text: the input text
:param locator_type: use default (Regexp-based) or ML-based locator
:return: Generator[name] or Generator[name, text] or Generator[name, text, coords]</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definitions.get_definitions_explicit">
<code class="sig-prename descclassname">lexnlp.extract.en.definitions.</code><code class="sig-name descname">get_definitions_explicit</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">decode_unicode=True</em>, <em class="sig-param">locator_type: lexnlp.extract.common.annotation_locator_type.AnnotationLocatorType = &lt;AnnotationLocatorType.RegexpBased: 1&gt;</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.definitions.get_definitions_explicit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.definitions.get_definitions_in_sentence">
<code class="sig-prename descclassname">lexnlp.extract.en.definitions.</code><code class="sig-name descname">get_definitions_in_sentence</code><span class="sig-paren">(</span><em class="sig-param">sentence: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">decode_unicode=True</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.definitions.get_definitions_in_sentence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.dict_entities">
<span id="lexnlp-extract-en-dict-entities-module"></span><h2>lexnlp.extract.en.dict_entities module<a class="headerlink" href="#module-lexnlp.extract.en.dict_entities" title="Permalink to this headline">¶</a></h2>
<p>Universal extraction of entities for which we have full dictionaries of possible names and aliases from English text.</p>
<p>Example: Courts - we have the full dictionary of known courts with their names and aliases and are able to
search the text for each possible court.</p>
<blockquote>
<div><p>Geo entities - we have the full set of known geo entities and can search any text for their occurrences.</p>
</div></blockquote>
<p>Search methods of this module require lists of possible entities with their ids, names and sets of aliases
in different languages.
To allow using these methods in Celery and especially for allowing building these configuration lists once and using
them in multiple Celery tasks it is required to allow their easy and fast serialization.
By default Celery uses JSON serialization starting from v. 4 and does not allow serializing objects of custom
classes out of the box. So we will have to use either dicts or tuples to avoid requiring special configuration for
Celery. Tuples are faster.</p>
<p>To avoid typos in development and utilize typization hints in IDE there are few methods in this module for operating
tuples which represent entities and aliases. They accept named parameters lists and return tuples.</p>
<dl class="class">
<dt id="lexnlp.extract.en.dict_entities.DictionaryEntity">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">DictionaryEntity</code><span class="sig-paren">(</span><em class="sig-param">entity: Any, coords: Tuple[int, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.DictionaryEntity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">SearchResultPosition</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]], alias: Tuple[str, str, bool, int], start: int, end: int</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a position in the normalized source text at which one or more entities have been detected.
One or more entities having equal aliases can be detected on a position in the text.</p>
<dl class="method">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.add_entity">
<code class="sig-name descname">add_entity</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]], alias: Tuple[str, str, bool, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.add_entity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.alias_text">
<code class="sig-name descname">alias_text</code><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.alias_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.end">
<code class="sig-name descname">end</code><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.entities_dict">
<code class="sig-name descname">entities_dict</code><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.entities_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.get_entities_aliases">
<code class="sig-name descname">get_entities_aliases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.get_entities_aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.overlaps">
<code class="sig-name descname">overlaps</code><span class="sig-paren">(</span><em class="sig-param">other: lexnlp.extract.en.dict_entities.SearchResultPosition</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.dict_entities.SearchResultPosition.start">
<code class="sig-name descname">start</code><a class="headerlink" href="#lexnlp.extract.en.dict_entities.SearchResultPosition.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.add_alias_to_entity">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">add_alias_to_entity</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]], alias: str, language: str = None, is_abbreviation: bool = False, alias_id: int = None</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.add_alias_to_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add alias to entity. Entities are in the form of tuples:
(entity_id, name, [(alias_text, lang, is_abbrev, alias_id), …]).
This method is just for more comfortable development - to ensure type safety and avoid accessing properties of
entities by their indexes.
:param entity:
:param alias:
:param language:
:param is_abbreviation:
:param alias_id: Alias id or None if identifying is not supported.
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.add_aliases_to_entity">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">add_aliases_to_entity</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple[str, str, bool]]], aliases_csv: str, language: str = None, is_abbreviation: bool = None, alias_id: int = None, csv_separator: str = ';'</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.dict_entities.add_aliases_to_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Add alias to entity. Entities are in the form of tuples:
(entity_id, name, [(alias_text, lang, is_abbrev, alias_id), …]).
This method can be used if there is a comma separated list of aliases stored somewhere and they all have the same
language and is_abbreviation value.
This method is just for more comfortable development - to ensure type safety and avoid accessing properties of
entities by their indexes.
:param entity:
:param aliases_csv:
:param language:
:param is_abbreviation:
:param alias_id:
:param csv_separator:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.alias_is_blacklisted">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">alias_is_blacklisted</code><span class="sig-paren">(</span><em class="sig-param">alias_black_list: Union[None, Dict[str, Tuple[List[str], List[str]]]], norm_alias: str, alias_lang: str, is_abbrev: bool</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#lexnlp.extract.en.dict_entities.alias_is_blacklisted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.conflicts_take_first_by_id">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">conflicts_take_first_by_id</code><span class="sig-paren">(</span><em class="sig-param">conflicting_entities_aliases: List[Tuple[Tuple[int, str, int, List[Tuple]], Tuple]]</em><span class="sig-paren">)</span> &#x2192; List[Tuple[Tuple[int, str, int, List[Tuple]], Tuple[str, str, bool, int]]]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.conflicts_take_first_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Default conflict resolving function for dropping all entities detected at the same position excepting the one
having the smallest id. To be used in find_dict_entities() method.
:param conflicting_entities_aliases: list of (entity, alias) pairs
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.conflicts_top_by_priority">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">conflicts_top_by_priority</code><span class="sig-paren">(</span><em class="sig-param">conflicting_entities_aliases: List[Tuple[Tuple[int, str, int, List[Tuple]], Tuple]]</em><span class="sig-paren">)</span> &#x2192; List[Tuple[Tuple[int, str, int, List[Tuple]], Tuple[str, str, bool, int]]]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.conflicts_top_by_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Default conflict resolving function for dropping all entities detected at the same position excepting the one
having the smallest id. To be used in find_dict_entities() method.
:param conflicting_entities_aliases: list of (entity, alias) pairs
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.entity_alias">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">entity_alias</code><span class="sig-paren">(</span><em class="sig-param">alias: str</em>, <em class="sig-param">language: str = None</em>, <em class="sig-param">is_abbreviation: bool = False</em>, <em class="sig-param">alias_id: int = None</em><span class="sig-paren">)</span> &#x2192; Tuple[str, str, bool, int, str]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.entity_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Create entity alias tuple. This method is just for ensuring type safety of alias components in IDE.
:param alias_id: Alias id. None if there is no id.
:param alias: Alias text - ‘Mississippi’, ‘MS’, ‘CAN’, …
:param language: Language - en, de, fr, …
:param is_abbreviation: Is this alias representing an abbreviation or not. Abbreviations have different rules
of searching.
:return: A tuple representing the alias in format: (alias_text, lang, is_abbreviation, alias_id)</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.entity_config">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">entity_config</code><span class="sig-paren">(</span><em class="sig-param">entity_id: int</em>, <em class="sig-param">name: str</em>, <em class="sig-param">priority: int = 0</em>, <em class="sig-param">aliases: List[Union[str</em>, <em class="sig-param">Tuple]] = ()</em>, <em class="sig-param">name_is_alias: bool = True</em><span class="sig-paren">)</span> &#x2192; Tuple[int, str, int, List[Tuple]]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.entity_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Create entity configuration for a possible entity with its id, name and aliases to search.
:param entity_id: Unique identifier of the entity.
:param name: Human-readable name to displaying in UI. Searches are made not for name but for the possible aliases -
each one having its assigned language. And name may or may not be added to the list of search aliases.
:param priority: Optional int priority value for the entity. Can be used for sorting. Entities with higher prio
should be selected first.
:param aliases: List of aliases to search for. Each alias can be either string or
(alias, language, is_abbreviation, alias_id)
tuple. For string - a tuple with default values is created. entity_alias() function can be used to create the alias
tuple ensuring its components type safety in IDE.
:param name_is_alias: If True - then add entity name to the list of aliases with undefined language.
:return: A tuple representing the entity in format (entity_id, name, [(alias, lang, is_abbrev, alias_id), …])</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.find_dict_entities">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">find_dict_entities</code><span class="sig-paren">(</span><em class="sig-param">text: str, all_possible_entities: List[Tuple[int, str, int, List[Tuple]]], text_languages: Union[List[str], Tuple[str], Set[str]] = None, conflict_resolving_func: Callable[List[Tuple[int, str, List[Tuple]]], Tuple[List[Tuple[int, str, List[Tuple]]], Tuple]] = None, use_stemmer: bool = False, remove_time_am_pm: bool = True, min_alias_len: int = None, prepared_alias_black_list: Union[None, Dict[str, Tuple[List[str], List[str]]]] = None</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.en.dict_entities.DictionaryEntity, None], None]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.find_dict_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all entities defined in the ‘all_possible_entities’ list appeared in the source text.
This method takes care of leaving only the longest matching search result for the case of multiple
entities having aliases - one being a substring of another.
This method takes care of the language of the text and aliases - if language is specified both for the text
and for the alias - then this alias is used only if they are the same.
This method may detect multiple possibly matching entities at a position in the text - because there can be
entites having the same aliases in the same language. To resolve such conflicts a special resolving function can be
specified.
This method takes care of time AM/PM components which possibly can appear in the aliases of some entities -
it tries to detect minutes/seconds/milliseconds before AM/PM and ignore them in such cases.</p>
<p>Algorithm of this method:
1. Normalize the source text (we need lowercase and non-lowercase versions for abbrev searches).
2. Create a shared search context - a map of position -&gt; (alias text + list of matching entities)
3. For each possible entity do search using the shared context:</p>
<blockquote>
<div><dl class="simple">
<dt>3.1. For each alias of the entity:</dt><dd><dl class="simple">
<dt>3.1.1. Iteratively search for all occurrences of the alias taking into account its language, abbrev status.</dt><dd><p>For each found occurrence of the alias - check if there is already found another alias and entity
at this position and leave only the one having the longest alias (“Something” vs “Something Bigger”)
If there is already a found different entity on this position having totally equal alias with
the same language - then store them both for this position in the text.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>4. Now we have a map filled with: position -&gt; (alias text + list of entities having this alias).
After sorting the items of this dict by position we will be able to get rid of overlaping of longer and shorter
aliases being one a substirng of another (“Bankr. E.D.N.Y.” vs “E.D.N.Y.”).
5. For each next position check if it overlaps with the next one [position; position + len(alias)].
If overlaps - then leave the longest alias and drop the shorter.</p>
<p>Main complexity of this algorithm is caused by the requirement to detect the longest match for each piece of text
while the longer match can start at the earlier position then the shorter match and there can be multiple aliases
of different entities matching the same piece of text.</p>
<p>Another algorithm for this function can be based on the idea that or-kind regexp returns the longest matching group.
We could form regexps containing the possible aliases and apply them to the source text:
r’alias1|alias2|longer alias2|…’</p>
<p>TODO Compare to other algorithms for time and memory complexity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> – </p></li>
<li><p><strong>all_possible_entities</strong> – list of dict or list of DictEntity - all possible entities to search for</p></li>
<li><p><strong>min_alias_len</strong> – Minimal length of alias/name to search for. Can be used to ignore too short aliases like “M.”</p></li>
</ul>
</dd>
</dl>
<p>while searching.
:param prepared_alias_black_list: List of aliases to remove from searching. Can be used to ignore concrete aliases.
Prepared black list of aliases to exclude from search.
Should be: dict of language -&gt; tuple (list of normalized non-abbreviations, list of normalized abbreviations)
:param text_languages: If set - then only aliases of these languages will be searched for.
:param conflict_resolving_func: A function for resolving conflicts when there are multiple entities detected
at the same position in the source text and their detected aliases are of the same length.
The function takes a list of conflicting entities and should return a list of one or more entities which
should be returned.
:param use_stemmer: Use stemmer instead of tokenizer. Stemmer converts words to their simple form (singular number,
e.t.c.). Stemmer works better for searching for “tables”, “developers”, … Tokenizer fits for “United States”,
“Mississippi”, …
:param remove_time_am_pm: Remove from final results AM/PM abbreviations which look like end part of time
strings - 11:45 am, 10:00 pm.
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_alias_id">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_alias_id</code><span class="sig-paren">(</span><em class="sig-param">alias: Tuple[str, str, bool, int]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_alias_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get alias text from alias tuple.
This method is just for more comfortable development - to avoid accessing properties of
aliases by their indexes.
:param alias:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_alias_text">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_alias_text</code><span class="sig-paren">(</span><em class="sig-param">alias: Tuple[str, str, bool, int]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_alias_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Get alias text from alias tuple.
This method is just for more comfortable development - to avoid accessing properties of
aliases by their indexes.
:param alias:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_entity_aliases">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_entity_aliases</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]]</em><span class="sig-paren">)</span> &#x2192; List[Tuple]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_entity_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>Get aliases of the entity.
This method is just for more comfortable development - to avoid accessing properties of
entities by their indexes.
:param entity:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_entity_id">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_entity_id</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_entity_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get id of the entity.
This method is just for more comfortable development - to avoid accessing properties of
entities by their indexes.
:param entity:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_entity_name">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_entity_name</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_entity_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get name of the entity.
This method is just for more comfortable development - to avoid accessing properties of
entities by their indexes.
:param entity:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.get_entity_priority">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">get_entity_priority</code><span class="sig-paren">(</span><em class="sig-param">entity: Tuple[int, str, int, List[Tuple]]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#lexnlp.extract.en.dict_entities.get_entity_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Get priority of the entity.
This method is just for more comfortable development - to avoid accessing properties of
entities by their indexes.
:param entity:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.normalize_text">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">normalize_text</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">spaces_on_start_end: bool = True</em>, <em class="sig-param">spaces_after_dots: bool = True</em>, <em class="sig-param">lowercase: bool = True</em>, <em class="sig-param">use_stemmer: bool = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#lexnlp.extract.en.dict_entities.normalize_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes text for substring search operations - extracts tokens, joins them back with spaces,
adds missing spaces after dots for abbreviations, e.t.c.
Overall aim of this method is to weaken substring matching conditions by normalizing both the text
and the substring being searched by the same way removing obsolete differences between them
(case, punctuation, …).
:param text:
:param spaces_on_start_end:
:param spaces_after_dots:
:param lowercase:
:param use_stemmer: Use stemmer instead of tokenizer. When using stemmer all words will be converted to singular
number (or to some the most plain form) before matching. When using tokenizer - the words are compared as is.
Using tokenizer should be enough for searches for entities which exist in a single number in the real world -
geo entities, courts, …. Stemmer is required for searching for some common objects - table, pen, developer, …
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.dict_entities.prepare_alias_blacklist_dict">
<code class="sig-prename descclassname">lexnlp.extract.en.dict_entities.</code><code class="sig-name descname">prepare_alias_blacklist_dict</code><span class="sig-paren">(</span><em class="sig-param">alias_blacklist: List[Tuple[str, str, bool]], use_stemmer: bool = False</em><span class="sig-paren">)</span> &#x2192; Union[None, Dict[str, Tuple[List[str], List[str]]]]<a class="headerlink" href="#lexnlp.extract.en.dict_entities.prepare_alias_blacklist_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare alias black list for providing it to find_dict_entities() function.
:param alias_blacklist: Non-normalized form of the blacklist: [(alias, lang, is_abbreb), …]
:param use_stemmer: Use stemmer for alias normalization. Otherwise - tokenizer only.
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.distances">
<span id="lexnlp-extract-en-distances-module"></span><h2>lexnlp.extract.en.distances module<a class="headerlink" href="#module-lexnlp.extract.en.distances" title="Permalink to this headline">¶</a></h2>
<p>Distance extraction for English.</p>
<p>This module implements basic distance extraction functionality in English.</p>
<dl class="function">
<dt id="lexnlp.extract.en.distances.get_distance_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.distances.</code><code class="sig-name descname">get_distance_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.distance_annotation.DistanceAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.distances.get_distance_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.distances.get_distances">
<code class="sig-prename descclassname">lexnlp.extract.en.distances.</code><code class="sig-name descname">get_distances</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.distances.get_distances" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.durations">
<span id="lexnlp-extract-en-durations-module"></span><h2>lexnlp.extract.en.durations module<a class="headerlink" href="#module-lexnlp.extract.en.durations" title="Permalink to this headline">¶</a></h2>
<p>This module implements duration extraction functionality in English.</p>
<dl class="class">
<dt id="lexnlp.extract.en.durations.EnDurationParser">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.durations.</code><code class="sig-name descname">EnDurationParser</code><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lexnlp.extract.common.durations.html#lexnlp.extract.common.durations.durations_parser.DurationParser" title="lexnlp.extract.common.durations.durations_parser.DurationParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">lexnlp.extract.common.durations.durations_parser.DurationParser</span></code></a></p>
<dl class="attribute">
<dt id="lexnlp.extract.en.durations.EnDurationParser.DURATION_MAP">
<code class="sig-name descname">DURATION_MAP</code><em class="property"> = {'anniversaries': 365, 'anniversary': 365, 'annum': 365, 'day': 1, 'hour': 0.041666666666666664, 'minute': 0.0006944444444444445, 'month': 30, 'quarter': 91.25, 'second': 1.1574074074074073e-05, 'week': 7, 'year': 365}</em><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.DURATION_MAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.durations.EnDurationParser.DURATION_PTN">
<code class="sig-name descname">DURATION_PTN</code><em class="property"> = '\n    ((\n(?:(?:(?:(?:(?:[\\.\\d][\\d\\.,]*\\s*|\\W|^)\n(?:(?:seventeenths|seventeenth|thirteenths|fourteenths|eighteenths|nineteenths|seventieths|thirteenth|fourteenth|eighteenth|nineteenth|seventieth|fifteenths|sixteenths|twentieths|thirtieths|eightieths|ninetieths|seventeen|fifteenth|sixteenth|twentieth|thirtieth|eightieth|ninetieth|elevenths|fortieths|fiftieths|sixtieths|thirteen|fourteen|eighteen|nineteen|eleventh|fortieth|fiftieth|sixtieth|sevenths|twelfths|fifteen|sixteen|seventy|seventh|twelfth|fourths|eighths|eleven|twelve|twenty|thirty|eighty|ninety|zeroth|second|fourth|eighth|thirds|fifths|sixths|ninths|tenths|three|seven|eight|forty|fifty|sixty|first|third|fifth|sixth|ninth|tenth|zero|four|five|nine|one|two|six|ten|thousandths|thousandth|thousand|trillion|million|billion|trill|bil|mm|k|m|b\n|hundred(?:th(?:s)?)?|dozen|and|a\\s+half|quarters?)[\\s-]*)+)\n(?:(?:no|\\d{1,2})/100)?)|(?&lt;=\\W|^)(?:[\\.\\d][\\d\\.,/]*))(?:\\W|$))(?:\\s{0,2}[½⅓⅔¼¾⅕⅖⅗⅘⅙⅚⅐⅛⅜⅝⅞⅑⅒]+)*)\n    (?:\\s*(?:calendar|business|actual))?[\\s-]*\n    (second|minute|hour|day|week|month|quarter|year|annum|anniversary|anniversaries)s?)(?:\\W|$)\n    '</em><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.DURATION_PTN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.durations.EnDurationParser.DURATION_PTN_RE">
<code class="sig-name descname">DURATION_PTN_RE</code><em class="property"> = regex.Regex('\n    ((\n(?:(?:(?:(?:(?:[\\.\\d][\\d\\.,]*\\s*|\\W|^)\n(?:(?:seventeenths|seventeenth|thirteenths|fourteenths|eighteenths|nineteenths|seventieths|thirteenth|fourteenth|eighteenth|nineteenth|seventieth|fifteenths|sixteenths|twentieths|thirtieths|eightieths|ninetieths|seventeen|fifteenth|sixteenth|twentieth|thirtieth|eightieth|ninetieth|elevenths|fortieths|fiftieths|sixtieths|thirteen|fourteen|eighteen|nineteen|eleventh|fortieth|fiftieth|sixtieth|sevenths|twelfths|fifteen|sixteen|seventy|seventh|twelfth|fourths|eighths|eleven|twelve|twenty|thirty|eighty|ninety|zeroth|second|fourth|eighth|thirds|fifths|sixths|ninths|tenths|three|seven|eight|forty|fifty|sixty|first|third|fifth|sixth|ninth|tenth|zero|four|five|nine|one|two|six|ten|thousandths|thousandth|thousand|trillion|million|billion|trill|bil|mm|k|m|b\n|hundred(?:th(?:s)?)?|dozen|and|a\\s+half|quarters?)[\\s-]*)+)\n(?:(?:no|\\d{1,2})/100)?)|(?&lt;=\\W|^)(?:[\\.\\d][\\d\\.,/]*))(?:\\W|$))(?:\\s{0,2}[½⅓⅔¼¾⅕⅖⅗⅘⅙⅚⅐⅛⅜⅝⅞⅑⅒]+)*)\n    (?:\\s*(?:calendar|business|actual))?[\\s-]*\n    (second|minute|hour|day|week|month|quarter|year|annum|anniversary|anniversaries)s?)(?:\\W|$)\n    ', flags=regex.S | regex.I | regex.M | regex.X | regex.V0)</em><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.DURATION_PTN_RE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.durations.EnDurationParser.INNER_CONJUNCTIONS">
<code class="sig-name descname">INNER_CONJUNCTIONS</code><em class="property"> = ['and', 'plus']</em><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.INNER_CONJUNCTIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.durations.EnDurationParser.INNER_PUNCTUATION">
<code class="sig-name descname">INNER_PUNCTUATION</code><em class="property"> = regex.Regex('[\\s\\,]', flags=regex.V0)</em><a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.INNER_PUNCTUATION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.durations.EnDurationParser.get_all_annotations">
<em class="property">classmethod </em><code class="sig-name descname">get_all_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.common.annotations.duration_annotation.DurationAnnotation]<a class="headerlink" href="#lexnlp.extract.en.durations.EnDurationParser.get_all_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.durations.get_duration_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.durations.</code><code class="sig-name descname">get_duration_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.duration_annotation.DurationAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.durations.get_duration_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.durations.get_duration_annotations_list">
<code class="sig-prename descclassname">lexnlp.extract.en.durations.</code><code class="sig-name descname">get_duration_annotations_list</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; List[lexnlp.extract.common.annotations.duration_annotation.DurationAnnotation]<a class="headerlink" href="#lexnlp.extract.en.durations.get_duration_annotations_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.durations.get_durations">
<code class="sig-prename descclassname">lexnlp.extract.en.durations.</code><code class="sig-name descname">get_durations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.durations.get_durations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.en_language_tokens">
<span id="lexnlp-extract-en-en-language-tokens-module"></span><h2>lexnlp.extract.en.en_language_tokens module<a class="headerlink" href="#module-lexnlp.extract.en.en_language_tokens" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.en_language_tokens.</code><code class="sig-name descname">EnLanguageTokens</code><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens.abbreviations">
<code class="sig-name descname">abbreviations</code><em class="property"> = {'A.D.', 'A.V.', 'Abbrev.', 'Abd.', 'Aberd.', 'Aberdeensh.', 'Abol.', 'Aborig.', 'Abp.', 'Abr.', 'Abridg.', 'Abridgem.', 'Absol.', 'Abst.', 'Abstr.', 'Acad.', 'Acc.', 'Accept.', 'Accomm.', 'Accompl.', 'Accs.', 'Acct.', 'Accts.', 'Achievem.', 'Add.', 'Addit.', 'Addr.', 'Adm.', 'Admin.', 'Admir.', 'Admon.', 'Admonit.', 'Adv.', 'Advancem.', 'Advert.', 'Advoc.', 'Advt.', 'Advts.', 'Aerodynam.', 'Aeronaut.', 'Aff.', 'Affect.', 'Afr.', 'Agric.', 'Alch.', 'Alg.', 'Alleg.', 'Allit.', 'Alm.', 'Alph.', 'Amer.', 'Anal.', 'Analyt.', 'Anat.', 'Anc.', 'Anecd.', 'Ang.', 'Angl.', 'Anglo-Ind.', 'Anim.', 'Ann.', 'Anniv.', 'Annot.', 'Anon.', 'Answ.', 'Ant.', 'Anthrop.', 'Anthropol.', 'Antiq.', 'Apoc.', 'Apol.', 'App.', 'Appl.', 'Applic.', 'Apr.', 'Arab.', 'Arb.', 'Arch.', 'Archaeol.', 'Archipel.', 'Archit.', 'Argt.', 'Arith.', 'Arithm.', 'Arrangem.', 'Artic.', 'Artific.', 'Artill.', 'Ashm.', 'Assemb.', 'Assoc.', 'Assoc. Football', 'Assyriol.', 'Astr.', 'Astrol.', 'Astron.', 'Astronaut.', 'Att.', 'Attrib.', 'Aug.', 'Austral.', 'Auth.', 'Autobiog.', 'Autobiogr.', 'Ayrsh.', 'B.C.', 'BNC', 'Bacteriol.', 'Bedford.', 'Bedfordsh.', 'Bel &amp; Dr.', 'Belg.', 'Berks.', 'Berksh.', 'Berw.', 'Berwicksh.', 'Bibliogr.', 'Biochem.', 'Biog.', 'Biogr.', 'Biol.', 'Bk.', 'Bks.', 'Bord.', 'Bot.', 'Bp.', 'Braz.', 'Brit.', 'Bucks.', 'Build.', 'Bull.', 'Bur.', 'Cal.', 'Calc.', 'Calend.', 'Calif.', 'Calligr.', 'Camb.', 'Cambr.', 'Campanol.', 'Canad.', 'Canterb.', 'Capt.', 'Cartogr.', 'Catal.', 'Catech.', 'Cath.', 'Cent.', 'Ceram.', 'Cert.', 'Certif.', 'Ch.', 'Ch. Hist.', 'Chamb.', 'Char.', 'Charac.', 'Chas.', 'Chem.', 'Chem. Engin.', 'Chesh.', 'Chr.', 'Chron.', 'Chronol.', 'Chrons.', 'Cinematogr.', 'Circ.', 'Civ. Law', 'Civil Engin.', 'Cl.', 'Class.', 'Class. Antiq.', 'Classif.', 'Climatol.', 'Clin.', 'Col.', 'Coll.', 'Collect.', 'Colloq.', 'Coloss.', 'Com.', 'Comb.', 'Combs.', 'Comm.', 'Comm. Law', 'Commandm.', 'Commend.', 'Commerc.', 'Commiss.', 'Commonw.', 'Communic.', 'Comp.', 'Comp. Anat.', 'Compan.', 'Compar.', 'Compend.', 'Compl.', 'Compos.', 'Conc.', 'Conch.', 'Concl.', 'Conf.', 'Confid.', 'Confl.', 'Confut.', 'Congr.', 'Congreg.', 'Congress.', 'Conn.', 'Consc.', 'Consecr.', 'Consid.', 'Consol.', 'Constit.', 'Constit. Hist.', 'Constr.', 'Contemp.', 'Contempl.', 'Contend.', 'Content.', 'Contin.', 'Contradict.', 'Contrib.', 'Controv.', 'Conv.', 'Convent.', 'Conversat.', 'Convoc.', 'Cor.', 'Cornw.', 'Coron.', 'Corr.', 'Corresp.', 'Counc.', 'Courtsh.', 'Craniol.', 'Craniom.', 'Crim.', 'Crim. Law', 'Crit.', 'Crt.', 'Crts.', 'Cryptogr.', 'Crystallogr.', 'Ct.', 'Cumb.', 'Cumberld.', 'Cumbld.', 'Cycl.', 'Cytol.', 'D.C.', 'Dan.', 'Dau.', 'Deb.', 'Dec.', 'Declar.', 'Ded.', 'Def.', 'Deliv.', 'Demonstr.', 'Dep.', 'Depred.', 'Depredat.', 'Dept.', 'Derbysh.', 'Descr.', 'Deut.', 'Devel.', 'Devonsh.', 'Dial.', 'Dict.', 'Diffic.', 'Direct.', 'Dis.', 'Disc.', 'Discipl.', 'Discov.', 'Discrim.', 'Discuss.', 'Diss.', 'Dist.', 'Distemp.', 'Distill.', 'Distrib.', 'Div.', 'Divers.', 'Dk.', 'Doc.', 'Doctr.', 'Domest.', 'Durh.', 'E. Afr.', 'E. Angl.', 'E. Anglian', 'E. Ind.', 'E.D.D.', 'E.E.T.S.', 'East Ind.', 'Eccl.', 'Eccl. Hist.', 'Eccl. Law', 'Eccles.', 'Ecclus.', 'Ecol.', 'Econ.', 'Ed.', 'Edin.', 'Edinb.', 'Educ.', 'Edw.', 'Egypt.', 'Egyptol.', 'Electr.', 'Electr. Engin.', 'Electro-magn.', 'Electro-physiol.', 'Elem.', 'Eliz.', 'Elizab.', 'Emb.', 'Embryol.', 'Encycl.', 'Encycl. Brit.', 'Encycl. Metrop.', 'Eng.', 'Engin.', 'Englishw.', 'Enq.', 'Ent.', 'Enthus.', 'Entom.', 'Entomol.', 'Enzymol.', 'Ep.', 'Eph.', 'Ephes.', 'Epil.', 'Episc.', 'Epist.', 'Epit.', 'Equip.', 'Esd.', 'Ess.', 'Essent.', 'Establ.', 'Esth.', 'Ethnol.', 'Etymol.', 'Eval.', 'Evang.', 'Even.', 'Evid.', 'Evol.', 'Ex. doc.', 'Exalt.', 'Exam.', 'Exch.', 'Exec.', 'Exerc.', 'Exhib.', 'Exod.', 'Exped.', 'Exper.', 'Explan.', 'Explic.', 'Explor.', 'Expos.', 'Ezek.', 'Fab.', 'Fam.', 'Farew.', 'Feb.', 'Ff.', 'Fifesh.', 'Footpr.', 'Forfarsh.', 'Fortif.', 'Fortn.', 'Found.', 'Fr.', 'Fragm.', 'Fratern.', 'Friendsh.', 'Fund.', 'Furnit.', 'Gal.', 'Gard.', 'Gastron.', 'Gaz.', 'Gd.', 'Gen.', 'Geo.', 'Geog.', 'Geogr.', 'Geol.', 'Geom.', 'Geomorphol.', 'Ger.', 'Glac.', 'Glasg.', 'Glos.', 'Gloss.', 'Glouc.', 'Gloucestersh.', 'Gosp.', 'Gov.', 'Govt.', 'Gr.', 'Gram.', 'Gramm. Analysis', 'Gt.', 'Gynaecol.', 'Hab.', 'Haematol.', 'Hag.', 'Hampsh.', 'Handbk.', 'Hants.', 'Heb.', 'Hebr.', 'Hen.', 'Her.', 'Herb.', 'Heref.', 'Hereford.', 'Herefordsh.', 'Hertfordsh.', 'Hierogl.', 'Hist.', 'Histol.', 'Hom.', 'Horol.', 'Hort.', 'Hos.', 'Hosp.', 'Househ.', 'Housek.', 'Husb.', 'Hydraul.', 'Hydrol.', 'Ichth.', 'Icthyol.', 'Ideol.', 'Idol.', 'Illustr.', 'Imag.', 'Immunol.', 'Impr.', 'Inaug.', 'Inc.', 'Inclos.', 'Ind.', 'Industr.', 'Industr. Rel.', 'Infl.', 'Innoc.', 'Inorg.', 'Inq.', 'Inst.', 'Instr.', 'Intell.', 'Intellect.', 'Interc.', 'Interl.', 'Internat.', 'Interpr.', 'Intro.', 'Introd.', 'Inv.', 'Invent.', 'Invert. Zool.', 'Invertebr.', 'Investig.', 'Investm.', 'Invoc.', 'Ir.', 'Irel.', 'Isa.', 'Ital.', 'Jahrb.', 'Jam.', 'Jan.', 'Jap.', 'Jas.', 'Jer.', 'Josh.', 'Jrnl.', 'Jrnls.', 'Jud.', 'Judg.', 'Jul.', 'Jun.', 'Jurisd.', 'Jurisdict.', 'Jurispr.', 'Justif.', 'Justific.', 'Kent.', 'Kgs.', 'Kingd.', 'King’s Bench Div.', 'Knowl.', 'Kpr.', 'LXX', 'Lab.', 'Lam.', 'Lament', 'Lament.', 'Lanc.', 'Lancash.', 'Lancs.', 'Lang.', 'Langs.', 'Lat.', 'Ld.', 'Lds.', 'Lect.', 'Leechd.', 'Leg.', 'Leicest.', 'Leicester.', 'Leicestersh.', 'Leics.', 'Let.', 'Lett.', 'Lev.', 'Lex.', 'Libr.', 'Limnol.', 'Lincolnsh.', 'Lincs.', 'Ling.', 'Linn.', 'Lit.', 'Lithogr.', 'Lithol.', 'Liturg.', 'Lond.', 'MS.', 'MSS.', 'Macc.', 'Mach.', 'Mag.', 'Magn.', 'Mal.', 'Man.', 'Managem.', 'Manch.', 'Manip.', 'Manuf.', 'Mar.', 'Mass.', 'Math.', 'Matt.', 'Meas.', 'Measurem.', 'Mech.', 'Med.', 'Medit.', 'Mem.', 'Merc.', 'Merch.', 'Metall.', 'Metallif.', 'Metallogr.', 'Metamorph.', 'Metaph.', 'Meteorol.', 'Meth.', 'Metrop.', 'Mex.', 'Mic.', 'Mich.', 'Microbiol.', 'Microsc.', 'Mil.', 'Milit.', 'Min.', 'Mineral.', 'Misc.', 'Miscell.', 'Mod.', 'Monum.', 'Morphol.', 'Mt.', 'Mtg.', 'Mts.', 'Munic.', 'Munif.', 'Munim.', 'Mus.', 'Myst.', 'Myth.', 'Mythol.', 'N. Afr.', 'N. Amer.', 'N. Carolina', 'N. Dakota', 'N. Ir.', 'N. Irel.', 'N.E.', 'N.E.D.', 'N.S. Wales', 'N.S.W.', 'N.T.', 'N.W.', 'N.Y.', 'N.Z.', 'Nah.', 'Narr.', 'Narrat.', 'Nat.', 'Nat. Hist.', 'Nat. Philos.', 'Nat. Sci.', 'Naut.', 'Nav.', 'Navig.', 'Neh.', 'Neighb.', 'Nerv.', 'Neurol.', 'Neurosurg.', 'New Hampsh.', 'Newc.', 'Newspr.', 'No.', 'Non-conf.', 'Nonconf.', 'Norf.', 'Northamptonsh.', 'Northants.', 'Northumb.', 'Northumbld.', 'Northumbr.', 'Norw.', 'Norweg.', 'Notts.', 'Nov.', 'Nucl.', 'Num.', 'Numism.', 'O.E.D.', 'O.T.', 'OE', 'Obad.', 'Obed.', 'Obj.', 'Obs.', 'Observ.', 'Obstet.', 'Obstetr.', 'Obstetr. Med.', 'Occas.', 'Occup.', 'Occurr.', 'Oceanogr.', 'Oct.', 'Off.', 'Offic.', 'Okla.', 'Ont.', 'Ophthalm.', 'Ophthalmol.', 'Oppress.', 'Opt.', 'Orac.', 'Ord.', 'Org.', 'Org. Chem.', 'Organ. Chem.', 'Orig.', 'Orkn.', 'Ornith.', 'Ornithol.', 'Orthogr.', 'Outl.', 'Oxf.', 'Oxfordsh.', 'Oxon.', 'P. R.', 'Pa.', 'Palaeobot.', 'Palaeogr.', 'Palaeont.', 'Palaeontol.', 'Paraphr.', 'Parasitol.', 'Parl.', 'Parnass.', 'Path.', 'Pathol.', 'Peculat.', 'Penins.', 'Perf.', 'Periodontol.', 'Pers.', 'Persec.', 'Perthsh.', 'Pet.', 'Petrogr.', 'Petrol.', 'Pharm.', 'Pharmaceut.', 'Pharmacol.', 'Phil.', 'Philad.', 'Philem.', 'Philipp.', 'Philol.', 'Philos.', 'Phoen.', 'Phonol.', 'Photog.', 'Photogr.', 'Phrenol.', 'Phys.', 'Physical Chem.', 'Physical Geogr.', 'Physiogr.', 'Physiol.', 'Pict.', 'Poet.', 'Pol.', 'Pol. Econ.', 'Polit.', 'Polytechn.', 'Pop.', 'Porc.', 'Port.', 'Posth.', 'Postm.', 'Pott.', 'Pract.', 'Predict.', 'Pref.', 'Preh.', 'Prehist.', 'Prerog.', 'Pres.', 'Presb.', 'Preserv.', 'Prim.', 'Princ.', 'Print.', 'Probab.', 'Probl.', 'Proc.', 'Prod.', 'Prol.', 'Pronunc.', 'Prop.', 'Pros.', 'Prov.', 'Provid.', 'Provinc.', 'Provis.', 'Ps.', 'Psych.', 'Psychoanal.', 'Psychoanalyt.', 'Psychol.', 'Psychopathol.', 'Pt.', 'Publ.', 'Purg.', 'Q. Eliz.', 'Qld.', 'Quantum Mech.', 'Queen’s Bench Div.', 'R.A.F.', 'R.C.', 'R.C. Church', 'R.N.', 'Radiol.', 'Reas.', 'Reb.', 'Rebell.', 'Rec.', 'Reclam.', 'Recoll.', 'Redempt.', 'Ref.', 'Refl.', 'Refus.', 'Refut.', 'Reg.', 'Regic.', 'Regist.', 'Regr.', 'Rel.', 'Relig.', 'Reminisc.', 'Remonstr.', 'Renfrewsh.', 'Rep.', 'Reprod.', 'Rept.', 'Repub.', 'Res.', 'Resid.', 'Ret.', 'Retrosp.', 'Rev.', 'Revol.', 'Rhet.', 'Rhode Isl.', 'Rich.', 'Rom.', 'Rom. Antiq.', 'Ross-sh.', 'Roxb.', 'Roy.', 'Rudim.', 'Russ.', 'S. Afr.', 'S. Carolina', 'S. Dakota', 'S.E.', 'S.T.S.', 'S.W.', 'SS.', 'Sam.', 'Sask.', 'Sat.', 'Sax.', 'Sc.', 'Scand.', 'Sch.', 'Sci.', 'Scot.', 'Scotl.', 'Script.', 'Sculpt.', 'Seismol.', 'Sel.', 'Sel. comm.', 'Select.', 'Sept.', 'Ser.', 'Serm.', 'Sess.', 'Settlem.', 'Sev.', 'Shakes.', 'Shaks.', 'Sheph.', 'Shetl.', 'Shropsh.', 'Soc.', 'Sociol.', 'Som.', 'Song Sol.', 'Song of Sol.', 'Sonn.', 'Span.', 'Spec.', 'Specif.', 'Specim.', 'Spectrosc.', 'St.', 'Staff.', 'Stafford.', 'Staffordsh.', 'Staffs.', 'Stand.', 'Stat.', 'Statist.', 'Stock Exch.', 'Stratigr.', 'Struct.', 'Stud.', 'Subj.', 'Subscr.', 'Subscript.', 'Suff.', 'Suppl.', 'Supplic.', 'Suppress.', 'Surg.', 'Surv.', 'Sus.', 'Symmetr.', 'Symp.', 'Syst.', 'Taxon.', 'Techn.', 'Technol.', 'Tel.', 'Telecomm.', 'Telegr.', 'Teleph.', 'Teratol.', 'Terminol.', 'Terrestr.', 'Test.', 'Textbk.', 'Theat.', 'Theatr.', 'Theol.', 'Theoret.', 'Thermonucl.', 'Thes.', 'Thess.', 'Tim.', 'Tit.', 'Topogr.', 'Trad.', 'Trag.', 'Trans.', 'Transl.', 'Transubstant.', 'Trav.', 'Treas.', 'Treat.', 'Treatm.', 'Trib.', 'Trig.', 'Trigonom.', 'Trop.', 'Troub.', 'Troubl.', 'Typog.', 'Typogr.', 'U.K.', 'U.S.', 'U.S.A.F.', 'U.S.S.R.', 'Univ.', 'Unnat.', 'Unoffic.', 'Urin.', 'Utilit.', 'Va.', 'Vac.', 'Valedict.', 'Veg.', 'Veg. Phys.', 'Veg. Physiol.', 'Venet.', 'Vertebr.', 'Vet.', 'Vet. Med.', 'Vet. Path.', 'Vet. Sci.', 'Vet. Surg.', 'Vic.', 'Vict.', 'Vind.', 'Vindic.', 'Virg.', 'Virol.', 'Voc.', 'Vocab.', 'Vol.', 'Vols.', 'Voy.', 'Vulg.', 'W. Afr.', 'W. Ind.', 'W. Indies', 'W. Va.', 'Warwicksh.', 'Wd.', 'Westm.', 'Westmld.', 'Westmorld.', 'Westmrld.', 'Will.', 'Wilts.', 'Wiltsh.', 'Wis.', 'Wisd.', 'Wk.', 'Wkly.', 'Wks.', 'Wonderf.', 'Worc.', 'Worcestersh.', 'Worcs.', 'Writ.', 'Yearbk.', 'Yng.', 'Yorks.', 'Yorksh.', 'Yr.', 'Yrs.', 'Zech.', 'Zeitschr.', 'Zeph.', 'Zoogeogr.', 'Zool.', 'abbrev.', 'abl.', 'abs.', 'absol.', 'abstr.', 'acc.', 'accus.', 'act.', 'ad.', 'adj.', 'adj. phr.', 'adjs.', 'adv.', 'advb.', 'advs.', 'agst.', 'alt.', 'aphet.', 'app.', 'appos.', 'arch.', 'art.', 'attrib.', 'bef.', 'betw.', 'cent.', 'cf.', 'cl.', 'cogn. w.', 'collect.', 'colloq.', 'comb. form', 'comp.', 'compar.', 'compl.', 'conc.', 'concr.', 'conj.', 'cons.', 'const.', 'contempt.', 'contr.', 'corresp.', 'cpd.', 'dat.', 'def.', 'dem.', 'deriv.', 'derog.', 'dial.', 'dim.', 'dyslog.', 'e. midl.', 'eOE', 'east.', 'ed.', 'ellipt.', 'emph.', 'erron.', 'esp.', 'etym.', 'etymol.', 'euphem.', 'exc.', 'fam.', 'famil.', 'fem.', 'fig.', 'fl.', 'freq.', 'fut.', 'gen.', 'gerund.', 'hist.', 'imit.', 'imp.', 'imperf.', 'impers.', 'impf.', 'improp.', 'inc.', 'ind.', 'indef.', 'indic.', 'indir.', 'infin.', 'infl.', 'instr.', 'int.', 'interj.', 'interrog.', 'intr.', 'intrans.', 'iron.', 'irreg.', 'joc.', 'lOE', 'lit.', 'll.', 'masc.', 'med.', 'metaphor.', 'metr. gr.', 'midl.', 'mispr.', 'mod.', 'n.e.', 'n.w.', 'no.', 'nom.', 'nonce-wd.', 'north.', 'nr.', 'ns.', 'obj.', 'obl.', 'obs.', 'occas.', 'opp.', 'orig.', 'p.', 'pa.', 'pa. pple.', 'pa. t.', 'pass.', 'perf.', 'perh.', 'pers.', 'personif.', 'pf.', 'phonet.', 'phr.', 'pl.', 'plur.', 'poet.', 'pop.', 'poss.', 'ppl.', 'ppl. a.', 'ppl. adj.', 'ppl. adjs.', 'pple.', 'pples.', 'pr.', 'pr. pple.', 'prec.', 'pred.', 'predic.', 'pref.', 'prep.', 'pres.', 'pres. pple.', 'priv.', 'prob.', 'pron.', 'pronunc.', 'prop.', 'propr.', 'prov.', 'pseudo-Sc.', 'pseudo-arch.', 'pseudo-dial.', 'q.v.', 'quot.', 'quots.', 'redupl.', 'refash.', 'refl.', 'reg.', 'rel.', 'repr.', 'rhet.', 's.e.', 's.v.', 's.w.', 'sc.', 'sing.', 'south.', 'sp.', 'spec.', 'str.', 'subj.', 'subjunct.', 'subord.', 'subord. cl.', 'subseq.', 'subst.', 'suff.', 'superl.', 'syll.', 'techn.', 'tr.', 'trans.', 'transf.', 'transl.', 'ult.', 'unkn.', 'unstr.', 'usu.', 'v.r.', 'v.rr.', 'var.', 'varr.', 'vars.', 'vb.', 'vbl.', 'vbl. ns.', 'vbl.n.', 'vbs.', 'viz.', 'vulg.', 'wd.', 'west.', 'wk.'}</em><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens.abbreviations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens.articles">
<code class="sig-name descname">articles</code><em class="property"> = ['a', 'the', 'an']</em><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens.articles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens.conjunctions">
<code class="sig-name descname">conjunctions</code><em class="property"> = ['for', 'and', 'nor', 'but', 'or', 'yet', 'so']</em><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens.conjunctions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens.init">
<em class="property">static </em><code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens.init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.en_language_tokens.EnLanguageTokens.pronouns">
<code class="sig-name descname">pronouns</code><em class="property"> = {'I', 'all', 'another', 'any', 'anybody', 'anyone', 'anything', 'both', 'each', 'each other', 'either', 'enough', 'everybody', 'everyone', 'everything', 'few', 'he', 'her', 'hers', 'herself', 'him', 'himself', 'his', 'i', 'it', 'itself', 'little', 'many', 'me', 'mine', 'more', 'most', 'much', 'myself', 'neither', 'no one', 'nobody', 'none', 'nothing', 'one', 'one another', 'other', 'others', 'ours', 'ourselves', 'several', 'she', 'some', 'somebody', 'someone', 'something', 'such', 'that', 'theirs', 'them', 'themselves', 'these', 'they', 'this', 'those', 'us', 'we', 'what', 'whatever', 'which', 'whichever', 'who', 'whoever', 'whom', 'whomever', 'whose', 'you', 'yours', 'yourself'}</em><a class="headerlink" href="#lexnlp.extract.en.en_language_tokens.EnLanguageTokens.pronouns" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.geoentities">
<span id="lexnlp-extract-en-geoentities-module"></span><h2>lexnlp.extract.en.geoentities module<a class="headerlink" href="#module-lexnlp.extract.en.geoentities" title="Permalink to this headline">¶</a></h2>
<p>Geo Entity extraction for English.</p>
<p>This module implements extraction functionality for geo entities in English, including formal names, abbreviations,
and aliases.</p>
<dl class="function">
<dt id="lexnlp.extract.en.geoentities.get_geoentities">
<code class="sig-prename descclassname">lexnlp.extract.en.geoentities.</code><code class="sig-name descname">get_geoentities</code><span class="sig-paren">(</span><em class="sig-param">text: str, geo_config_list: List[Tuple[int, str, List[Tuple[str, str, bool, int]]]], priority: bool = False, priority_by_id: bool = False, text_languages: List[str] = None, min_alias_len: int = 2, prepared_alias_black_list: Union[None, Dict[str, Tuple[List[str], List[str]]]] = None</em><span class="sig-paren">)</span> &#x2192; Generator[[Tuple[Tuple, Tuple], Any], Any]<a class="headerlink" href="#lexnlp.extract.en.geoentities.get_geoentities" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for geo entities from the provided config list and yields pairs of (entity, alias).
Entity is: (entity_id, name, [list of aliases])
Alias is: (alias_text, lang, is_abbrev, alias_id)</p>
<p>This method uses general searching routines for dictionary entities from dict_entities.py module.
Methods of dict_entities module can be used for comfortable creating the config: entity_config(),
entity_alias(), add_aliases_to_entity().
:param text:
:param geo_config_list: List of all possible known geo entities in the form of tuples
(id, name, [(alias, lang, is_abbrev, alias_id), …]).
:param priority: If two entities found with the totally equal matching aliases -
then use the one with the greatest priority field.
:param priority_by_id: If two entities found with the totally equal matching aliases -
then use the one with the lowest id.
:param text_languages: Language(s) of the source text. If a language is specified then only aliases of this
language will be searched for. For example: this allows ignoring “Island” - a German language</p>
<blockquote>
<div><p>alias of Iceland for English texts.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_alias_len</strong> – Minimal length of geo entity aliases to search for.</p></li>
<li><p><strong>prepared_alias_black_list</strong> – List of aliases to exclude from searching in the form:
dict of lang -&gt; (list of normalized non-abbreviation aliases, list of normalized abbreviation aliases).
Use dict_entities.prepare_alias_blacklist_dict() for preparing this dict.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Generates tuples: (entity, alias)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.geoentities.get_geoentity_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.geoentities.</code><code class="sig-name descname">get_geoentity_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str, geo_config_list: List[Tuple[int, str, List[Tuple[str, str, bool, int]]]], priority: bool = False, priority_by_id: bool = False, text_languages: List[str] = None, min_alias_len: int = 2, prepared_alias_black_list: Union[None, Dict[str, Tuple[List[str], List[str]]]] = None</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.geo_annotation.GeoAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.geoentities.get_geoentity_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>See get_geoentities</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.geoentities.load_entities_dict_by_path">
<code class="sig-prename descclassname">lexnlp.extract.en.geoentities.</code><code class="sig-name descname">load_entities_dict_by_path</code><span class="sig-paren">(</span><em class="sig-param">entities_fn: str</em>, <em class="sig-param">aliases_fn: str</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.geoentities.load_entities_dict_by_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.introductory_words_detector">
<span id="lexnlp-extract-en-introductory-words-detector-module"></span><h2>lexnlp.extract.en.introductory_words_detector module<a class="headerlink" href="#module-lexnlp.extract.en.introductory_words_detector" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.introductory_words_detector.</code><code class="sig-name descname">IntroductoryWordsDetector</code><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRODUCTORY_POS">
<code class="sig-name descname">INTRODUCTORY_POS</code><em class="property"> = [[('RB', {'so', 'also'}), ('VBN', {'known', 'named', 'called'})], [('RB', {'so', 'also'}), ('JJ', {'known', 'named', 'called'})], [('VBN', {'known', 'named', 'called'})]]</em><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRODUCTORY_POS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRO_ADVERBS">
<code class="sig-name descname">INTRO_ADVERBS</code><em class="property"> = {'also', 'so'}</em><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRO_ADVERBS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRO_VERBS">
<code class="sig-name descname">INTRO_VERBS</code><em class="property"> = {'called', 'known', 'named'}</em><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.INTRO_VERBS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.MAX_INTRO_LEN">
<code class="sig-name descname">MAX_INTRO_LEN</code><em class="property"> = 2</em><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.MAX_INTRO_LEN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.PUNCTUATION_POS">
<code class="sig-name descname">PUNCTUATION_POS</code><em class="property"> = {'\t', '!', '&quot;', '$', '%', '&amp;', &quot;'&quot;, '(', ')', '*', ',', '-', '.', '/', ':', ';', '?', '&#64;', '\\', ']', '^', '``', '{', '}['}</em><a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.PUNCTUATION_POS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.remove_term_introduction">
<em class="property">static </em><code class="sig-name descname">remove_term_introduction</code><span class="sig-paren">(</span><em class="sig-param">term: str, term_pos: List[Tuple[str, str, int, int]]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#lexnlp.extract.en.introductory_words_detector.IntroductoryWordsDetector.remove_term_introduction" title="Permalink to this definition">¶</a></dt>
<dd><p>so called “champerty’ =&gt; “champerty’
:param term: source phrase
:param term_pos: sourse phrase</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.money">
<span id="lexnlp-extract-en-money-module"></span><h2>lexnlp.extract.en.money module<a class="headerlink" href="#module-lexnlp.extract.en.money" title="Permalink to this headline">¶</a></h2>
<p>Money extraction for English.</p>
<p>This module implements basic money extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.money.get_money">
<code class="sig-prename descclassname">lexnlp.extract.en.money.</code><code class="sig-name descname">get_money</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.money.get_money" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.money.get_money_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.money.</code><code class="sig-name descname">get_money_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.money_annotation.MoneyAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.money.get_money_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.percents">
<span id="lexnlp-extract-en-percents-module"></span><h2>lexnlp.extract.en.percents module<a class="headerlink" href="#module-lexnlp.extract.en.percents" title="Permalink to this headline">¶</a></h2>
<p>Percent extraction for English.</p>
<p>This module implements percent extraction functionality in English.</p>
<p>Todo:</p>
<dl class="function">
<dt id="lexnlp.extract.en.percents.get_percent_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.percents.</code><code class="sig-name descname">get_percent_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.percent_annotation.PercentAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.percents.get_percent_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get percent usages within text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.percents.get_percents">
<code class="sig-prename descclassname">lexnlp.extract.en.percents.</code><code class="sig-name descname">get_percents</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.percents.get_percents" title="Permalink to this definition">¶</a></dt>
<dd><p>Get percent usages within text.
:param text:
:param return_sources:
:param float_digits:
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.pii">
<span id="lexnlp-extract-en-pii-module"></span><h2>lexnlp.extract.en.pii module<a class="headerlink" href="#module-lexnlp.extract.en.pii" title="Permalink to this headline">¶</a></h2>
<p>PII extraction for English.</p>
<p>This module implements PII extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p><a class="reference external" href="http://www.doncio.navy.mil/contentview.aspx?id=2428">http://www.doncio.navy.mil/contentview.aspx?id=2428</a></p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.pii.get_pii">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_pii</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.pii.get_pii" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible PII references in the text.
:param text:
:param return_sources:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.pii.get_pii_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_pii_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.text_annotation.TextAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.pii.get_pii_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible PII references in the text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.pii.get_ssn_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_ssn_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.ssn_annotation.SsnAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.pii.get_ssn_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.pii.get_ssns">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_ssns</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">return_sources=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.pii.get_ssns" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible SSN references in the text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.pii.get_us_phone_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_us_phone_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.phone_annotation.PhoneAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.pii.get_us_phone_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible telephone numbers in the text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.pii.get_us_phones">
<code class="sig-prename descclassname">lexnlp.extract.en.pii.</code><code class="sig-name descname">get_us_phones</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.pii.get_us_phones" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible telephone numbers in the text.</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.ratios">
<span id="lexnlp-extract-en-ratios-module"></span><h2>lexnlp.extract.en.ratios module<a class="headerlink" href="#module-lexnlp.extract.en.ratios" title="Permalink to this headline">¶</a></h2>
<p>Ratio extraction for English.</p>
<p>This module implements ratio extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.ratios.get_ratio_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.ratios.</code><code class="sig-name descname">get_ratio_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.ratio_annotation.RatioAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.ratios.get_ratio_annotations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.ratios.get_ratios">
<code class="sig-prename descclassname">lexnlp.extract.en.ratios.</code><code class="sig-name descname">get_ratios</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">return_sources=False</em>, <em class="sig-param">float_digits=4</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.ratios.get_ratios" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.regulations">
<span id="lexnlp-extract-en-regulations-module"></span><h2>lexnlp.extract.en.regulations module<a class="headerlink" href="#module-lexnlp.extract.en.regulations" title="Permalink to this headline">¶</a></h2>
<p>Regulation extraction for English.</p>
<p>This module implements regulation extraction functionality in English.</p>
<dl class="simple">
<dt>Todo:</dt><dd><ul class="simple">
<li><p>Improved unit tests and case coverage</p></li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="lexnlp.extract.en.regulations.get_regulation_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.regulations.</code><code class="sig-name descname">get_regulation_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.regulation_annotation.RegulationAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.regulations.get_regulation_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get regulations.
:param text:
:param return_source:
:param as_dict:
:return: tuple or dict
(volume, reporter, reporter_full_name, page, page2, court, year[, source text])</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.regulations.get_regulations">
<code class="sig-prename descclassname">lexnlp.extract.en.regulations.</code><code class="sig-name descname">get_regulations</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">return_source=False</em>, <em class="sig-param">as_dict=False</em><span class="sig-paren">)</span> &#x2192; Generator<a class="headerlink" href="#lexnlp.extract.en.regulations.get_regulations" title="Permalink to this definition">¶</a></dt>
<dd><p>Get regulations.
:param text:
:param return_source:
:param as_dict:
:return: tuple or dict
(volume, reporter, reporter_full_name, page, page2, court, year[, source text])</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.trademarks">
<span id="lexnlp-extract-en-trademarks-module"></span><h2>lexnlp.extract.en.trademarks module<a class="headerlink" href="#module-lexnlp.extract.en.trademarks" title="Permalink to this headline">¶</a></h2>
<p>Trademark extraction for English using NLTK and NLTK pre-trained maximum entropy classifier.</p>
<p>This module implements basic Trademark extraction functionality in English relying on the pre-trained
NLTK functionality, including POS tagger and NE (fuzzy) chunkers.</p>
<p>Todo: -</p>
<dl class="function">
<dt id="lexnlp.extract.en.trademarks.get_trademark_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.trademarks.</code><code class="sig-name descname">get_trademark_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.trademark_annotation.TrademarkAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.trademarks.get_trademark_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find trademarks in text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.trademarks.get_trademarks">
<code class="sig-prename descclassname">lexnlp.extract.en.trademarks.</code><code class="sig-name descname">get_trademarks</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[str, None], None]<a class="headerlink" href="#lexnlp.extract.en.trademarks.get_trademarks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find trademarks in text.</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.urls">
<span id="lexnlp-extract-en-urls-module"></span><h2>lexnlp.extract.en.urls module<a class="headerlink" href="#module-lexnlp.extract.en.urls" title="Permalink to this headline">¶</a></h2>
<p>Urls extraction for English using NLTK and NLTK pre-trained maximum entropy classifier.</p>
<p>This module implements basic urls extraction functionality in English relying on the pre-trained
NLTK functionality, including POS tagger and NE (fuzzy) chunkers.</p>
<p>Todo: -</p>
<dl class="function">
<dt id="lexnlp.extract.en.urls.get_url_annotations">
<code class="sig-prename descclassname">lexnlp.extract.en.urls.</code><code class="sig-name descname">get_url_annotations</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[lexnlp.extract.common.annotations.url_annotation.UrlAnnotation, None], None]<a class="headerlink" href="#lexnlp.extract.en.urls.get_url_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find urls in text.</p>
</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.urls.get_urls">
<code class="sig-prename descclassname">lexnlp.extract.en.urls.</code><code class="sig-name descname">get_urls</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[str, None], None]<a class="headerlink" href="#lexnlp.extract.en.urls.get_urls" title="Permalink to this definition">¶</a></dt>
<dd><p>Find urls in text.</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en.utils">
<span id="lexnlp-extract-en-utils-module"></span><h2>lexnlp.extract.en.utils module<a class="headerlink" href="#module-lexnlp.extract.en.utils" title="Permalink to this headline">¶</a></h2>
<p>Extraction utilities for English.</p>
<dl class="class">
<dt id="lexnlp.extract.en.utils.NPExtractor">
<em class="property">class </em><code class="sig-prename descclassname">lexnlp.extract.en.utils.</code><code class="sig-name descname">NPExtractor</code><span class="sig-paren">(</span><em class="sig-param">grammar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.cleanup_leaves">
<code class="sig-name descname">cleanup_leaves</code><span class="sig-paren">(</span><em class="sig-param">leaves</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.cleanup_leaves" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.utils.NPExtractor.exception_pos">
<code class="sig-name descname">exception_pos</code><em class="property"> = ['IN', 'CC']</em><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.exception_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.utils.NPExtractor.exception_sym">
<code class="sig-name descname">exception_sym</code><em class="property"> = ['&amp;', 'and', 'of']</em><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.exception_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.get_np">
<code class="sig-name descname">get_np</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; Generator[[str, None], None]<a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.get_np" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.get_np_with_coords">
<code class="sig-name descname">get_np_with_coords</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[Tuple[str, int, int]]<a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.get_np_with_coords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.get_tokenizer">
<code class="sig-name descname">get_tokenizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.get_tokenizer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">np_items</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.join" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.sep">
<code class="sig-name descname">sep</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">current_pos</em>, <em class="sig-param">last_pos</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.sep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lexnlp.extract.en.utils.NPExtractor.strip_np">
<em class="property">static </em><code class="sig-name descname">strip_np</code><span class="sig-paren">(</span><em class="sig-param">np</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.strip_np" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.utils.NPExtractor.sym_with_space">
<code class="sig-name descname">sym_with_space</code><em class="property"> = ['(', '&amp;']</em><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.sym_with_space" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lexnlp.extract.en.utils.NPExtractor.sym_without_space">
<code class="sig-name descname">sym_without_space</code><em class="property"> = ['!', '&quot;', '#', '$', '%', &quot;'&quot;, ')', '*', '+', ',', '-', '.', '/', ':', ';', '&lt;', '=', '&gt;', '?', '&#64;', '[', '\\', ']', '^', '_', '`', '{', '|', '}', '~', &quot;'s&quot;]</em><a class="headerlink" href="#lexnlp.extract.en.utils.NPExtractor.sym_without_space" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="lexnlp.extract.en.utils.strip_unicode_punctuation">
<code class="sig-prename descclassname">lexnlp.extract.en.utils.</code><code class="sig-name descname">strip_unicode_punctuation</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">valid_punctuation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lexnlp.extract.en.utils.strip_unicode_punctuation" title="Permalink to this definition">¶</a></dt>
<dd><p>This method strips all unicode punctuation that is not whitelisted.
:param text: text to strip
:param valid_punctuation: valid punctuation to whitelist
:return:</p>
</dd></dl>

</div>
<div class="section" id="module-lexnlp.extract.en">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lexnlp.extract.en" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LexNLP</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About LexNLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lexnlp.html">LexNLP package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changes.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015-2020, ContraxSuite, LLC.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/api/lexnlp.extract.en.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>