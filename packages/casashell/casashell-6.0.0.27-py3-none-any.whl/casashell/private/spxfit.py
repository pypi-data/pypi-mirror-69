##################### generated by xml-casa (v2) from spxfit.xml ####################
##################### c60437ad5994d9fa4a638820743bb73e ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import spxfit as _spxfit_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _spxfit:
    """
    spxfit ---- Fit a 1-dimensional model(s) to an image(s) or region for determination of spectral index.

    --------- parameter descriptions ---------------------------------------------

    imagename  Name of the input image(s)
    box        Rectangular region to select in direction plane. Default is to use the entire direction plane.
    region     Region selection. Default is to use the full image.
    chans      Channels to use. Default is to use all channels.
    stokes     Stokes planes to use. Default is to use all Stokes planes.
    axis       The profile axis. Default: use the spectral axis if one exists, axis 0 otherwise (<0).
    mask       Mask to use. Default is none.
    minpts     Minimum number of unmasked points necessary to attempt fit.
    multifit   If true, fit a profile along the desired axis at each pixel in the specified region. If false, average the non-fit axis pixels and do a single fit to that average profile. Default False.
    spxtype    Type of function to fit. "plp" = power logarithmic polynomial, "ltp" = logarithmic transformed polynomial.
    spxest     REQUIRED. Initial estimates as array of numerical values for the spectral index function coefficients. eg [1.5, -0.8] if fitting a plp function thought to be close to 1.5*(x/div)**(-0.8) or [0.4055, -0.8] if fitting an lpt function thought to be close to ln(1.5) - 0.8*ln(x/div).
    spxfix     Fix the corresponding spectral index function coefficients during the fit. True means hold fixed.
    div        Divisor (numerical value or quantity) to use in the logarithmic terms of the plp or ltp function. 0 means calculate a useful value on the fly.
    spxsol     Name of the spectral index function coefficient solution image to write.
    spxerr     Name of the spectral index function coefficient error image to write.
    model      Name of model image. Default: do not write the model image ("").
    residual   Name of residual image. Default: do not write the residual image ("").
    wantreturn Should a record summarizing the results be returned?
    stretch    Stretch the mask if necessary and possible?
    logresults Output results to logger?
    logfile    File in which to log results. Default is not to write a logfile.
    append     Append results to logfile? Logfile must be specified. Default is to append. False means overwrite existing file if it exists.
    sigma      Standard deviation array or image name(s).
    outsigma   Name of output image used for standard deviation. Ignored if sigma is empty.
    [1;42mRETURNS[1;m       record

    --------- examples -----------------------------------------------------------

    
    
    This task fits a power logarithmic polynomial or a logarithmic tranformed polynomial to one dimensional profiles for determination of spectral indices.
    
    PARAMETER SUMMARY
    imagename       Name of the input image(s). More than one image name can be given as an
    array, in which case the images are concatenated along the specified axis
    and the resultant image is what is used by the fitter. In this case,
    all images must have the same dimensions along all axes other than the fit axis.
    box             Rectangular region to select in direction plane.
    Default is to use the entire direction plane.
    region          Region selection. Default is to use the full image.
    chans           Channels to use. Default is to use all channels.
    stokes          Stokes planes to use. Default is to use all Stokes planes.
    axis            Axis along which to do the fit(s). <0 means use the spectral axis or the
    zeroth axis if a spectral axis is not present.
    mask            Mask to use. Default is none.
    stretch         Stretch the input mask if necessary and possible? Only used if a mask is specified.
    
    minpts          Minimum number of points necessary to attempt a fit.
    multifit        Fit models at each pixel in region (true) or average profiles and fit a single model (false).
    spxtype         Type of function to fit. "plp" => power logarithmic polynomial, "ltp" => logarithmic
    transformed polynomial.
    spxest          REQUIRED. Initial estimates as array of numerical values for the spectral index
    function coefficients. eg [1.5, -0.8] if fitting a plp function thought to be close to
    1.5*(x/div)**(-0.8), or [0.4055, -0.8] if fitting an lpt function thought to be close to
    ln(1.5) - 0.8*ln(x/div).
    spxfix          Fix the corresponding spx function coefficients during the fit. True=>hold fixed
    div             Divisor (numerical value or quantity) to use in the logarithmic terms of the plp or ltp
    function. 0 => calculate a useful value on the fly.
    spxsol          Name of the function coeffecients solution image to write.
    spxerr          Name of the function coeffecients error image to write.
    model           Name of model image to write.
    residual        Name of residual image to write.
    wantreturn      If true, return a record summarizing the fit results, if false, return false.
    stretch         Stretch the mask if necessary and possible?
    logresults      Output results to logger?
    logfile         File in which to log results. Default is not to write a logfile.
    append          Append results to logfile? Logfile must be specified. Default is to append. False means overwrite existing file if it exists.
    sigma           Standard deviation numerical array, image name (string), or string array of names of images which will be
    concatenated to create the sigma image that is used by the fitter.
    outsigma        Name of output image used for standard deviation. Ignored if sigma is empty.
    
    This application performs a non-linear, least squares fits using the Levenberg-Marquardt algorithm of either a power logarithmic polynomial or a
    logarithmic tranformed polynomial to pixel values along a specified axis of an image or images. A description of the fitting algorithm may be found
    in AIPS++ Note 224 (http://www.astron.nl/casacore/trunk/casacore/doc/notes/224.html) and in Numerical Recipes by W.H. Press et al., Cambridge
    University Press. These functions are most often used for fitting the spectral index and higher order terms of a spectrum. A power logarithmic
    polynomial (plp) has the form
    
    y = c0*(x/div)**(c1 + c2*ln(x/div) + c3*ln(x/div)**2 + ... + cn*ln(x/div)**(n - 1))
    
    and a logarithmic transformed polynomial (ltp) is simply the result of this equation after taking the natural log of both sides so that it has the form
    
    ln(y) = c0 + c1*ln(x/div) + c2*ln(x/div)**2 +  ... + cn*ln(x/div)**n
    
    Because the logarithm of the ordinate values must be taken before fitting a logarithmic transformed polynomial,
    all non-positive pixel values are effectively masked for the purposes of fitting.
    
    The coefficients of the two forms are equal to each other except that c0 in the second equation is equal to
    ln(c0) of the first. In the case of fitting a spectral index, which is traditionally represented as alpha, is
    equal to c1.
    
    In both cases, div is a numerical value used to scale abscissa values so they are closer to unity when they are sent to the fitter. This generally
    improves the probability that the fit will converge. This parameter may be specified via the div parameter. A value of 0
    (the default) indicates that the application should determine a reasonable value for div, which is determined via
    
    div = 10**int(log10(sqrt(min(x)*max(x))))
    
    where min(x) and max(x) are the minimum and maximum abscissa values, respectively.
    
    So, for example, if S(nu) is proportional to nu**alpha and you expect alpha to be near -0.8 and the value of S(nu) is 1.5 at
    1e9 Hz and your image(s) have spectral units of Hz, you would specify spxest=[1.5, -0.8] and div=1e9 when fitting a plp function,
    or spxest=[0.405, -0.8] and div=1e9 if fitting an ltp function close to ln(1.5) - 0.8*ln(x/div).
    
    
    A CAUTIONARY NOTE
    Note that the likelihood of getting a reliable solution increases with the number of good data points as well as the goodness
    of the initial estimate. It is possible that the first solution found might not be the best one, and
    so, if a solution is found, it is recommended that the fit be repeated using the solution of the previous fit as the
    initial estimatE for the new fit. This process should be repeated until the solutions from one fit to the next differ only insignificantly.
    The convergent solution is very likely the best solution.
    
    AXIS
    The axis parameter indicates on which axis profiles should be fit; a value <0 indicates the spectral axis should be used,
    or if one does not exist, that the zeroth axis should be used.
    
    MINIMUM NUMBER OF PIXELS
    The minpts parameter indicates the minimum number of unmasked pixels that must be present in order for a fit
    to be attempted. When multifit=T, positions with too few good points will be masked in any output images.
    
    ONE FIT OF REGION AVERAGE OR PIXEL BY PIXEL FIT
    The multifit parameter indicates if profiles should be fit at each pixel in the selected region (true), or if the profiles in that region should be
    averaged and the fit done to that average profile (false).
    
    FUNCTION TYPE
    Which function to fit is specified in the spxtype parameter. Only two values (case insensitive) are supported. A value of
    "plp" indicates that a power logarithmic polynomial should be fit. A value of "ltp" indicates a logarithmic transformed
    polynomial should be fit.
    
    INCLUDING STANDARD DEVIATIONS OF PIXEL VALUES
    If the standard deviations of the pixel values in the input image are known and they vary in the image (eg they are higher for pixels
    near the edge of the band), they can be included in the sigma parameter. This parameter takes either an array or an image name. The
    array or image must have one of three shapes: 1. the shape of the input image, 2. the same dimensions as the input image with the lengths
    of all axes being one except for the fit axis which must have length corresponding to its length in the input image, or 3. be one
    dimensional with lenght equal the the length of the fit axis in the input image. In cases 2 and 3, the array or pixels in sigma will
    be replicated such that the image that is ultimately used is the same shape as the input image. The values of sigma must be non-negative.
    It is only the relative values that are important. A value of 0 means that pixel should not be used in the fit. Other than that, if pixel
    A has a higher standard deviation than pixel B, then pixel A is noisier than pixel B and will receive a lower weight when the fit is done.
    The weight of a pixel is the usual
    
    weight = 1/(sigma*sigma)
    
    In the case of multifit=F, the sigma values at each pixel along the fit axis in the hyperplane perpendicular to the fit axis which includes
    that pixel are averaged and the resultant averaged standard deviation spectrum is the one used in the fit. Internally, sigma values are normalized
    such that the maximum value is 1. This mitigates a known overflow issue.
    
    One can write the normalized standard deviation image used in the fit by specifying its name in outsigma. This image can then be
    used as sigma for subsequent runs.
    
    RETURNED DICTIONARY STRUCTURE
    The returned dictionary has a (necessarily) complex structure. First, there are keys "xUnit" and "yUnit" whose values are
    the abscissa unit and the ordinate unit described by simple strings. Next there are arrays giving a broad overview of the
    fit quality. These arrays have the shape of the specified region collapsed along the fit axis with the axis corresponding to the fit
    axis having length of 1:
    
    attempted: a boolean array indicating which fits were attempted (eg if too few unmasked points, a fit will not be attempted).
    converged: a boolean array indicating which fits converged. False if the fit was not attempted.
    valid:     a boolean array indicating which solutions fall within the specified valid ranges of parameter space. Any solution for
    which a value or error is NaN is automatically marked as invalid.
    niter:     an int array indicating the number of iterations for each profile, <0 if the fit did not converge
    direction: a string array containing the world direction coordinate for each profile
    
    There is a "type" array having number of dimensions equal to the number of dimensions in the above arrays plus one. The shape of
    the first n-1 dimensions is the same as the shape of the above arrays. The length of the last dimension is equal to the number of
    components fit. The values of this array are all "POWER LOGARITHMIC POLYNOMIAL" or "LOGARITHMIC TRANSFORMED POLYNOMIAL", depending
    on which type function was fit.
    
    There will be a subdictionary accessible via the "plp" or "ltp" key (depending on which type of function was fit) which will have
    subkeys "solution" and "error" which will each have an array of values. Each of these arrays will have one more dimension than the overview arrays
    described above. The shape of the first n-1 dimensions will be the same as the shape of the overview arrays described above, while the
    final dimension will have length equal to the number of parameters that were fit. Along this axis will be the
    corresponding fit result or associated error (depending on the array's associated key) of the fit. In cases where
    the fit was not attempted or did not converge, a value of NAN will be present.
    
    OUTPUT IMAGES
    In addition to the returned dictionary, optionally one or more of any combination of output images can be written.
    The model and residual parameters indicate the names of the model and residual images to be written; empty values inidcate that these images
    should not be written.
    
    The parameters spxsol and spxerr are the names of the solution and error images to write, respectively. In cases
    where more than one coefficient are fit, the image names will be appended with an underscore followed by the relevant
    coefficient number ("_0", "_1", etc). These images contain the arrays for the associated parameter solutions or errors
    described in previous sections. Pixels for which fits were not attempted, did not converge, or converged but have values
    of NaN (not a number) or INF (infinity) will be masked as bad.
    
    LPT vs PLP
    Ultimately, the choice of which functional form to use in determining the spectral index is up to the user and should be based
    on the scientific goals. However, below is a summary of one user's experience and preferences as an example:
    
    If the weights are known or can be determined from the images (eg. the source-free image rms and a fractional calibration error) then I
    favor a weighted fit using the non-linear (power-law) model. An unweighted fit using the non-linear model will, in general, give far
    too much leverage to large flux values.
    
    If the weights are unknown or will not be considered by the fitting algorithm, then I prefer the log-transformed polynomial model. However,
    this does not work well in low signal-to-noise regions. A conservative mask could be created such that only high s/n areas are fit,
    but this could hinder many science objectives.
    
    EXAMPLES
    
    res = spxfit(imagename=["im0.im","im1.im"], multifit=true, spxtype="plp", spxest=[0.5,2,0.1], div="1GHz", spxsol="myplpsolutions.im")


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Fit a 1-dimensional model(s) to an image(s) or region for determination of spectral index."""

    __schema = {'imagename': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'box': {'type': 'cStr'}, 'region': {'type': 'cStr'}, 'chans': {'type': 'cStr'}, 'stokes': {'type': 'cStr'}, 'axis': {'type': 'cInt'}, 'mask': {'type': 'cStr'}, 'minpts': {'type': 'cInt'}, 'multifit': {'type': 'cBool'}, 'spxtype': {'type': 'cStr'}, 'spxest': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'spxfix': {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}, 'div': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'spxsol': {'type': 'cStr'}, 'spxerr': {'type': 'cStr'}, 'model': {'type': 'cStr'}, 'residual': {'type': 'cStr'}, 'wantreturn': {'type': 'cBool'}, 'stretch': {'type': 'cBool'}, 'logresults': {'type': 'cBool'}, 'logfile': {'type': 'cStr'}, 'append': {'type': 'cBool'}, 'sigma': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'outsigma': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __spxtype_dflt( self, glb ):
        return 'plp'

    def __spxtype( self, glb ):
        if 'spxtype' in glb: return glb['spxtype']
        return 'plp'

    def __div_dflt( self, glb ):
        return [ ]

    def __div( self, glb ):
        if 'div' in glb: return glb['div']
        return [ ]

    def __wantreturn_dflt( self, glb ):
        return True

    def __wantreturn( self, glb ):
        if 'wantreturn' in glb: return glb['wantreturn']
        return True

    def __sigma_dflt( self, glb ):
        return ''

    def __sigma( self, glb ):
        if 'sigma' in glb: return glb['sigma']
        return ''

    def __logresults_dflt( self, glb ):
        return True

    def __logresults( self, glb ):
        if 'logresults' in glb: return glb['logresults']
        return True

    def __multifit_dflt( self, glb ):
        return False

    def __multifit( self, glb ):
        if 'multifit' in glb: return glb['multifit']
        return False

    def __minpts_dflt( self, glb ):
        return int(1)

    def __minpts( self, glb ):
        if 'minpts' in glb: return glb['minpts']
        return int(1)

    def __axis_dflt( self, glb ):
        return int(-1)

    def __axis( self, glb ):
        if 'axis' in glb: return glb['axis']
        return int(-1)

    def __spxest_dflt( self, glb ):
        return [  ]

    def __spxest( self, glb ):
        if 'spxest' in glb: return glb['spxest']
        return [  ]

    def __logfile_dflt( self, glb ):
        return ''

    def __logfile( self, glb ):
        if 'logfile' in glb: return glb['logfile']
        return ''

    def __mask_dflt( self, glb ):
        return ''

    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __region_dflt( self, glb ):
        return ''

    def __region( self, glb ):
        if 'region' in glb: return glb['region']
        return ''

    def __chans_dflt( self, glb ):
        return ''

    def __chans( self, glb ):
        if 'chans' in glb: return glb['chans']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __box_dflt( self, glb ):
        return ''

    def __box( self, glb ):
        if 'box' in glb: return glb['box']
        return ''

    def __spxfix_dflt( self, glb ):
        return [  ]

    def __spxfix( self, glb ):
        if 'spxfix' in glb: return glb['spxfix']
        return [  ]



    #--------- return inp/go default --------------------------------------------------
    def __spxsol_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __residual_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __model_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __spxerr_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __stretch_dflt( self, glb ):
        if self.__mask( glb ) != "": return bool(False)
        return None
    def __outsigma_dflt( self, glb ):
        if self.__sigma( glb ) != "": return ""
        return None
    def __append_dflt( self, glb ):
        if self.__logfile( glb ) != "": return bool(True)
        return None

    #--------- return subparam values -------------------------------------------------
    def __spxsol( self, glb ):
        if 'spxsol' in glb: return glb['spxsol']
        dflt = self.__spxsol_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spxerr( self, glb ):
        if 'spxerr' in glb: return glb['spxerr']
        dflt = self.__spxerr_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __model( self, glb ):
        if 'model' in glb: return glb['model']
        dflt = self.__model_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __residual( self, glb ):
        if 'residual' in glb: return glb['residual']
        dflt = self.__residual_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __stretch( self, glb ):
        if 'stretch' in glb: return glb['stretch']
        dflt = self.__stretch_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        dflt = self.__append_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __outsigma( self, glb ):
        if 'outsigma' in glb: return glb['outsigma']
        dflt = self.__outsigma_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __box_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__box( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'box': value},{'box': self.__schema['box']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('box',pre,self.__to_string_(value),post,description))
    def __region_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__region( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'region': value},{'region': self.__schema['region']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('region',pre,self.__to_string_(value),post,description))
    def __chans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chans': value},{'chans': self.__schema['chans']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('chans',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __axis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__axis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'axis': value},{'axis': self.__schema['axis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('axis',pre,self.__to_string_(value),post,description))
    def __mask_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mask( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mask',pre,self.__to_string_(value),post,description))
    def __minpts_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__minpts( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'minpts': value},{'minpts': self.__schema['minpts']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('minpts',pre,self.__to_string_(value),post,description))
    def __multifit_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__multifit( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'multifit': value},{'multifit': self.__schema['multifit']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('multifit',pre,self.__to_string_(value),post,description))
    def __spxtype_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spxtype( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spxtype': value},{'spxtype': self.__schema['spxtype']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('spxtype',pre,self.__to_string_(value),post,description))
    def __spxest_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spxest( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spxest': value},{'spxest': self.__schema['spxest']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('spxest',pre,self.__to_string_(value),post,description))
    def __spxfix_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spxfix( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spxfix': value},{'spxfix': self.__schema['spxfix']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('spxfix',pre,self.__to_string_(value),post,description))
    def __div_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__div( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'div': value},{'div': self.__schema['div']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('div',pre,self.__to_string_(value),post,description))
    def __spxsol_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spxsol_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spxsol( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spxsol': value},{'spxsol': self.__schema['spxsol']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spxsol',pre,self.__to_string_(value),post,description))
    def __spxerr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spxerr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spxerr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spxerr': value},{'spxerr': self.__schema['spxerr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spxerr',pre,self.__to_string_(value),post,description))
    def __model_inp(self):
        out = self.__stdout or sys.stdout
        if self.__model_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__model( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'model': value},{'model': self.__schema['model']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('model',pre,self.__to_string_(value),post,description))
    def __residual_inp(self):
        out = self.__stdout or sys.stdout
        if self.__residual_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__residual( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'residual': value},{'residual': self.__schema['residual']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('residual',pre,self.__to_string_(value),post,description))
    def __wantreturn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__wantreturn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'wantreturn': value},{'wantreturn': self.__schema['wantreturn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('wantreturn',pre,self.__to_string_(value),post,description))
    def __stretch_inp(self):
        out = self.__stdout or sys.stdout
        if self.__stretch_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__stretch( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'stretch': value},{'stretch': self.__schema['stretch']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('stretch',pre,self.__to_string_(value),post,description))
    def __logresults_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__logresults( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'logresults': value},{'logresults': self.__schema['logresults']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('logresults',pre,self.__to_string_(value),post,description))
    def __logfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__logfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'logfile': value},{'logfile': self.__schema['logfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('logfile',pre,self.__to_string_(value),post,description))
    def __append_inp(self):
        out = self.__stdout or sys.stdout
        if self.__append_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__append( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('append',pre,self.__to_string_(value),post,description))
    def __sigma_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__sigma( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'sigma': value},{'sigma': self.__schema['sigma']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('sigma',pre,self.__to_string_(value),post,description))
    def __outsigma_inp(self):
        out = self.__stdout or sys.stdout
        if self.__outsigma_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__outsigma( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'outsigma': value},{'outsigma': self.__schema['outsigma']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outsigma',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'stokes' in glb: del glb['stokes']
        if 'spxsol' in glb: del glb['spxsol']
        if 'spxtype' in glb: del glb['spxtype']
        if 'residual' in glb: del glb['residual']
        if 'mask' in glb: del glb['mask']
        if 'model' in glb: del glb['model']
        if 'wantreturn' in glb: del glb['wantreturn']
        if 'spxerr' in glb: del glb['spxerr']
        if 'logresults' in glb: del glb['logresults']
        if 'stretch' in glb: del glb['stretch']
        if 'imagename' in glb: del glb['imagename']
        if 'div' in glb: del glb['div']
        if 'sigma' in glb: del glb['sigma']
        if 'logfile' in glb: del glb['logfile']
        if 'spxfix' in glb: del glb['spxfix']
        if 'multifit' in glb: del glb['multifit']
        if 'chans' in glb: del glb['chans']
        if 'region' in glb: del glb['region']
        if 'outsigma' in glb: del glb['outsigma']
        if 'box' in glb: del glb['box']
        if 'minpts' in glb: del glb['minpts']
        if 'axis' in glb: del glb['axis']
        if 'spxest' in glb: del glb['spxest']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__box_inp( )
        self.__region_inp( )
        self.__chans_inp( )
        self.__stokes_inp( )
        self.__axis_inp( )
        self.__mask_inp( )
        self.__minpts_inp( )
        self.__multifit_inp( )
        self.__spxtype_inp( )
        self.__spxest_inp( )
        self.__spxfix_inp( )
        self.__div_inp( )
        self.__spxsol_inp( )
        self.__spxerr_inp( )
        self.__model_inp( )
        self.__residual_inp( )
        self.__wantreturn_inp( )
        self.__stretch_inp( )
        self.__logresults_inp( )
        self.__logfile_inp( )
        self.__append_inp( )
        self.__sigma_inp( )
        self.__outsigma_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("spxfit.last"):
                filename = "spxfit.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, box=None, region=None, chans=None, stokes=None, axis=None, mask=None, minpts=None, multifit=None, spxtype=None, spxest=None, spxfix=None, div=None, spxsol=None, spxerr=None, model=None, residual=None, wantreturn=None, stretch=None, logresults=None, logfile=None, append=None, sigma=None, outsigma=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('spxfit.pre')
        _postfile = os.path.realpath('spxfit.last')
        _return_result_ = None
        _arguments = [imagename,box,region,chans,stokes,axis,mask,minpts,multifit,spxtype,spxest,spxfix,div,spxsol,spxerr,model,residual,wantreturn,stretch,logresults,logfile,append,sigma,outsigma]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if box is not None: local_global['box'] = box
            if region is not None: local_global['region'] = region
            if chans is not None: local_global['chans'] = chans
            if stokes is not None: local_global['stokes'] = stokes
            if axis is not None: local_global['axis'] = axis
            if mask is not None: local_global['mask'] = mask
            if minpts is not None: local_global['minpts'] = minpts
            if multifit is not None: local_global['multifit'] = multifit
            if spxtype is not None: local_global['spxtype'] = spxtype
            if spxest is not None: local_global['spxest'] = spxest
            if spxfix is not None: local_global['spxfix'] = spxfix
            if div is not None: local_global['div'] = div
            if wantreturn is not None: local_global['wantreturn'] = wantreturn
            if logresults is not None: local_global['logresults'] = logresults
            if logfile is not None: local_global['logfile'] = logfile
            if sigma is not None: local_global['sigma'] = sigma

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['box'] = self.__box( local_global )
            _invocation_parameters['region'] = self.__region( local_global )
            _invocation_parameters['chans'] = self.__chans( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['axis'] = self.__axis( local_global )
            _invocation_parameters['mask'] = self.__mask( local_global )
            _invocation_parameters['minpts'] = self.__minpts( local_global )
            _invocation_parameters['multifit'] = self.__multifit( local_global )
            _invocation_parameters['spxtype'] = self.__spxtype( local_global )
            _invocation_parameters['spxest'] = self.__spxest( local_global )
            _invocation_parameters['spxfix'] = self.__spxfix( local_global )
            _invocation_parameters['div'] = self.__div( local_global )
            _invocation_parameters['wantreturn'] = self.__wantreturn( local_global )
            _invocation_parameters['logresults'] = self.__logresults( local_global )
            _invocation_parameters['logfile'] = self.__logfile( local_global )
            _invocation_parameters['sigma'] = self.__sigma( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['spxsol'] = self.__spxsol( _invocation_parameters ) if spxsol is None else spxsol
            _invocation_parameters['spxerr'] = self.__spxerr( _invocation_parameters ) if spxerr is None else spxerr
            _invocation_parameters['model'] = self.__model( _invocation_parameters ) if model is None else model
            _invocation_parameters['residual'] = self.__residual( _invocation_parameters ) if residual is None else residual
            _invocation_parameters['stretch'] = self.__stretch( _invocation_parameters ) if stretch is None else stretch
            _invocation_parameters['append'] = self.__append( _invocation_parameters ) if append is None else append
            _invocation_parameters['outsigma'] = self.__outsigma( _invocation_parameters ) if outsigma is None else outsigma

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['box'] = self.__box( self.__globals_( ) )
            _invocation_parameters['region'] = self.__region( self.__globals_( ) )
            _invocation_parameters['chans'] = self.__chans( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['axis'] = self.__axis( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['minpts'] = self.__minpts( self.__globals_( ) )
            _invocation_parameters['multifit'] = self.__multifit( self.__globals_( ) )
            _invocation_parameters['spxtype'] = self.__spxtype( self.__globals_( ) )
            _invocation_parameters['spxest'] = self.__spxest( self.__globals_( ) )
            _invocation_parameters['spxfix'] = self.__spxfix( self.__globals_( ) )
            _invocation_parameters['div'] = self.__div( self.__globals_( ) )
            _invocation_parameters['spxsol'] = self.__spxsol( self.__globals_( ) )
            _invocation_parameters['spxerr'] = self.__spxerr( self.__globals_( ) )
            _invocation_parameters['model'] = self.__model( self.__globals_( ) )
            _invocation_parameters['residual'] = self.__residual( self.__globals_( ) )
            _invocation_parameters['wantreturn'] = self.__wantreturn( self.__globals_( ) )
            _invocation_parameters['stretch'] = self.__stretch( self.__globals_( ) )
            _invocation_parameters['logresults'] = self.__logresults( self.__globals_( ) )
            _invocation_parameters['logfile'] = self.__logfile( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['sigma'] = self.__sigma( self.__globals_( ) )
            _invocation_parameters['outsigma'] = self.__outsigma( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#spxfit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _spxfit_t( _invocation_parameters['imagename'],_invocation_parameters['box'],_invocation_parameters['region'],_invocation_parameters['chans'],_invocation_parameters['stokes'],_invocation_parameters['axis'],_invocation_parameters['mask'],_invocation_parameters['minpts'],_invocation_parameters['multifit'],_invocation_parameters['spxtype'],_invocation_parameters['spxest'],_invocation_parameters['spxfix'],_invocation_parameters['div'],_invocation_parameters['spxsol'],_invocation_parameters['spxerr'],_invocation_parameters['model'],_invocation_parameters['residual'],_invocation_parameters['wantreturn'],_invocation_parameters['stretch'],_invocation_parameters['logresults'],_invocation_parameters['logfile'],_invocation_parameters['append'],_invocation_parameters['sigma'],_invocation_parameters['outsigma'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

spxfit = _spxfit( )

