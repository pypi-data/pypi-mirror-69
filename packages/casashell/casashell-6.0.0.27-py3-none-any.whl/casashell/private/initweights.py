##################### generated by xml-casa (v2) from initweights.xml ###############
##################### 091fd8f0d036e58aa774ba48ec7cb0b9 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import initweights as _initweights_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _initweights:
    """
    initweights ---- Initializes weight information in the MS

    --------- parameter descriptions ---------------------------------------------

    vis       Name of input visibility file (MS)
    wtmode    Initialization mode
    tsystable Tsys calibration table to apply on the fly
    gainfield Select a subset of calibrators from Tsys table
    interp    Interpolation type in time[,freq]. default==\'linear,linear\'
    spwmap    Spectral windows combinations to form for gaintable(s)
    dowtsp    Initialize the WEIGHT_SPECTRUM column
    [1;42mRETURNS[1;m      void

    --------- examples -----------------------------------------------------------

    
    
    This task provides for initialization of the weight information
    in the MS.  For ALMA interferometry and EVLA data, it should not
    generally be necessary to use this task, as the weight information
    should have been initialized properly at fill time (v4.2.2 and later).
    
    Several initialization modes are supported via the wtmode parameter.
    
    If wtmode='nyq' (the default), SIGMA and WEIGHT will be
    initialized according to bandwidth and integration time.  This
    is the theoretically correct mode for raw normalized visibilities.
    (e.g., ALMA).  For the EVLA, this is correct if switched-power
    and bandpass calibration will later be applied.
    
    If wtmode='sigma', WEIGHT will be initialized according to the
    existing SIGMA column.
    
    If wtmode='weight', WEIGHT_SPECTRUM will be initialized according
    to the existing WEIGHT column; dowtspec=T must be specified in
    this case.
    
    If wtmode='ones', SIGMA and WEIGHT will be initialized with 1.0,
    globally.  This is a traditional means of initializing weight
    information, and is adequate when the integration time and
    bandwidth are uniform. It is not recommended for modern
    instruments (ALMA, EVLA), where variety in observational setups
    is common, and properly initialized and calibrated weights
    will be used for imaging sensitivity estimates.
    
    There are two EXPERIMENTAL modes, wtmode='tsys' and 'tinttsys'.
    In the modes, SIGMA and WEIGHT will be initialized according to
    Tsys, bandwidth, and integration time (used only in 'tinttsys'),
    i.e.,
    tsys    : weight=bw/Tsys^2
    tinttsys: weight=bw*t_int/Tsys^2
    These modes use Tsys values to calculate weight as is done in
    Tsys calibration. Tsys values are taken from a tsys calibration
    table given as tsystable. Selection of gain field (gainfield),
    interpolation method (interp), and spectral window mapping (spwmap)
    are supported, too.
    Available types of interpolation are,
    Time: 'nearest', 'linear', the variation of those with 'perobs',
    e.g., 'linearperobs' (enforce obsId boundaries in interpolation)
    Freq: 'nearest', 'linear', 'cubic', 'spline', and the variation
    of those with 'flag', e.g., 'linearflag' (with
    channelized flag).
    See the help of applycal for details of interpolations.
    Note if the weight in an MS is initialized with these modes and
    Tsys calibration table is applied with calwt=True after that, the
    weight would be contaminated by being devided by square of Tsys
    twice.
    !!! USERS ARE ADVICED TO USE THESE EXPERIMENTAL MODES WITH CARE !!!
    
    For the above wtmodes, if dowtsp=T (or if the WEIGHT_SPECTRUM
    column already exists), the WEIGHT_SPECTRUM column will be
    initialized (uniformly in channel in wtmode='nyq', 'sigma',
    'weight', and 'ones'), in a manner consistent with the
    disposition of the WEIGHT column.  If the WEIGHT_SPECTRUM
    column does not exist, dowtsp=T will force its creation.
    Use of the WEIGHT_SPECTRUM column is only meaningful
    for ALMA data which will be calibrated with channelized
    Tsys information, or if the weights will become channelized
    after calibration, e.g., via averaging over time- and
    channel-dependent flagging.  (A task for channel-dependent
    weight estimation from the data itself is also currently under
    development).
    In non-channelized modes (wtmode='nyq', 'sigma', 'weight', and
    'ones') or when dowtsp=F, SIGMA_SPECTRUM column will be removed
    from MS. On the other hand, SIGMA_SPECTRUM column is added and
    initialized in channelized modes (wtmode='tsys' and 'tinttsys')
    if dowtsp=T or WEIGHT_SPECTRUM already column exists.
    
    Two additional modes are available for managing the spectral
    weight info columns; these should be used with extreme care: If
    wtmode='delwtsp', the WEIGHT_SPECTRUM column will be deleted (if
    it exists).  If wtmode='delsigsp', the SIGMA_SPECTRUM column
    will be deleted (if it exists).  Note that creation of
    SIGMA_SPECTRUM is not supported via this method.
    
    Note that this task does not support any prior selection.
    Intialization of the weight information must currently be done
    globally or not at all.  This is to maintain consistency.
    
    


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Initializes weight information in the MS"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'wtmode': {'type': 'cStr'}, 'tsystable': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'gainfield': {'type': 'cStr'}, 'interp': {'type': 'cStr'}, 'spwmap': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'dowtsp': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __dowtsp_dflt( self, glb ):
        return False

    def __dowtsp( self, glb ):
        if 'dowtsp' in glb: return glb['dowtsp']
        return False

    def __wtmode_dflt( self, glb ):
        return 'nyq'

    def __wtmode( self, glb ):
        if 'wtmode' in glb: return glb['wtmode']
        return 'nyq'



    #--------- return inp/go default --------------------------------------------------
    def __interp_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return ""
        if self.__wtmode( glb ) == "tinttsys": return ""
        return None
    def __gainfield_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return ""
        if self.__wtmode( glb ) == "tinttsys": return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return []
        if self.__wtmode( glb ) == "tinttsys": return []
        return None
    def __tsystable_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return UNKNOWN
        if self.__wtmode( glb ) == "tinttsys": return UNKNOWN
        return None

    #--------- return subparam values -------------------------------------------------
    def __tsystable( self, glb ):
        if 'tsystable' in glb: return glb['tsystable']
        dflt = self.__tsystable_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        dflt = self.__gainfield_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [  ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __wtmode_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__wtmode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'wtmode': value},{'wtmode': self.__schema['wtmode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('wtmode',pre,self.__to_string_(value),post,description))
    def __tsystable_inp(self):
        out = self.__stdout or sys.stdout
        if self.__tsystable_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__tsystable( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'tsystable': value},{'tsystable': self.__schema['tsystable']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('tsystable',pre,self.__to_string_(value),post,description))
    def __gainfield_inp(self):
        out = self.__stdout or sys.stdout
        if self.__gainfield_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__gainfield( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gainfield',pre,self.__to_string_(value),post,description))
    def __interp_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interp( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interp',pre,self.__to_string_(value),post,description))
    def __spwmap_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwmap',pre,self.__to_string_(value),post,description))
    def __dowtsp_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__dowtsp( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'dowtsp': value},{'dowtsp': self.__schema['dowtsp']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('dowtsp',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'dowtsp' in glb: del glb['dowtsp']
        if 'gainfield' in glb: del glb['gainfield']
        if 'spwmap' in glb: del glb['spwmap']
        if 'tsystable' in glb: del glb['tsystable']
        if 'vis' in glb: del glb['vis']
        if 'interp' in glb: del glb['interp']
        if 'wtmode' in glb: del glb['wtmode']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__wtmode_inp( )
        self.__tsystable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__dowtsp_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("initweights.last"):
                filename = "initweights.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, wtmode=None, tsystable=None, gainfield=None, interp=None, spwmap=None, dowtsp=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('initweights.pre')
        _postfile = os.path.realpath('initweights.last')
        _return_result_ = None
        _arguments = [vis,wtmode,tsystable,gainfield,interp,spwmap,dowtsp]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if wtmode is not None: local_global['wtmode'] = wtmode
            if dowtsp is not None: local_global['dowtsp'] = dowtsp

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['wtmode'] = self.__wtmode( local_global )
            _invocation_parameters['dowtsp'] = self.__dowtsp( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['tsystable'] = self.__tsystable( _invocation_parameters ) if tsystable is None else tsystable
            _invocation_parameters['gainfield'] = self.__gainfield( _invocation_parameters ) if gainfield is None else gainfield
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['wtmode'] = self.__wtmode( self.__globals_( ) )
            _invocation_parameters['tsystable'] = self.__tsystable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['dowtsp'] = self.__dowtsp( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#initweights( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _initweights_t( _invocation_parameters['vis'],_invocation_parameters['wtmode'],_invocation_parameters['tsystable'],_invocation_parameters['gainfield'],_invocation_parameters['interp'],_invocation_parameters['spwmap'],_invocation_parameters['dowtsp'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

initweights = _initweights( )

