##################### generated by xml-casa (v2) from cvel.xml ######################
##################### 55b7b927cc8f843235c7fae1646f1c3a ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import cvel as _cvel_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _cvel:
    """
    cvel ---- regrid an MS to a new spectral window / channel structure or frame

    
    The intent of cvel is to transform channel labels and the
    visibilities to a spectral reference frame which is appropriate
    for the science analysis, e.g. from TOPO to LSRK to correct for
    Doppler shifts throughout the time of the observation. Naturally,
    this will change the shape of the spectral feature to some extent.
    According to the Nyquist theorem you should oversample a spectrum
    with twice the numbers of channels to retain the shape. Based on
    some tests, however, we recommend to observe with at least
    3-4 times the number of channels for each significant spectral
    feature (like 3-4 times the linewidth). This will minimize
    regridding artifacts in cvel.
    
    If cvel has already established the grid that is desired for the
    imaging, clean should be run with exactly the same frequency/velocity
    parameters as used in cvel in order to avoid additional regridding in
    clean.
    
    Hanning smoothing is optionally offered in cvel, but tests have
    shown that already the regridding process itself, if it involved
    a transformation from TOPO to a non-terrestrial reference frame,
    implies some smoothing (due to channel interpolation) such that
    Hanning smoothing may not be necessary.

    --------- parameter descriptions ---------------------------------------------

    vis           Name of input measurement set
    outputvis     Name of output measurement set
    passall       Pass through (write to output MS) non-selected data with no change
    field         Select field using field id(s) or field name(s)
    spw           Select spectral window/channels
    selectdata    Other data selection parameters
    antenna       Select data based on antenna/baseline
    timerange     Range of time to select from data
    scan          scan number range
    array         (sub)array indices
    mode          Regridding mode
    nchan         Number of channels in output spw (-1=all). Used for regridding, together with \'start\' and \'width\'.
    start         Start of the output visibilities. Used for regridding, together with \'width\' and \'nchan\'. It can be in different units, depending on the regridding mode: first input channel (mode=\'channel\'), first velocity (mode=\'velocity\'), or first frequency (mode=\'frequency\'). Example values: \'5\', \'0.0km/s\', \'1.4GHz\', for channel, velocity, and frequency modes, respectively.
    width         Channel width of the output visibilities. Used for regridding, together with \'start\', and \'nchan\'. It can be in different units, depending on the regridding mode: number of input channels (mode=\'channel\'), velocity (mode=\'velocity\'), or frequency (mode=\'frequency\'. Example values: \'2\', \'1.0km/s\', \'1.0kHz\', for channel, velocity, and frequency modes, respectively.
    interpolation Spectral interpolation method
    phasecenter   Phase center direction to be used for the spectral coordinate transformation: direction measure or field index
    restfreq      rest frequency (see help)
    outframe      Output frame (not case-sensitive, \'\'=keep input frame)
    veltype       velocity definition
    hanning       If true, Hanning smooth data before regridding to remove Gibbs ringing.
    [1;42mRETURNS[1;m          void

    --------- examples -----------------------------------------------------------

    
    
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    
    outputvis -- Name of output measurement set (required)
    default: none; example: vis='ngc5921-regridded.ms'
    
    passall --  if False, data not meeting the selection is omitted/deleted
    or flagged (if in-row); if True, data not meeting the selection
    on field and spw is passed through without modification
    default: False; example:
    field='NGC5921'
    passall=False : only data from NGC5921 is included in output MS,
    no data from other fields (e.g. 1331+305) is included
    passall=True : data from NGC5921 is transformed by cvel, all other
    fields are passed through unchanged
    
    field -- Select fields in mosaic.  Use field id(s) or field name(s).
    ['go listobs' to obtain the list id's or names]
    default: ''= all fields
    If field string is a non-negative integer, it is assumed to
    be a field index otherwise, it is assumed to be a
    field name
    field='0~2'; field ids 0,1,2
    field='0,4,5~7'; field ids 0,4,5,6,7
    field='3C286,3C295'; field named 3C286 and 3C295
    field = '3,4C*'; field id 3, all names starting with 4C
    
    spw --Select spectral window/channels
    NOTE: This selects the data passed as the INPUT to mode
    default: ''=all spectral windows and channels
    spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
    spw='0:5~61'; spw 0, channels 5 to 61
    spw='<2';   spectral windows less than 2 (i.e. 0,1)
    spw='0,10,3:3~45'; spw 0,10 all channels, spw 3,
    channels 3 to 45.
    spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
    spw='0:0~10;15~60'; spectral window 0 with channels
    0-10,15-60
    spw='0:0~10,1:20~30,2:1;2;3'; spw 0, channels 0-10,
    spw 1, channels 20-30, and spw 2, channels, 1,2 and 3
    
    selectdata -- Other data selection parameters
    default: True
    
    >>> selectdata=True expandable parameters
    
    antenna -- Select data based on antenna/baseline
    default: '' (all)
    If antenna string is a non-negative integer, it is
    assumed to be an antenna index, otherwise, it is
    considered an antenna name.
    antenna='5&6'; baseline between antenna index 5 and
    index 6.
    antenna='VA05&VA06'; baseline between VLA antenna 5
    and 6.
    antenna='5&6;7&8'; baselines 5-6 and 7-8
    antenna='5'; all baselines with antenna index 5
    antenna='05'; all baselines with antenna number 05
    (VLA old name)
    antenna='5,6,9'; all baselines with antennas 5,6,9
    index numbers
    
    timerange  -- Select data based on time range:
    default = '' (all); examples,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: if YYYY/MM/DD is missing date defaults to first
    day in data set
    timerange='09:14:0~09:54:0' picks 40 min on first day
    timerange= '25:00:00~27:30:00' picks 1 hr to 3 hr
    30min on NEXT day
    timerange='09:44:00' pick data within one integration
    of time
    timerange='>10:24:00' data after this time
    
    scan -- Scan number range.
    default: '' (all)
    example: scan='1~5'
    Check 'go listobs' to insure the scan numbers are in
    order.
    
    array -- Select data by (sub)array indices
    default: '' (all); example:
    array='0~2'; arrays 0 to 2
    
    mode -- Frequency Specification:
    NOTE: See examples below:
    default: 'channel'
    mode = 'channel'; Use with nchan, start, width to specify
    output spw. Produces equidistant grid based on first
    selected channel. See examples below.
    mode = 'velocity', means channels are specified in
    velocity.
    mode = 'frequency', means channels are specified in
    frequency.
    mode = 'channel_b', alternative 'channel' mode.
    Does not force an equidistant grid. Faster.
    
    >>> mode expandable parameters
    Start, width are given in units of channels, frequency
    or velocity as indicated by mode
    nchan -- Number of channels in output spw
    default: -1 = all channels; example: nchan=3
    start -- Start or end input channel (zero-based) depending on the sign of the width parameter
    default=0; example: start=5
    width -- Output channel width in units of the input
    channel width (sign indicates whether the start parameter is lower(+) or upper(-) end of the range)
    default=1; example: width=4
    interpolation -- Interpolation method (linear, nearest, cubic, spline, fftshift)
    default = 'linear'
    examples:
    spw = '0,1'; mode = 'channel'
    will produce a single spw containing all channels in spw
    0 and 1
    spw='0:5~28^2'; mode = 'channel'
    will produce a single spw made with channels
    (5,7,9,...,25,27)
    spw = '0'; mode = 'channel': nchan=3; start=5; width=4
    will produce an spw with 3 output channels
    new channel 1 contains data from channels (5+6+7+8)
    new channel 2 contains data from channels (9+10+11+12)
    new channel 3 contains data from channels (13+14+15+16)
    spw = '0:0~63^3'; mode='channel'; nchan=21; start = 0;
    width = 1
    will produce an spw with 21 channels
    new channel 1 contains data from channel 0
    new channel 2 contains data from channel 2
    new channel 21 contains data from channel 61
    spw = '0:0~40^2'; mode = 'channel'; nchan = 3; start =
    5; width = 4
    will produce an spw with three output channels
    new channel 1 contains channels (5,7)
    new channel 2 contains channels (13,15)
    new channel 3 contains channels (21,23)
    
    phasecenter -- Direction measure  or fieldid. To be used in mosaics to indicate
    the center direction to be used in the spectral coordinate transformation.
    default: '' => first field selected ; example: phasecenter=6
    or phasecenter='J2000 19h30m00 -40d00m00'
    
    restfreq -- Specify rest frequency to use for output visibilities
    default='' Occasionally it is necessary to set this (for
    example some VLA spectral line data).  For example for
    NH_3 (1,1) put restfreq='23.694496GHz'
    
    outframe -- output reference frame (not case-sensitive)
    possible values: LSRK, LSRD, BARY, GALACTO, LGROUP, CMB, GEO, TOPO, or SOURCE
    (SOURCE is meant for solar system work and corresponds to GEO + radial velocity
    correction for ephemeris objects).
    default='' (keep original reference frame) ; example: outframe='BARY'
    
    veltype -- definition of velocity (in mode)
    default = 'radio'
    
    hanning -- if true, Hanning smooth frequency channel data to remove Gibbs ringing
    
    ==================================================================
    
    The intent of cvel is to transform channel labels and the
    visibilities to a spectral reference frame which is appropriate
    for the science analysis, e.g. from TOPO to LSRK to correct for
    Doppler shifts throughout the time of the observation. Naturally,
    this will change the shape of the spectral feature to some extent.
    According to the Nyquist theorem you should oversample a spectrum
    with twice the numbers of channels to retain the shape. Based on
    some tests, however, we recommend to observe with at least
    3-4 times the number of channels for each significant spectral
    feature (like 3-4 times the linewidth). This will minimize
    regridding artifacts in cvel.
    
    If cvel has already established the grid that is desired for the
    imaging, clean should be run with exactly the same frequency/velocity
    parameters as used in cvel in order to avoid additional regridding in
    clean.
    
    Hanning smoothing is optionally offered in cvel, but tests have
    shown that already the regridding process itself, if it involved
    a transformation from TOPO to a non-terrestrial reference frame,
    implies some smoothing (due to channel interpolation) such that
    Hanning smoothing may not be necessary.


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """regrid an MS to a new spectral window / channel structure or frame"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cStr'}, 'passall': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'selectdata': {'type': 'cBool'}, 'antenna': {'type': 'cStr'}, 'timerange': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'mode': {'type': 'cStr'}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'width': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'interpolation': {'type': 'cStr'}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'restfreq': {'type': 'cStr'}, 'outframe': {'type': 'cStr'}, 'veltype': {'type': 'cStr'}, 'hanning': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __outframe_dflt( self, glb ):
        return ''

    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        return ''

    def __veltype_dflt( self, glb ):
        return 'radio'

    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        return 'radio'

    def __hanning_dflt( self, glb ):
        return False

    def __hanning( self, glb ):
        if 'hanning' in glb: return glb['hanning']
        return False

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __restfreq_dflt( self, glb ):
        return ''

    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        return ''

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __mode_dflt( self, glb ):
        return 'channel'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'channel'

    def __passall_dflt( self, glb ):
        return False

    def __passall( self, glb ):
        if 'passall' in glb: return glb['passall']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __interpolation_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return "linear"
        if self.__mode( glb ) == "channel_b": return "linear"
        if self.__mode( glb ) == "velocity": return "linear"
        if self.__mode( glb ) == "frequency": return "linear"
        return None
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "channel_b": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __array_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 0
        if self.__mode( glb ) == "channel_b": return 0
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 1
        if self.__mode( glb ) == "channel_b": return 1
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        dflt = self.__array_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        dflt = self.__interpolation_dflt( glb )
        if dflt is not None: return dflt
        return 'linear'

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __outputvis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('outputvis',pre,self.__to_string_(value),post,description))
    def __passall_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__passall( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'passall': value},{'passall': self.__schema['passall']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('passall',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __selectdata_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-16.16s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('selectdata',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__scan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        if self.__array_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__array( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-16.16s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __nchan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nchan',pre,self.__to_string_(value),post,description))
    def __start_inp(self):
        out = self.__stdout or sys.stdout
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__start( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('start',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__width( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __interpolation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interpolation_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interpolation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interpolation',pre,self.__to_string_(value),post,description))
    def __phasecenter_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('phasecenter',pre,self.__to_string_(value),post,description))
    def __restfreq_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__restfreq( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('restfreq',pre,self.__to_string_(value),post,description))
    def __outframe_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outframe( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('outframe',pre,self.__to_string_(value),post,description))
    def __veltype_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__veltype( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('veltype',pre,self.__to_string_(value),post,description))
    def __hanning_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__hanning( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'hanning': value},{'hanning': self.__schema['hanning']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-16.16s = %s%-23.22s%s # %-.60s\n' % ('hanning',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'passall' in glb: del glb['passall']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'interpolation' in glb: del glb['interpolation']
        if 'nchan' in glb: del glb['nchan']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'array' in glb: del glb['array']
        if 'restfreq' in glb: del glb['restfreq']
        if 'veltype' in glb: del glb['veltype']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'start' in glb: del glb['start']
        if 'hanning' in glb: del glb['hanning']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__passall_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__selectdata_inp( )
        self.__antenna_inp( )
        self.__timerange_inp( )
        self.__scan_inp( )
        self.__array_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__interpolation_inp( )
        self.__phasecenter_inp( )
        self.__restfreq_inp( )
        self.__outframe_inp( )
        self.__veltype_inp( )
        self.__hanning_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("cvel.last"):
                filename = "cvel.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, outputvis=None, passall=None, field=None, spw=None, selectdata=None, antenna=None, timerange=None, scan=None, array=None, mode=None, nchan=None, start=None, width=None, interpolation=None, phasecenter=None, restfreq=None, outframe=None, veltype=None, hanning=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('cvel.pre')
        _postfile = os.path.realpath('cvel.last')
        _return_result_ = None
        _arguments = [vis,outputvis,passall,field,spw,selectdata,antenna,timerange,scan,array,mode,nchan,start,width,interpolation,phasecenter,restfreq,outframe,veltype,hanning]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if passall is not None: local_global['passall'] = passall
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if selectdata is not None: local_global['selectdata'] = selectdata
            if mode is not None: local_global['mode'] = mode
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if restfreq is not None: local_global['restfreq'] = restfreq
            if outframe is not None: local_global['outframe'] = outframe
            if veltype is not None: local_global['veltype'] = veltype
            if hanning is not None: local_global['hanning'] = hanning

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['passall'] = self.__passall( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['restfreq'] = self.__restfreq( local_global )
            _invocation_parameters['outframe'] = self.__outframe( local_global )
            _invocation_parameters['veltype'] = self.__veltype( local_global )
            _invocation_parameters['hanning'] = self.__hanning( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['array'] = self.__array( _invocation_parameters ) if array is None else array
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['interpolation'] = self.__interpolation( _invocation_parameters ) if interpolation is None else interpolation

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['passall'] = self.__passall( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['hanning'] = self.__hanning( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#cvel( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _cvel_t( _invocation_parameters['vis'],_invocation_parameters['outputvis'],_invocation_parameters['passall'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['selectdata'],_invocation_parameters['antenna'],_invocation_parameters['timerange'],_invocation_parameters['scan'],_invocation_parameters['array'],_invocation_parameters['mode'],_invocation_parameters['nchan'],_invocation_parameters['start'],_invocation_parameters['width'],_invocation_parameters['interpolation'],_invocation_parameters['phasecenter'],_invocation_parameters['restfreq'],_invocation_parameters['outframe'],_invocation_parameters['veltype'],_invocation_parameters['hanning'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

cvel = _cvel( )

