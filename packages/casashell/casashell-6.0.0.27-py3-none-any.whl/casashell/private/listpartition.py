##################### generated by xml-casa (v2) from listpartition.xml #############
##################### df5992dc6d4de4290021b028f3b34b13 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import listpartition as _listpartition_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _listpartition:
    """
    listpartition ---- List the summary of a multi-MS data set in the logger or in a file

    
    Lists the following properties of a multi-measurement set:
    sub-MS name, scan list, spw list, list of number of channels per spw,
    number of rows for all scans.
    

    --------- parameter descriptions ---------------------------------------------

    vis        Name of Multi-MS or normal MS.
    createdict Create and return a dictionary with Sub-MS information
    listfile   Name of ASCII file to save output: ''==>to terminal
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    
    A multi-measurement set (MMS) is an MS that has been split into sub-MSs.
    An MMS contains a reference MS in the top directory and the sub-MSs are
    located in a directory called SUBMSS inside the MMS directory.
    Example of a MS that was partitioned in the 'scan' axis using the task partition:
    
    > ls ngc5921.mms
    ANTENNA           FLAG_CMD     POLARIZATION  SPECTRAL_WINDOW  table.dat
    DATA_DESCRIPTION  HISTORY      PROCESSOR     STATE            table.info
    FEED              OBSERVATION  SORTED_TABLE  SUBMSS           WEATHER
    FIELD             POINTING     SOURCE        SYSCAL
    
    > ls ngc5921.mms/SUBMSS/
    ngc5921.0000.ms/  ngc5921.0002.ms/  ngc5921.0004.ms/  ngc5921.0006.ms/
    ngc5921.0001.ms/  ngc5921.0003.ms/  ngc5921.0005.ms/
    
    The task lists the following properties of a multi-MS or MS:
    sub-MS name, scan, spw list, list of number of channels per spw,
    number of rows for each scan and the size in disk. Example of logger output:
    
    Sub-MS          Scan  Spw      Nchan    Nrows   Size
    ngc5921.0000.ms  1    [0]      [63]     4509    11M
    ngc5921.0001.ms  2    [0]      [63]     1890    6.4M
    ngc5921.0002.ms  3    [0]      [63]     6048    13M
    ngc5921.0003.ms  4    [0]      [63]     756     4.9M
    ngc5921.0004.ms  5    [0]      [63]     1134    6.4M
    ngc5921.0005.ms  6    [0]      [63]     6804    15M
    ngc5921.0006.ms  7    [0]      [63]     1512    6.4M
    
    
    ------- Detailed description of keyword arguments -------
    vis -- Name of multi-MS or normal MS.
    default: ''.
    example: vis='pScan.mms'
    
    createdict -- Create and return a dictionary containing scan summaries of each
    sub-MS.
    default: False
    
    If set to True, the returned dictionary will contain information from
    ms.getscansummary() and ms.getspectralwindowinfo(), with the addition of an
    index as the top key and the sub-MS name.
    Example:
    
    {0: {'MS': 'ngc5921.0000.ms',
    'scanId': {1: {'nchans': array([63], dtype=int32),
    'nrows': 4509,
    'spwIds': array([0], dtype=int32)}},
    'size': '11M'},
    1: {'MS': 'ngc5921.0001.ms',
    'scanId': {2: {'nchans': array([63], dtype=int32),
    'nrows': 1890,
    'spwIds': array([0], dtype=int32)}},
    'size': '6.4M'}}
    
    listfile -- Name of ASCII file to save output to. If empty, it will
    list on the logger/terminal.
    default: ''
    example: listfile='pscan.txt'
    
    


    """

    _info_group_ = """information"""
    _info_desc_ = """List the summary of a multi-MS data set in the logger or in a file"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'createdict': {'type': 'cBool'}, 'listfile': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __createdict_dflt( self, glb ):
        return False

    def __createdict( self, glb ):
        if 'createdict' in glb: return glb['createdict']
        return False

    def __listfile_dflt( self, glb ):
        return ''

    def __listfile( self, glb ):
        if 'listfile' in glb: return glb['listfile']
        return ''



    #--------- return inp/go default --------------------------------------------------


    #--------- return subparam values -------------------------------------------------


    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __createdict_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__createdict( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'createdict': value},{'createdict': self.__schema['createdict']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('createdict',pre,self.__to_string_(value),post,description))
    def __listfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__listfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'listfile': value},{'listfile': self.__schema['listfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('listfile',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'vis' in glb: del glb['vis']
        if 'createdict' in glb: del glb['createdict']
        if 'listfile' in glb: del glb['listfile']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__createdict_inp( )
        self.__listfile_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("listpartition.last"):
                filename = "listpartition.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, createdict=None, listfile=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('listpartition.pre')
        _postfile = os.path.realpath('listpartition.last')
        _return_result_ = None
        _arguments = [vis,createdict,listfile]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if createdict is not None: local_global['createdict'] = createdict
            if listfile is not None: local_global['listfile'] = listfile

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['createdict'] = self.__createdict( local_global )
            _invocation_parameters['listfile'] = self.__listfile( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['createdict'] = self.__createdict( self.__globals_( ) )
            _invocation_parameters['listfile'] = self.__listfile( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#listpartition( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _listpartition_t( _invocation_parameters['vis'],_invocation_parameters['createdict'],_invocation_parameters['listfile'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

listpartition = _listpartition( )

