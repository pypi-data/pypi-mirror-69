##################### generated by xml-casa (v2) from specfit.xml ###################
##################### 7926fd42b727961c124474a19553fb96 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import specfit as _specfit_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _specfit:
    """
    specfit ---- Fit 1-dimensional gaussians and/or polynomial models to an image or image region

    --------- parameter descriptions ---------------------------------------------

    imagename       Name of the input image
    box             Rectangular region to select in direction plane. Default is to use the entire direction plane.
    region          Region selection. Default is to use the full image.
    chans           Channels to use. Default is to use all channels.
    stokes          Stokes planes to use. Default is to use all Stokes planes.
    axis            The profile axis. Default: use the spectral axis if one exists, axis 0 otherwise (<0).
    mask            Mask to use. Default is none..
    ngauss          Number of Gaussian elements.  Default: 1.
    poly            Order of polynomial element.  Default: do not fit a polynomial (<0).
    estimates       Name of file containing initial estimates.  Default: No initial estimates ("").
    minpts          Minimum number of unmasked points necessary to attempt fit.
    multifit        If true, fit a profile along the desired axis at each pixel in the specified region. If false, average the non-fit axis pixels and do a single fit to that average profile. Default False.
    model           Name of model image. Default: do not write the model image ("").
    residual        Name of residual image. Default: do not write the residual image ("").
    amp             Name of amplitude solution image. Default: do not write the image ("").
    amperr          Name of amplitude solution error image. Default: do not write the image ("").
    center          Name of center solution image. Default: do not write the image ("").
    centererr       Name of center solution error image. Default: do not write the image ("").
    fwhm            Name of fwhm solution image. Default: do not write the image ("").
    fwhmerr         Name of fwhm solution error image. Default: do not write the image ("").
    integral        Prefix of ame of integral solution image. Name of image will have gaussian component number appended.  Default: do not write the image ("").
    integralerr     Prefix of name of integral error solution image. Name of image will have gaussian component number appended.  Default: do not write the image ("").
    wantreturn      Should a record summarizing the results be returned?
    stretch         Stretch the mask if necessary and possible?
    logresults      Output results to logger?
    pampest         Initial estimate of PCF profile (gaussian or lorentzian) amplitudes.
    pcenterest      Initial estimate PCF profile centers, in pixels.
    pfwhmest        Initial estimate PCF profile FWHMs, in pixels.
    pfix            PCF profile parameters to fix during fit.
    gmncomps        Number of components in each gaussian multiplet to fit
    gmampcon        The amplitude ratio constraints for non-reference components to reference component in gaussian multiplets.
    gmcentercon     The center offset constraints (in pixels) for non-reference components to reference component in gaussian multiplets.
    gmfwhmcon       The FWHM  ratio constraints for non-reference components to reference component in gaussian multiplets.
    gmampest        Initial estimate of individual gaussian amplitudes in gaussian multiplets.
    gmcenterest     Initial estimate of individual gaussian centers in gaussian multiplets, in pixels.
    gmfwhmest       Initial estimate of individual gaussian FWHMss in gaussian multiplets, in pixels.
    gmfix           Parameters of individual gaussians in gaussian multiplets to fix during fit.
    logfile         File in which to log results. Default is not to write a logfile.
    append          Append results to logfile? Logfile must be specified. Default is to append. False means overwrite existing file if it exists.
    pfunc           PCF singlet functions to fit. "gaussian" or "lorentzian" (minimal match supported). Unspecified means all gaussians.
    goodamprange    Acceptable amplitude solution range. [0.0] => all amplitude solutions are acceptable.
    goodcenterrange Acceptable center solution range in pixels relative to region start. [0.0] => all center solutions are acceptable.
    goodfwhmrange   Acceptable FWHM solution range in pixels. [0.0] => all FWHM solutions are acceptable.
    sigma           Standard deviation array or image name.
    outsigma        Name of output image used for standard deviation. Ignored if sigma is empty.
    [1;42mRETURNS[1;m            record

    --------- examples -----------------------------------------------------------

    
    
    This task simultaneously fits one or more gaussian singlets lorentzian singlets, gaussian multiplets, and/or a polynomial to one dimensional profiles.
    
    PARAMETER SUMMARY
    imagename       Name of the input (CASA, FITS, MIRIAD) image
    box             Rectangular region to select in direction plane.
    for details. Default is to use the entire direction plane.
    region          Region selection. Default is to use the
    full image.
    chans           Channels to use. Default is to use
    all channels.
    stokes          Stokes planes to use. Default is
    to use all Stokes planes.
    axis            Axis along which to do the fit(s). <0 means use the spectral axis or the
    zeroth axis if a spectral axis is not present.
    mask            Mask to use. Default is none.
    stretch         Stretch the input mask if necessary and possible? Only used if a mask is specified.
    
    ngauss          Maximum number of gaussians to fit.
    poly            Order of polynomial to fit. <0 means do not fit a polynomial.
    estimates       Name of file containing initial gaussian estimates.
    minpts          Minimum number of points necessary to attempt a fit.
    multifit        Fit models at each pixel in region (true) or average profiles and fit a single model (false).
    model           Name of model image to write.
    residual        Name of residual image to write.
    amp             Name of amplitude solution image. Default: do not write the image ("")
    amperr          Name of amplitude solution error image. Default: do not write the image ("")
    center          Name of center solution image. Default: do not write the image ("")
    centererr       Name of center solution error image. Default: do not write the image ("")
    fwhm            Name of fwhm solution image. Default: do not write the image ("")
    fwhmerr         Name of fwhm solution error image. Default: do not write the image ("")
    integral        Name of integral solution image. Default: do not write the image ("")
    integralerr     Name of integral solution error image. Default: do not write the image ("")
    wantreturn      If true, return a record summarizing the fit results, if false, return false.
    stretch         Stretch the mask if necessary and possible?
    logresults      Output results to logger?
    pampest         Initial estimate of PCF profile (gaussian or lorentzian) amplitudes.
    pcenterest      Initial estimate PCF profile centers, in pixels.
    pfwhmest        Initial estimate PCF profile FWHMs, in pixels.
    pfix            PCF profile parameters to fix during fit.
    pfunc           PCF singlet functions to fit. "gaussian" or "lorentzian" (minimal match supported). Unspecified means all gaussians.
    gmncomps        Number of components in each Gaussian multiplet to fit.
    gmampcon        The amplitude ratio constraints for non-reference components to reference component in gaussian multiplets.
    gmcentercon     The center offset constraints (in pixels) for non-reference components to reference component in gaussian multiplets.
    gmfwhmcon       The FWHM  ratio constraints for non-reference components to reference component in gaussian multiplets.
    gmampest        Initial estimate of individual gaussian amplitudes in gaussian multiplets.
    gmcenterest     Initial estimate of individual gaussian centers in gaussian multiplets, in pixels.
    gmfwhmest       Initial estimate of individual gaussian FWHMss in gaussian multiplets, in pixels.
    gmfix           Parameters of individual gaussians in gaussian multiplets to fix during fit.
    logfile         File in which to log results. Default is not to write a logfile.
    append          Append results to logfile? Logfile must be specified. Default is to append. False means overwrite existing file if it exists.
    goodamprange    Acceptable amplitude solution range. 0 => all amplitude solutions are acceptable. [0.0] => All amplitude solutions are acceptable.
    goodcenterrange Acceptable center solution range in pixels relative to region start. [0.0] => all center solutions are acceptable.
    goodfwhmrange   Acceptable FWHM solution range in pixels. [0.0] => all FWHM solutions are acceptable.
    sigma           Standard deviation array or image name.
    outsigma        Name of output image used for standard deviation. Ignored if sigma is empty.
    
    This task simultaneously performs a non-linear, least squares fit using the Levenberg-Marquardt algorithm of one or more gaussian singlets,
    one or more lorentzian singlets, one or more gaussian multiplets, and/or a polynomial to one dimensional profiles. A description of the
    fitting algorithm may be found in AIPS++ Note 224 (http://www.astron.nl/casacore/trunk/casacore/doc/notes/224.html) and in Numerical Recipes
    by W.H. Press et al., Cambridge University Press. A gaussian/lorentzian singlet is a gaussian/lorentzian whose parameters (amplitude,
    center position, and width) are all independent from any other feature that may be simultaneously fit. A gaussian multiplet is a set of two or
    more gaussian lines in which at least one (and possibly two or three) parameter of each line is dependent on the parameter of another,
    single (reference) profile in the multiplet. For example, one can specify a doublet in which the amplitude of the first line is 0.6 times the
    amplitude of the zeroth line and/or the center of the first line is 20 pixels from the center of the zeroth line, and/or the fwhm of the first
    line is identical (in pixels) to that of the zeroth line. There is no limit to the number of components one can specify in a multiplet
    (except of course that the number of parameters to be fit should be significantly less than the number of data points), but there can be only
    a single reference profile in a multiplet to which to tie constraints of parameters of the other profiles in the set.
    
    AXIS
    The axis parameter indicates on which axis profiles should be fit; a value <0 indicates the spectral axis should be used, or if one does not exist,
    that the zeroth axis should be used.
    
    MINIMUM NUMBER OF PIXELS
    The minpts parameter indicates the minimum number of unmasked pixels that must be present in order for a fit
    to be attempted. When multifit=T, positions with too few good points will be masked in any output images.
    
    ONE FIT OF REGION AVERAGE OR PIXEL BY PIXEL FIT
    The multifit parameter indicates if profiles should be fit at each pixel in the selected region (true), or if the profiles in that region should be
    averaged and the fit done to that average profile (false).
    
    POLYNOMIAL FITTING
    The order of the polynomial to fit is specified only via the poly parameter. If poly<0, no polynomial will be fit. No initial estimates of
    coefficients can be specified; these are determined automatically.
    
    GAUSSIAN SINGLET FITTING
    In the absence of an estimates file and no estimates being specified by the p*est parameters, and gmncomps=0 or is empty, the ngauss parameter
    indicates the maximum number of gaussian singlets that should be fit. The initial estimates of the parameters for these gaussians will be attempted
    automatically in this case. If it deems appropriate, the fitter will fit fewer than this number. In the case where an estimates file is supplied,
    ngauss is ignored (see below). ngauss is also ignored if the p*est parameters are specified or if gmncomps is not an empty array or, if an integer,
    is greater than zero. If estimates is not specified or the p*est parameters are not specified and ngauss=0, gmncomps is empty or 0, and poly<0,
    an error will occur as this indicates there is nothing to fit.
    
    One can specify initial estimates of gaussian singlet parameters via an estimates file or the pampest, pcenterest, pfwhmest, and optionally, the
    pfix parameters. The latter is the recommended way to specify these estimates as support for estimates files may be deprecated in the future. No matter
    which option is used, an amplitude initial estimate must always be nonzero.  A negative fwhm estimate will be silently changed to positve.
    
    SPECIFYING INITIAL ESTIMATES FOR GAUSSIAN AND LORENTZIAN SINGLETS (RECOMMENDED METHOD)
    One may specify initial estimates via the pampest, pcenterest, and pfwhmest parameters. In the case of a single gaussian or lorentzian singlet,
    these parameters can be numbers. pampest must be specified in image brightness units, pcenterest must be given in the number of pixels from the
    zeroth pixel, and pfwhmest must be given in pixels. Optionally pfix can be specified and in the case of a single gaussian or lorentzian singlet
    can be a string. In it is coded which parameters should be held constant during the fix. Any combination of "p" (amplitude), "c" (center), or "f"
    (fwhm) is allowed; eg pfix="pc" means fix both the amplitude and center during the fit. In the case of more than one gaussian and/or lorentzian
    singlets, these parameters must be specified as arrays of numbers. The length of the arrays indicates the number of singlets to fit and must be
    the same for all the p*est parameters.
    
    If no parameters are to be fixed for any of the singlets, pfix can be set to the empty string. However, if at least one parameter of one singlet
    is to be fixed, pfix must be an array of strings and have a length equal to the p*est arrays. Singlets which are not to have any parameters fixed
    should be represented as an empty string in the pfix array. So, for example, if one desires to fit three singlets and fix the fwhm of the middle
    one, one must specify pfix=["", "f", ""], the empty strings indicating no parameters of the zeroth and second singlet should be held constant.
    
    In the case of multifit=True, the initial estimates, whether from the p*est parameters or from a file (see below), will be applied to the location
    of the first fit. This is normally the bottom left corner of the region selected. If masked, not enough good points to perform a fit, or the
    attempted fit fails, the fitting proceeds to the next pixel with the pixel value of the lowest numbered axis changing the fastest. Once a
    successful fit has been performed, subsequent fits will use the results of a fit for a nearest pixel for which a previous fit was successful as the
    initial estimate for the parameters at the current location. The fixed parameter string will be honored for every fit performed when multifit=True.
    
    One specifies what type of PCF profile to fit via the pfunc parameter. A PCF function is one that can be parameterized by a peak, center, and FWHM,
    as both gaussian and lorentzian singlets can. If all singlets to be fit are gaussians, one can set pfunc equal to the empty string and all snglets
    will be assumed to be gaussians. If at least one lorentzian is to be fit, pfunc must be specified as a string (in the case of a single singlet) or
    an array of strings (in the case of multiple singlets). The position of each string corresponds to the positions of the initial estimates in the
    p*est and pfix arrays. Minimal match ("g", "G", "l", or "L") is supported. So, if one wanted to simultaneously fit two gaussian and two lorentzian
    singlets, the zeroth and last of which were lorentzians, one would specify pfunc=["L", "G", "G", "L"].
    
    ESTIMATES FILE FOR GAUSSIAN SINGLETS (NONRECOMMENDED METHOD)
    Initial estimates for gaussian singlets can be specified in an estimates file. Estimates files may be deprecated in the future in favor of the
    p*est parameters, so it is recommended users use those parameters instead. If an estimates file is desired to be used, the p*est parameters
    must be 0 or empty and mgncomps must be 0 or empty. Only gaussian singlets can be specified in an estimates file. If one desires to fit one or
    more gaussian multiplets and/or one or more lorentzian singlets simultaneously, the p*est parameters must be used to specify the initial parameters
    of all gaussian singlets to fit; one cannot use an estimates file in this case. If an estimates file is specified, a polynomial
    can be fit simultaneously by specifying the poly parameter. The estimates file must contain initial estimates of parameters
    for all gaussian singlets to be fit. The number of gaussian singlets to fit is gotten from the number of estimates in the file. The file can contain
    comments which are indicated by a "#" at the beginning of a line. All non-comment lines will be interpreted as initial estimates. The
    format of such a line is
    
    [peak intensity], [center], [fwhm], [optional fixed parameter string]
    
    The first three values are required and must be numerical values. The peak intensity must be expressed in image brightness units, while the
    center must be specified in pixels offset from the zeroth pixel, and fwhm must be specified in pixels. The fourth value is optional and if present,
    represents the parameter(s) that should be held constant during the fit. Any combination of the characters 'p' (peak), 'c' (center), and 'f' (fwhm) are
    permitted, eg "fc" means hold the fwhm and the center constant during the fit. Fixed parameters will have no error associated with them. Here is an
    example file:
    
    # estimates file indicating that two gaussians should be fit
    # first guassian estimate, peak=40, center at pixel number 10.5, fwhm = 5.8 pixels, all parameters allowed to vary during
    # fit
    40, 10.5, 5.8
    # second gaussian, peak = 4, center at pixel number 90.2, fwhm = 7.2 pixels, hold fwhm constant
    4, 90.2, 7.2, f
    # end file
    
    GAUSSIAN MULTIPLET FITTING
    Any number of gaussian multiplets, each containing any number of two or more components, can be simultaneously fit, optionally with a
    polynomial and/or any number of gaussian and/or lorentzian singlets, the only caveat being that the number of parameters to be fit should be
    significantly less than the number of data points. The gmncomps parameter indicates the number of multiplets to fit and the number of
    components in each multiplet. In the case of a single multiplet, an integer (>1) can be specified. For example, mgncomps=4 means fit a
    single quadruplet of gaussians. In the case of 2 or more multiplets, and array of integers (all >1) must be specified. For example,
    gmncomps=[2, 4, 3] means 3 seperate multiples are to be fit, the zeroth being a doublet, the first being a quadruplet, and the second
    being a triplet.
    
    Initial estimates of all gaussians in all multiplets are specified via the gm*est parameters which must be arrays of numbers. The order
    starts with the zeroth component of the zeroth multiplet to the last component of the zeroth multiplet, then the zeroth component of
    the first multiplet to the last compoenent of the first multiplet, etc to the zeroth component of the last multiplet to the last
    element of the last multiplet. The zeroth element of a multiplet is defined as the reference component of that multiplet and has the special
    significance that it is the profile to which all constraints of all other profiles in that multiplet are referenced (see below). So,
    in our example of gmncomps=[2, 4, 3], gmampest, gmcenterest, and gmfwhmest must each be nine (the total number of individual gaussian
    profiles summed over all multiplets) element arrays. The zeroth, second, and sixth elements represent parameters of the reference profiles
    in the zeroth, first, and second multiplet, respectively.
    
    The fixed relationships between the non-reference profile(s) and the reference profile of a multiplet are specified via the gmampcon,
    gmcentercon, and gmfwhmcon parameters. At least one, and any combination, of constraints can be specified for any non-reference
    component of a multiplet. The amplitude ratio of a non-reference line to that of the reference line is set in gmampcon. The ratio of
    the fwhm of a non-reference line to that of the reference line is set in gmfwhmcon. The offset in pixels of the center position of
    a non-reference line to that of the reference line is set in gmcentercon. In the case where a parameter is not constrained for any
    non-reference line of any multiplet, the value of the associated parameter must be 0. In the case of
    a single doublet, a constraint may be specified as a number or an array of a single number. For example, mgncomps=2 and gmampcon=0.65
    and gmcentercon=[32.4] means there is a single doublet to fit where the amplitude ratio of the first to the zeroth line is constained
    to be 0.65 and the center of the first line is constrained to be offset by 32.4 pixels from the center of the zeroth line. In cases
    of a total of three or more gaussians, the constraints parameters must be specified as arrays with lengths equal to the total number
    of gaussians summed over all multiplets minus the number of reference lines (one per multiplet, or just number of multiplets, since
    reference lines cannot be constrained by themselves). In the cases where an array must be specified but a component in that array
    does not have that constraint, 0 should be specified. Here's an example
    
    gmncomps=[2, 4, 3]
    gmampcon=  [ 0  ,  0.2,  0  , 0.1,   4.5,   0  ]
    gcentercon=[24.2, 45.6, 92.7, 0  , -22.8, -33.5]
    gfwhmcon=""
    
    In this case we have our previous example of one doublet, one quadruplet, and one triplet. The first component of the doublet has the constraint
    that its center is offset by 24.2 pixels from the zeroth (reference) component. The first component of the quadruplet is constrained to have
    an amplitude of 0.2 times that of the quadruplet's zeroth component and its center is constrained to be offset by 45.6 pixels from the
    reference component. The second component of the quadruplet is constained to have its center offset by 92.7 pixels from the associated
    reference component and the third component is constrained to have an amplitude of 0.1 times that of the associated reference component.
    The first component of the triplet is constrained to have an amplitude of 4.5 times that of its associated reference component and its center
    is constrained to be offset by -22.8 pixels from the reference component's center. The second component of the triplet is constrained to have
    its center offset by -33.5 pixels from the center of the reference component. No lines have FWHM constraints, so the empty string can be given
    for that parameter. Note that using 0 to indicate no constraint for line center means that one cannot specify a line centered at the same
    position as the reference component but having a different FWHM from the reference component. If you must specify this very unusual case,
    try using a very small positive (or even negative) value for the center constraint.
    
    Note that when a parameter for a line is constrained, the corresponding value for that component in the corresponding gm*est array is
    ignored and the value of the constrained parameter is automatically used instead. So let's say, for our example above, we had specified
    the following estimates:
    
    gmampest =     [ 1,   .2,  2,   .1,    .1,   .5,  3,    2, 5]
    gmcenterest =  [20, 10  , 30, 45.2, 609  , -233, 30, -859, 1]
    
    Before any fitting is done, the constraints would be taken into account and these arrays would be implicitly rewritten as:
    
    gmampest =     [ 1,   .2,  2,   .4,    .1,   .2,  3, 13.5,  5  ]
    gmcenterest =  [20, 44.2, 30, 75.6, 127.7, -233, 30,  7.2, -3.5]
    
    The value of gmfwhmest would be unchanged since there are no FWHM constraints in this example.
    
    In addition to be constrained by values of the reference component, parameters of individual components can be fixed. Fixed parameters
    are specified via the gmfix parameter. If no parameters are to be fixed, gmfix can be specified as the empty string or a zero element
    array. In the case where any parameter is to be fixed, gmfix must be specified as an array of strings with length equal to the total number of
    components summed over all multiplets. These strings encode which parameters to be fixed for the corresponding components. If
    a component is to have no parameters fixed, an empty string is used. In other cases one or more of any combination of parameters can
    be fixed using "p", "c", and/or "f" described above for fixing singlet parameters. There are a couople of special cases
    to be aware of. In the case where a non-reference component parameter is constrained and the corresponding reference component parameter is
    set as fixed, that parameter in the non-reference parameter will automatically be fixed even if it was specified not to be fixed in
    the gmfix array. This is the only way the constraint can be honored afterall. In the converse case of when a constrained parameter of a
    non-reference component is specified as fixed, but the corresponding parameter in the reference component is not specified to be fixed,
    an error will occur. Fixing an unconstrained parameter in a non-reference component is always legal as is fixing any combination of
    parameters in a reference component (with the above caveat that corresponding constrained parameters in non-reference components will
    be silently held fixed as well).
    
    The same rules that apply to singlets when multifit=True apply to multiplets.
    
    LIMITING RANGES FOR SOLUTION PARAMETERS
    In cases of low (or no) signal to noise spectra, it is still possible for the fit to converge, but often to a
    nonsensical solution. The astronomer can use her knowledge of the source to filter out obviously bogus solutions.
    Any solution which contains a NaN value as a value or error in any one of its parameters is automatically marked as
    invalid.
    
    One can also limit the ranges of solution parameters to known "good" values via the goodamprange, goodcenterrange, and goodfwhmrange
    parameters. Any combination can be specified and the limit constraints will be ANDed together. The ranges apply to all PCF components
    that might be fit; choosing ranges on a component by component basis is not supported. If specified,
    an array of exactly two numerical values must be given to indicate the range of acceptable solution values for
    that parameter.  goodamprange is expressed in terms of image brightness units. goodcenterrange is expressed in terms of pixels
    from the zeroth pixel in the specified region. goodfwhmrange is expressed in terms of pixels (only non-negative values should be
    given for FWHM range endpoints). In the case of a multiple-PCF fit, if any of the corresponding solutions are outside the specified
    ranges, the entire solution is considered to be invalid.
    
    In addition, solutions for which the absolute value of the ratio of the amplitude error to the amplitude exceeds 100 or the
    ratio of the FWHM error to the FWHM exceeds 100 are automatically marked as invalid.
    
    INCLUDING STANDARD DEVIATIONS OF PIXEL VALUES
    If the standard deviations of the pixel values in the input image are known and they vary in the image (eg they are higher for pixels
    near the edge of the band), they can be included in the sigma parameter. This parameter takes either an array or an image name. The
    array or image must have one of three shapes: 1. the shape of the input image, 2. the same dimensions as the input image with the lengths
    of all axes being one except for the fit axis which must have length corresponding to its length in the input image, or 3. be one
    dimensional with lenght equal the the length of the fit axis in the input image. In cases 2 and 3, the array or pixels in sigma will
    be replicated such that the image that is ultimately used is the same shape as the input image. The values of sigma must be non-negative.
    It is only the relative values that are important. A value of 0 means that pixel should not be used in the fit. Other than that, if pixel
    A has a higher standard deviation than pixel B, then pixel A is noisier than pixel B and will receive a lower weight when the fit is done.
    The weight of a pixel is the usual
    
    weight = 1/(sigma*sigma)
    
    In the case of multifit=F, the sigma values at each pixel along the fit axis in the hyperplane perpendicular to the fit axis which includes
    that pixel are averaged and the resultant averaged standard deviation spectrum is the one used in the fit. Internally, sigma values are normalized
    such that the maximum value is 1. This mitigates a known overflow issue.
    
    One can write the normalized standard deviation image used in the fit but specifying its name in outsigma. This image can then be
    used as sigma for subsequent runs.
    
    RETURNED DICTIONARY STRUCTURE
    The dictionary returned (if wantreturn=True) has a (necessarily) complex structure. First, there are keys "xUnit" and "yUnit" whose values are
    the abscissa unit and the ordinate unit described by simple strings. Next there are arrays giving a broad overview of the
    fit quality. These arrays have the shape of the specified region collapsed along the fit axis with the axis corresponding to the fit
    axis having length of 1:
    
    attempted: a boolean array indicating which fits were attempted (eg if too few unmasked points, a fit will not be attempted).
    converged: a boolean array indicating which fits converged. False if the fit was not attempted.
    valid:     a boolean array indicating which solutions fall within the specified valid ranges of parameter space  (see
    section LIMITING RANGES FOR SOLUTION PARAMETERS for details).
    niter:     an int array indicating the number of iterations for each profile, <0 if the fit did not converge
    ncomps:    the number of components (gaussian singlets + lorentzian singlets + gaussian multiplets + polynomial) fit for the profile,
    <0 if the fit did not converge
    direction: a string array containing the world direction coordinate for each profile
    
    There is a "type" array having number of dimensions equal to the number of dimensions in the above arrays plus one. The shape of
    the first n-1 dimensions is the same as the shape of the above arrays. The length of the last dimension is equal to the number of
    components fit. The values of this array are strings describing the components that were fit at each possition ("POLYNOMIAL",
    "GAUSSIAN" in the case of gaussian singlets, "LORENTZIAN" in the case of lorentzian singlets, and ""GAUSSIAN MULTPLET").
    
    If any gaussian singlets were fit, there will be a subdictionary accessible via the "gs" key which will have subkeys "amp", "ampErr", "center",
    "centerErr", "fwhm", "fwhmErr, "integral", and "integralErr". Each of these arrays will have one more dimension than the overview arrays described
    above. The shape of the first n-1 dimensions will be the same as the shape of the arrays described above, while the final dimension will
    have length equal to the maximum number of gaussian singlets that were fit. Along this axis will be the
    corresponding fit result or associated error (depending on the array's associated key) of the fit for that singlet component number. In cases where
    the fit did not converge, or that particular component was excluded from the fit, a value of NAN will be present.
    
    If any lorentzian singlets were fit, their solutions will be accessible via the "ls" key. These arrays follow the same rules
    as the "gs" arrays described above.
    
    If any gaussian multiplets were fit, there will be subdictionaries accessible by keys "gm0", "gm1", ..., "gm{n-1}" where n is the number of gaussian
    muliplets that were fit. Each of these dictionaries will have the same arrays described above for gaussian singlets. The last dimension
    will have length equal to the number of components in that particular multiplet. Each pixel along the last axis will be the parameter solution
    value or error for that component number in the multiplet, eg the zeroth pixel along that axis contains
    the parameter solution or error for the reference component of the multiplet.
    
    The polynomial coefficient solutions and errors are not returned, although they are logged.
    
    OUTPUT IMAGES
    In addition to the returned dictionary, optionally one or more of any combination of output images can be written.
    The model and residual parameters indicate the names of the model and residual images to be written; blank values inidcate that these images
    should not be written.
    
    One can also write none, any or all of the solution and error images for Gaussian singlet, Lorentzian singlet,  and Gaussian multiplet fits
    via the parameters amp, amperr, center, centererr, fwhm, fwhmerr, integral, and integralerr when doing multi-pixel fits. These images simply
    contain the arrays described for the associated parameter solutions or errors described in previous sections. In the case of Lorentzian
    singlets, "_ls" is appended to the image names, in the case of Gaussian multiplets, "_gm" is appended. Pixels for which fits were not attempted or did not converge will be masked as bad. The last axis of these images
    is a linear axis and repesents component number (and is named accordingly). In the case where multiple Gaussian singlets and/or
    Lorentzians are fitted, the image names are further appended with an underscore and the relevant component number ("_0", "_1", etc).
    In the case of Gaussian multiplets, the image names are appended with an underscore, followed by the number of the relevant
    multiplet group, followed by an underscore, followed by the number of the component in that group (eg, "image_gm_3_4" represents
    component number 4 of multiplet group number 3). Pixels for which fits were not attempted, did not converge, or converged but
    have values of NaN (not a number) or INF (infinity) will be masked as bad.
    
    Writing analogous images for polynomial coefficients is not supported.
    
    EXAMPLE
    res = specif(imagename="myspectrum.im", ngauss=2, box="3,3,4,5", poly=2, multifit=true, wantreturn=True)


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Fit 1-dimensional gaussians and/or polynomial models to an image or image region"""

    __schema = {'imagename': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'box': {'type': 'cStr'}, 'region': {'anyof': [{'type': 'cPath', 'coerce': _coerce.expand_path}, {'type': 'cStr'}, {'type': 'cDict'}]}, 'chans': {'type': 'cStr'}, 'stokes': {'type': 'cStr'}, 'axis': {'type': 'cInt'}, 'mask': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'ngauss': {'type': 'cInt'}, 'poly': {'type': 'cInt'}, 'estimates': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'minpts': {'type': 'cInt'}, 'multifit': {'type': 'cBool'}, 'model': {'type': 'cStr'}, 'residual': {'type': 'cStr'}, 'amp': {'type': 'cStr'}, 'amperr': {'type': 'cStr'}, 'center': {'type': 'cStr'}, 'centererr': {'type': 'cStr'}, 'fwhm': {'type': 'cStr'}, 'fwhmerr': {'type': 'cStr'}, 'integral': {'type': 'cStr'}, 'integralerr': {'type': 'cStr'}, 'wantreturn': {'type': 'cBool'}, 'stretch': {'type': 'cBool'}, 'logresults': {'type': 'cBool'}, 'pampest': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'pcenterest': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'pfwhmest': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'pfix': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'gmncomps': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'gmampcon': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'gmcentercon': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'gmfwhmcon': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'gmampest': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'gmcenterest': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'gmfwhmest': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'gmfix': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'logfile': {'type': 'cStr'}, 'append': {'type': 'cBool'}, 'pfunc': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'goodamprange': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'goodcenterrange': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'goodfwhmrange': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'sigma': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cStr'}, {'type': 'cIntArray', 'coerce': [_coerce.to_intarray]}, {'type': 'cFloatArray', 'coerce': [_coerce.to_floatarray]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'outsigma': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __gmncomps_dflt( self, glb ):
        return int(0)

    def __gmncomps( self, glb ):
        if 'gmncomps' in glb: return glb['gmncomps']
        return int(0)

    def __wantreturn_dflt( self, glb ):
        return True

    def __wantreturn( self, glb ):
        if 'wantreturn' in glb: return glb['wantreturn']
        return True

    def __estimates_dflt( self, glb ):
        return ''

    def __estimates( self, glb ):
        if 'estimates' in glb: return glb['estimates']
        return ''

    def __goodfwhmrange_dflt( self, glb ):
        return [ float(0.0) ]

    def __goodfwhmrange( self, glb ):
        if 'goodfwhmrange' in glb: return glb['goodfwhmrange']
        return [ float(0.0) ]

    def __goodcenterrange_dflt( self, glb ):
        return [ float(0.0) ]

    def __goodcenterrange( self, glb ):
        if 'goodcenterrange' in glb: return glb['goodcenterrange']
        return [ float(0.0) ]

    def __sigma_dflt( self, glb ):
        return ''

    def __sigma( self, glb ):
        if 'sigma' in glb: return glb['sigma']
        return ''

    def __logresults_dflt( self, glb ):
        return True

    def __logresults( self, glb ):
        if 'logresults' in glb: return glb['logresults']
        return True

    def __goodamprange_dflt( self, glb ):
        return [ float(0.0) ]

    def __goodamprange( self, glb ):
        if 'goodamprange' in glb: return glb['goodamprange']
        return [ float(0.0) ]

    def __multifit_dflt( self, glb ):
        return False

    def __multifit( self, glb ):
        if 'multifit' in glb: return glb['multifit']
        return False

    def __minpts_dflt( self, glb ):
        return int(1)

    def __minpts( self, glb ):
        if 'minpts' in glb: return glb['minpts']
        return int(1)

    def __model_dflt( self, glb ):
        return ''

    def __model( self, glb ):
        if 'model' in glb: return glb['model']
        return ''

    def __axis_dflt( self, glb ):
        return int(-1)

    def __axis( self, glb ):
        if 'axis' in glb: return glb['axis']
        return int(-1)

    def __logfile_dflt( self, glb ):
        return ''

    def __logfile( self, glb ):
        if 'logfile' in glb: return glb['logfile']
        return ''

    def __mask_dflt( self, glb ):
        return ''

    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        return ''

    def __residual_dflt( self, glb ):
        return ''

    def __residual( self, glb ):
        if 'residual' in glb: return glb['residual']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __region_dflt( self, glb ):
        return ''

    def __region( self, glb ):
        if 'region' in glb: return glb['region']
        return ''

    def __poly_dflt( self, glb ):
        return int(-1)

    def __poly( self, glb ):
        if 'poly' in glb: return glb['poly']
        return int(-1)

    def __chans_dflt( self, glb ):
        return ''

    def __chans( self, glb ):
        if 'chans' in glb: return glb['chans']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __box_dflt( self, glb ):
        return ''

    def __box( self, glb ):
        if 'box' in glb: return glb['box']
        return ''

    #--------- return non subparam/when values ---------------------------------------------
    def __gmfwhmcon( self, glb ):
        if 'gmfwhmcon' in glb: return glb['gmfwhmcon']
        return [  ]
    def __gmampest( self, glb ):
        if 'gmampest' in glb: return glb['gmampest']
        return [ float(0.0) ]
    def __gmcentercon( self, glb ):
        if 'gmcentercon' in glb: return glb['gmcentercon']
        return [  ]
    def __gmampcon( self, glb ):
        if 'gmampcon' in glb: return glb['gmampcon']
        return [  ]
    def __gmfwhmest( self, glb ):
        if 'gmfwhmest' in glb: return glb['gmfwhmest']
        return [ float(0.0) ]
    def __gmcenterest( self, glb ):
        if 'gmcenterest' in glb: return glb['gmcenterest']
        return [ float(0.0) ]
    def __gmfix( self, glb ):
        if 'gmfix' in glb: return glb['gmfix']
        return ''

    #--------- return inp/go default --------------------------------------------------
    def __center_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __pampest_dflt( self, glb ):
        if self.__estimates( glb ) == "": return UNKNOWN
        return None
    def __ngauss_dflt( self, glb ):
        if self.__estimates( glb ) == "": return int(1)
        return None
    def __fwhm_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __stretch_dflt( self, glb ):
        if self.__mask( glb ) != "": return bool(False)
        return None
    def __pfwhmest_dflt( self, glb ):
        if self.__estimates( glb ) == "": return UNKNOWN
        return None
    def __amperr_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __gmampest_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return []
        return None
    def __amp_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __integralerr_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __gmampcon_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return UNKNOWN
        return None
    def __fwhmerr_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __gmcenterest_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return []
        return None
    def __integral_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __gmfix_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return UNKNOWN
        return None
    def __pcenterest_dflt( self, glb ):
        if self.__estimates( glb ) == "": return UNKNOWN
        return None
    def __pfunc_dflt( self, glb ):
        if self.__estimates( glb ) == "": return ""
        return None
    def __pfix_dflt( self, glb ):
        if self.__estimates( glb ) == "": return UNKNOWN
        return None
    def __outsigma_dflt( self, glb ):
        if self.__sigma( glb ) != "": return ""
        return None
    def __centererr_dflt( self, glb ):
        if self.__multifit( glb ) == bool(True): return ""
        return None
    def __gmfwhmcon_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return UNKNOWN
        return None
    def __gmfwhmest_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return []
        return None
    def __gmcentercon_dflt( self, glb ):
        if self.__gmncomps( glb ) != UNKNOWN: return UNKNOWN
        return None
    def __append_dflt( self, glb ):
        if self.__logfile( glb ) != "": return bool(True)
        return None

    #--------- return subparam values -------------------------------------------------
    def __ngauss( self, glb ):
        if 'ngauss' in glb: return glb['ngauss']
        dflt = self.__ngauss_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __amp( self, glb ):
        if 'amp' in glb: return glb['amp']
        dflt = self.__amp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __amperr( self, glb ):
        if 'amperr' in glb: return glb['amperr']
        dflt = self.__amperr_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __center( self, glb ):
        if 'center' in glb: return glb['center']
        dflt = self.__center_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __centererr( self, glb ):
        if 'centererr' in glb: return glb['centererr']
        dflt = self.__centererr_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __fwhm( self, glb ):
        if 'fwhm' in glb: return glb['fwhm']
        dflt = self.__fwhm_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __fwhmerr( self, glb ):
        if 'fwhmerr' in glb: return glb['fwhmerr']
        dflt = self.__fwhmerr_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __integral( self, glb ):
        if 'integral' in glb: return glb['integral']
        dflt = self.__integral_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __integralerr( self, glb ):
        if 'integralerr' in glb: return glb['integralerr']
        dflt = self.__integralerr_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __stretch( self, glb ):
        if 'stretch' in glb: return glb['stretch']
        dflt = self.__stretch_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __pampest( self, glb ):
        if 'pampest' in glb: return glb['pampest']
        dflt = self.__pampest_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __pcenterest( self, glb ):
        if 'pcenterest' in glb: return glb['pcenterest']
        dflt = self.__pcenterest_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __pfwhmest( self, glb ):
        if 'pfwhmest' in glb: return glb['pfwhmest']
        dflt = self.__pfwhmest_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __pfix( self, glb ):
        if 'pfix' in glb: return glb['pfix']
        dflt = self.__pfix_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        dflt = self.__append_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __pfunc( self, glb ):
        if 'pfunc' in glb: return glb['pfunc']
        dflt = self.__pfunc_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __outsigma( self, glb ):
        if 'outsigma' in glb: return glb['outsigma']
        dflt = self.__outsigma_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __box_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__box( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'box': value},{'box': self.__schema['box']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('box',pre,self.__to_string_(value),post,description))
    def __region_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__region( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'region': value},{'region': self.__schema['region']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('region',pre,self.__to_string_(value),post,description))
    def __chans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chans': value},{'chans': self.__schema['chans']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('chans',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __axis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__axis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'axis': value},{'axis': self.__schema['axis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('axis',pre,self.__to_string_(value),post,description))
    def __mask_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mask( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mask',pre,self.__to_string_(value),post,description))
    def __ngauss_inp(self):
        out = self.__stdout or sys.stdout
        if self.__ngauss_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__ngauss( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'ngauss': value},{'ngauss': self.__schema['ngauss']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('ngauss',pre,self.__to_string_(value),post,description))
    def __poly_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__poly( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'poly': value},{'poly': self.__schema['poly']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('poly',pre,self.__to_string_(value),post,description))
    def __estimates_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__estimates( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'estimates': value},{'estimates': self.__schema['estimates']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('estimates',pre,self.__to_string_(value),post,description))
    def __minpts_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__minpts( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'minpts': value},{'minpts': self.__schema['minpts']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('minpts',pre,self.__to_string_(value),post,description))
    def __multifit_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__multifit( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'multifit': value},{'multifit': self.__schema['multifit']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('multifit',pre,self.__to_string_(value),post,description))
    def __model_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__model( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'model': value},{'model': self.__schema['model']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('model',pre,self.__to_string_(value),post,description))
    def __residual_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__residual( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'residual': value},{'residual': self.__schema['residual']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('residual',pre,self.__to_string_(value),post,description))
    def __amp_inp(self):
        out = self.__stdout or sys.stdout
        if self.__amp_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__amp( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'amp': value},{'amp': self.__schema['amp']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('amp',pre,self.__to_string_(value),post,description))
    def __amperr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__amperr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__amperr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'amperr': value},{'amperr': self.__schema['amperr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('amperr',pre,self.__to_string_(value),post,description))
    def __center_inp(self):
        out = self.__stdout or sys.stdout
        if self.__center_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__center( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'center': value},{'center': self.__schema['center']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('center',pre,self.__to_string_(value),post,description))
    def __centererr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__centererr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__centererr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'centererr': value},{'centererr': self.__schema['centererr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('centererr',pre,self.__to_string_(value),post,description))
    def __fwhm_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fwhm_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fwhm( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fwhm': value},{'fwhm': self.__schema['fwhm']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fwhm',pre,self.__to_string_(value),post,description))
    def __fwhmerr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fwhmerr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fwhmerr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fwhmerr': value},{'fwhmerr': self.__schema['fwhmerr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fwhmerr',pre,self.__to_string_(value),post,description))
    def __integral_inp(self):
        out = self.__stdout or sys.stdout
        if self.__integral_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__integral( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'integral': value},{'integral': self.__schema['integral']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('integral',pre,self.__to_string_(value),post,description))
    def __integralerr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__integralerr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__integralerr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'integralerr': value},{'integralerr': self.__schema['integralerr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('integralerr',pre,self.__to_string_(value),post,description))
    def __wantreturn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__wantreturn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'wantreturn': value},{'wantreturn': self.__schema['wantreturn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('wantreturn',pre,self.__to_string_(value),post,description))
    def __stretch_inp(self):
        out = self.__stdout or sys.stdout
        if self.__stretch_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__stretch( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'stretch': value},{'stretch': self.__schema['stretch']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('stretch',pre,self.__to_string_(value),post,description))
    def __logresults_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__logresults( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'logresults': value},{'logresults': self.__schema['logresults']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('logresults',pre,self.__to_string_(value),post,description))
    def __pampest_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pampest_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pampest( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pampest': value},{'pampest': self.__schema['pampest']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pampest',pre,self.__to_string_(value),post,description))
    def __pcenterest_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pcenterest_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pcenterest( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pcenterest': value},{'pcenterest': self.__schema['pcenterest']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pcenterest',pre,self.__to_string_(value),post,description))
    def __pfwhmest_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pfwhmest_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pfwhmest( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pfwhmest': value},{'pfwhmest': self.__schema['pfwhmest']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pfwhmest',pre,self.__to_string_(value),post,description))
    def __pfix_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pfix_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pfix( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pfix': value},{'pfix': self.__schema['pfix']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pfix',pre,self.__to_string_(value),post,description))
    def __gmncomps_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmncomps( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmncomps': value},{'gmncomps': self.__schema['gmncomps']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gmncomps',pre,self.__to_string_(value),post,description))
    def __gmampcon_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmampcon( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmampcon': value},{'gmampcon': self.__schema['gmampcon']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmampcon',pre,self.__to_string_(value),post,description))
    def __gmcentercon_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmcentercon( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmcentercon': value},{'gmcentercon': self.__schema['gmcentercon']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmcentercon',pre,self.__to_string_(value),post,description))
    def __gmfwhmcon_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmfwhmcon( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmfwhmcon': value},{'gmfwhmcon': self.__schema['gmfwhmcon']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmfwhmcon',pre,self.__to_string_(value),post,description))
    def __gmampest_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmampest( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmampest': value},{'gmampest': self.__schema['gmampest']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmampest',pre,self.__to_string_(value),post,description))
    def __gmcenterest_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmcenterest( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmcenterest': value},{'gmcenterest': self.__schema['gmcenterest']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmcenterest',pre,self.__to_string_(value),post,description))
    def __gmfwhmest_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmfwhmest( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmfwhmest': value},{'gmfwhmest': self.__schema['gmfwhmest']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmfwhmest',pre,self.__to_string_(value),post,description))
    def __gmfix_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__gmfix( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gmfix': value},{'gmfix': self.__schema['gmfix']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('gmfix',pre,self.__to_string_(value),post,description))
    def __logfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__logfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'logfile': value},{'logfile': self.__schema['logfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('logfile',pre,self.__to_string_(value),post,description))
    def __append_inp(self):
        out = self.__stdout or sys.stdout
        if self.__append_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__append( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('append',pre,self.__to_string_(value),post,description))
    def __pfunc_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pfunc_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pfunc( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pfunc': value},{'pfunc': self.__schema['pfunc']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pfunc',pre,self.__to_string_(value),post,description))
    def __goodamprange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__goodamprange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'goodamprange': value},{'goodamprange': self.__schema['goodamprange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('goodamprange',pre,self.__to_string_(value),post,description))
    def __goodcenterrange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__goodcenterrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'goodcenterrange': value},{'goodcenterrange': self.__schema['goodcenterrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('goodcenterrange',pre,self.__to_string_(value),post,description))
    def __goodfwhmrange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__goodfwhmrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'goodfwhmrange': value},{'goodfwhmrange': self.__schema['goodfwhmrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-15.15s = %s%-23.22s%s # %-.60s\n' % ('goodfwhmrange',pre,self.__to_string_(value),post,description))
    def __sigma_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__sigma( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'sigma': value},{'sigma': self.__schema['sigma']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('sigma',pre,self.__to_string_(value),post,description))
    def __outsigma_inp(self):
        out = self.__stdout or sys.stdout
        if self.__outsigma_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__outsigma( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'outsigma': value},{'outsigma': self.__schema['outsigma']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outsigma',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'poly' in glb: del glb['poly']
        if 'stokes' in glb: del glb['stokes']
        if 'residual' in glb: del glb['residual']
        if 'mask' in glb: del glb['mask']
        if 'model' in glb: del glb['model']
        if 'center' in glb: del glb['center']
        if 'pampest' in glb: del glb['pampest']
        if 'gmncomps' in glb: del glb['gmncomps']
        if 'ngauss' in glb: del glb['ngauss']
        if 'wantreturn' in glb: del glb['wantreturn']
        if 'estimates' in glb: del glb['estimates']
        if 'fwhm' in glb: del glb['fwhm']
        if 'logresults' in glb: del glb['logresults']
        if 'stretch' in glb: del glb['stretch']
        if 'pfwhmest' in glb: del glb['pfwhmest']
        if 'imagename' in glb: del glb['imagename']
        if 'amperr' in glb: del glb['amperr']
        if 'gmampest' in glb: del glb['gmampest']
        if 'amp' in glb: del glb['amp']
        if 'sigma' in glb: del glb['sigma']
        if 'integralerr' in glb: del glb['integralerr']
        if 'gmampcon' in glb: del glb['gmampcon']
        if 'logfile' in glb: del glb['logfile']
        if 'fwhmerr' in glb: del glb['fwhmerr']
        if 'gmcenterest' in glb: del glb['gmcenterest']
        if 'goodamprange' in glb: del glb['goodamprange']
        if 'integral' in glb: del glb['integral']
        if 'gmfix' in glb: del glb['gmfix']
        if 'pcenterest' in glb: del glb['pcenterest']
        if 'multifit' in glb: del glb['multifit']
        if 'pfunc' in glb: del glb['pfunc']
        if 'chans' in glb: del glb['chans']
        if 'region' in glb: del glb['region']
        if 'pfix' in glb: del glb['pfix']
        if 'outsigma' in glb: del glb['outsigma']
        if 'box' in glb: del glb['box']
        if 'minpts' in glb: del glb['minpts']
        if 'axis' in glb: del glb['axis']
        if 'centererr' in glb: del glb['centererr']
        if 'goodfwhmrange' in glb: del glb['goodfwhmrange']
        if 'goodcenterrange' in glb: del glb['goodcenterrange']
        if 'gmfwhmcon' in glb: del glb['gmfwhmcon']
        if 'gmfwhmest' in glb: del glb['gmfwhmest']
        if 'gmcentercon' in glb: del glb['gmcentercon']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__box_inp( )
        self.__region_inp( )
        self.__chans_inp( )
        self.__stokes_inp( )
        self.__axis_inp( )
        self.__mask_inp( )
        self.__ngauss_inp( )
        self.__poly_inp( )
        self.__estimates_inp( )
        self.__minpts_inp( )
        self.__multifit_inp( )
        self.__model_inp( )
        self.__residual_inp( )
        self.__amp_inp( )
        self.__amperr_inp( )
        self.__center_inp( )
        self.__centererr_inp( )
        self.__fwhm_inp( )
        self.__fwhmerr_inp( )
        self.__integral_inp( )
        self.__integralerr_inp( )
        self.__wantreturn_inp( )
        self.__stretch_inp( )
        self.__logresults_inp( )
        self.__pampest_inp( )
        self.__pcenterest_inp( )
        self.__pfwhmest_inp( )
        self.__pfix_inp( )
        self.__gmncomps_inp( )
        self.__gmampcon_inp( )
        self.__gmcentercon_inp( )
        self.__gmfwhmcon_inp( )
        self.__gmampest_inp( )
        self.__gmcenterest_inp( )
        self.__gmfwhmest_inp( )
        self.__gmfix_inp( )
        self.__logfile_inp( )
        self.__append_inp( )
        self.__pfunc_inp( )
        self.__goodamprange_inp( )
        self.__goodcenterrange_inp( )
        self.__goodfwhmrange_inp( )
        self.__sigma_inp( )
        self.__outsigma_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("specfit.last"):
                filename = "specfit.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, box=None, region=None, chans=None, stokes=None, axis=None, mask=None, ngauss=None, poly=None, estimates=None, minpts=None, multifit=None, model=None, residual=None, amp=None, amperr=None, center=None, centererr=None, fwhm=None, fwhmerr=None, integral=None, integralerr=None, wantreturn=None, stretch=None, logresults=None, pampest=None, pcenterest=None, pfwhmest=None, pfix=None, gmncomps=None, gmampcon=None, gmcentercon=None, gmfwhmcon=None, gmampest=None, gmcenterest=None, gmfwhmest=None, gmfix=None, logfile=None, append=None, pfunc=None, goodamprange=None, goodcenterrange=None, goodfwhmrange=None, sigma=None, outsigma=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('specfit.pre')
        _postfile = os.path.realpath('specfit.last')
        _return_result_ = None
        _arguments = [imagename,box,region,chans,stokes,axis,mask,ngauss,poly,estimates,minpts,multifit,model,residual,amp,amperr,center,centererr,fwhm,fwhmerr,integral,integralerr,wantreturn,stretch,logresults,pampest,pcenterest,pfwhmest,pfix,gmncomps,gmampcon,gmcentercon,gmfwhmcon,gmampest,gmcenterest,gmfwhmest,gmfix,logfile,append,pfunc,goodamprange,goodcenterrange,goodfwhmrange,sigma,outsigma]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if box is not None: local_global['box'] = box
            if region is not None: local_global['region'] = region
            if chans is not None: local_global['chans'] = chans
            if stokes is not None: local_global['stokes'] = stokes
            if axis is not None: local_global['axis'] = axis
            if mask is not None: local_global['mask'] = mask
            if poly is not None: local_global['poly'] = poly
            if estimates is not None: local_global['estimates'] = estimates
            if minpts is not None: local_global['minpts'] = minpts
            if multifit is not None: local_global['multifit'] = multifit
            if model is not None: local_global['model'] = model
            if residual is not None: local_global['residual'] = residual
            if wantreturn is not None: local_global['wantreturn'] = wantreturn
            if logresults is not None: local_global['logresults'] = logresults
            if gmncomps is not None: local_global['gmncomps'] = gmncomps
            if gmampcon is not None: local_global['gmampcon'] = gmampcon
            if gmcentercon is not None: local_global['gmcentercon'] = gmcentercon
            if gmfwhmcon is not None: local_global['gmfwhmcon'] = gmfwhmcon
            if gmampest is not None: local_global['gmampest'] = gmampest
            if gmcenterest is not None: local_global['gmcenterest'] = gmcenterest
            if gmfwhmest is not None: local_global['gmfwhmest'] = gmfwhmest
            if gmfix is not None: local_global['gmfix'] = gmfix
            if logfile is not None: local_global['logfile'] = logfile
            if goodamprange is not None: local_global['goodamprange'] = goodamprange
            if goodcenterrange is not None: local_global['goodcenterrange'] = goodcenterrange
            if goodfwhmrange is not None: local_global['goodfwhmrange'] = goodfwhmrange
            if sigma is not None: local_global['sigma'] = sigma

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['box'] = self.__box( local_global )
            _invocation_parameters['region'] = self.__region( local_global )
            _invocation_parameters['chans'] = self.__chans( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['axis'] = self.__axis( local_global )
            _invocation_parameters['mask'] = self.__mask( local_global )
            _invocation_parameters['poly'] = self.__poly( local_global )
            _invocation_parameters['estimates'] = self.__estimates( local_global )
            _invocation_parameters['minpts'] = self.__minpts( local_global )
            _invocation_parameters['multifit'] = self.__multifit( local_global )
            _invocation_parameters['model'] = self.__model( local_global )
            _invocation_parameters['residual'] = self.__residual( local_global )
            _invocation_parameters['wantreturn'] = self.__wantreturn( local_global )
            _invocation_parameters['logresults'] = self.__logresults( local_global )
            _invocation_parameters['gmncomps'] = self.__gmncomps( local_global )
            _invocation_parameters['gmampcon'] = self.__gmampcon( local_global )
            _invocation_parameters['gmcentercon'] = self.__gmcentercon( local_global )
            _invocation_parameters['gmfwhmcon'] = self.__gmfwhmcon( local_global )
            _invocation_parameters['gmampest'] = self.__gmampest( local_global )
            _invocation_parameters['gmcenterest'] = self.__gmcenterest( local_global )
            _invocation_parameters['gmfwhmest'] = self.__gmfwhmest( local_global )
            _invocation_parameters['gmfix'] = self.__gmfix( local_global )
            _invocation_parameters['logfile'] = self.__logfile( local_global )
            _invocation_parameters['goodamprange'] = self.__goodamprange( local_global )
            _invocation_parameters['goodcenterrange'] = self.__goodcenterrange( local_global )
            _invocation_parameters['goodfwhmrange'] = self.__goodfwhmrange( local_global )
            _invocation_parameters['sigma'] = self.__sigma( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['ngauss'] = self.__ngauss( _invocation_parameters ) if ngauss is None else ngauss
            _invocation_parameters['amp'] = self.__amp( _invocation_parameters ) if amp is None else amp
            _invocation_parameters['amperr'] = self.__amperr( _invocation_parameters ) if amperr is None else amperr
            _invocation_parameters['center'] = self.__center( _invocation_parameters ) if center is None else center
            _invocation_parameters['centererr'] = self.__centererr( _invocation_parameters ) if centererr is None else centererr
            _invocation_parameters['fwhm'] = self.__fwhm( _invocation_parameters ) if fwhm is None else fwhm
            _invocation_parameters['fwhmerr'] = self.__fwhmerr( _invocation_parameters ) if fwhmerr is None else fwhmerr
            _invocation_parameters['integral'] = self.__integral( _invocation_parameters ) if integral is None else integral
            _invocation_parameters['integralerr'] = self.__integralerr( _invocation_parameters ) if integralerr is None else integralerr
            _invocation_parameters['stretch'] = self.__stretch( _invocation_parameters ) if stretch is None else stretch
            _invocation_parameters['pampest'] = self.__pampest( _invocation_parameters ) if pampest is None else pampest
            _invocation_parameters['pcenterest'] = self.__pcenterest( _invocation_parameters ) if pcenterest is None else pcenterest
            _invocation_parameters['pfwhmest'] = self.__pfwhmest( _invocation_parameters ) if pfwhmest is None else pfwhmest
            _invocation_parameters['pfix'] = self.__pfix( _invocation_parameters ) if pfix is None else pfix
            _invocation_parameters['append'] = self.__append( _invocation_parameters ) if append is None else append
            _invocation_parameters['pfunc'] = self.__pfunc( _invocation_parameters ) if pfunc is None else pfunc
            _invocation_parameters['outsigma'] = self.__outsigma( _invocation_parameters ) if outsigma is None else outsigma

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['box'] = self.__box( self.__globals_( ) )
            _invocation_parameters['region'] = self.__region( self.__globals_( ) )
            _invocation_parameters['chans'] = self.__chans( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['axis'] = self.__axis( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['ngauss'] = self.__ngauss( self.__globals_( ) )
            _invocation_parameters['poly'] = self.__poly( self.__globals_( ) )
            _invocation_parameters['estimates'] = self.__estimates( self.__globals_( ) )
            _invocation_parameters['minpts'] = self.__minpts( self.__globals_( ) )
            _invocation_parameters['multifit'] = self.__multifit( self.__globals_( ) )
            _invocation_parameters['model'] = self.__model( self.__globals_( ) )
            _invocation_parameters['residual'] = self.__residual( self.__globals_( ) )
            _invocation_parameters['amp'] = self.__amp( self.__globals_( ) )
            _invocation_parameters['amperr'] = self.__amperr( self.__globals_( ) )
            _invocation_parameters['center'] = self.__center( self.__globals_( ) )
            _invocation_parameters['centererr'] = self.__centererr( self.__globals_( ) )
            _invocation_parameters['fwhm'] = self.__fwhm( self.__globals_( ) )
            _invocation_parameters['fwhmerr'] = self.__fwhmerr( self.__globals_( ) )
            _invocation_parameters['integral'] = self.__integral( self.__globals_( ) )
            _invocation_parameters['integralerr'] = self.__integralerr( self.__globals_( ) )
            _invocation_parameters['wantreturn'] = self.__wantreturn( self.__globals_( ) )
            _invocation_parameters['stretch'] = self.__stretch( self.__globals_( ) )
            _invocation_parameters['logresults'] = self.__logresults( self.__globals_( ) )
            _invocation_parameters['pampest'] = self.__pampest( self.__globals_( ) )
            _invocation_parameters['pcenterest'] = self.__pcenterest( self.__globals_( ) )
            _invocation_parameters['pfwhmest'] = self.__pfwhmest( self.__globals_( ) )
            _invocation_parameters['pfix'] = self.__pfix( self.__globals_( ) )
            _invocation_parameters['gmncomps'] = self.__gmncomps( self.__globals_( ) )
            _invocation_parameters['gmampcon'] = self.__gmampcon( self.__globals_( ) )
            _invocation_parameters['gmcentercon'] = self.__gmcentercon( self.__globals_( ) )
            _invocation_parameters['gmfwhmcon'] = self.__gmfwhmcon( self.__globals_( ) )
            _invocation_parameters['gmampest'] = self.__gmampest( self.__globals_( ) )
            _invocation_parameters['gmcenterest'] = self.__gmcenterest( self.__globals_( ) )
            _invocation_parameters['gmfwhmest'] = self.__gmfwhmest( self.__globals_( ) )
            _invocation_parameters['gmfix'] = self.__gmfix( self.__globals_( ) )
            _invocation_parameters['logfile'] = self.__logfile( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['pfunc'] = self.__pfunc( self.__globals_( ) )
            _invocation_parameters['goodamprange'] = self.__goodamprange( self.__globals_( ) )
            _invocation_parameters['goodcenterrange'] = self.__goodcenterrange( self.__globals_( ) )
            _invocation_parameters['goodfwhmrange'] = self.__goodfwhmrange( self.__globals_( ) )
            _invocation_parameters['sigma'] = self.__sigma( self.__globals_( ) )
            _invocation_parameters['outsigma'] = self.__outsigma( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-15s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#specfit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _specfit_t( _invocation_parameters['imagename'],_invocation_parameters['box'],_invocation_parameters['region'],_invocation_parameters['chans'],_invocation_parameters['stokes'],_invocation_parameters['axis'],_invocation_parameters['mask'],_invocation_parameters['ngauss'],_invocation_parameters['poly'],_invocation_parameters['estimates'],_invocation_parameters['minpts'],_invocation_parameters['multifit'],_invocation_parameters['model'],_invocation_parameters['residual'],_invocation_parameters['amp'],_invocation_parameters['amperr'],_invocation_parameters['center'],_invocation_parameters['centererr'],_invocation_parameters['fwhm'],_invocation_parameters['fwhmerr'],_invocation_parameters['integral'],_invocation_parameters['integralerr'],_invocation_parameters['wantreturn'],_invocation_parameters['stretch'],_invocation_parameters['logresults'],_invocation_parameters['pampest'],_invocation_parameters['pcenterest'],_invocation_parameters['pfwhmest'],_invocation_parameters['pfix'],_invocation_parameters['gmncomps'],_invocation_parameters['gmampcon'],_invocation_parameters['gmcentercon'],_invocation_parameters['gmfwhmcon'],_invocation_parameters['gmampest'],_invocation_parameters['gmcenterest'],_invocation_parameters['gmfwhmest'],_invocation_parameters['gmfix'],_invocation_parameters['logfile'],_invocation_parameters['append'],_invocation_parameters['pfunc'],_invocation_parameters['goodamprange'],_invocation_parameters['goodcenterrange'],_invocation_parameters['goodfwhmrange'],_invocation_parameters['sigma'],_invocation_parameters['outsigma'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

specfit = _specfit( )

