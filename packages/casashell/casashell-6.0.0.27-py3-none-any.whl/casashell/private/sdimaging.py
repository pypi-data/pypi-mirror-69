##################### generated by xml-casa (v2) from sdimaging.xml #################
##################### 2222c20069423dc204c9695affa1d53c ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import sdimaging as _sdimaging_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdimaging:
    """
    sdimaging ---- SD task: imaging for total power and spectral data

    
    Task sdimaging creates an image from input single-dish data sets.
    The input can be either total power and spectral data.
    
    The coordinate of output image is defined by four axes, i.e., two
    spatial axes, frequency and polarization axes.n
    By default, spatial coordinate of image is defined so that the all
    pointing directions in POINTING tables of input data sets are covered
    with the cell size, 1/3 of FWHM of primary beam of antennas in the
    first MS. Therefore, it is often easiest to leave spatial definitions
    at the default values. It is also possible to define spatial axes of
    the image by specifying the image center direction (phasecenter),
    number of image pixel (imsize) and size of the pixel (cell).n
    The frequency coordinate of image is defined by three parameters,
    the number of channels (nchan), the channel id/frequency/velocity of
    the first channel (start), and channel width (width).There are three
    modes available to define unit of start and width, i.e., 'channel' (use
    channel indices), 'frequency' (use frequency unit, e.g., 'GHz'),
    and 'velocity' (use velocity unit, e.g., 'km/s'). By default, nchan,
    start, and width are defined so that all selected spectral windows are
    covered with the channel width equal to separation of first two
    channels selected.n
    Finally, polarizations of image is defined by stokes parameter or
    polarization. For example, stokes='XXYY' produces an image cube with
    each plane contains the image of one of the polarizations, while
    stokes='I' produces a 'total intensity' or Stokes I image.n
    
    The task also supports various grid function (convolution kernel) to
    weight spectra as well as an option to remove the most extreme minimum
    and maximum (unweighted) values prior to computing the gridded pixel
    values. See description below for details of gridfunction available.
    
    

    --------- parameter descriptions ---------------------------------------------

    infiles        a list of names of input SD Measurementsets (only MS is allowed for this task)
    outfile        name of output image
    overwrite      overwrite the output file if already exists [True, False]
    field          select data by field IDs and names, e.g. "3C2*" (""=all)
    spw            select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)
    antenna        select data by antenna names or IDs, e.g, "PM03" ("" = all antennas)
    scan           select data by scan numbers, e.g. "21~23" (""=all)
    intent         select data by observational intent, e.g. "*ON_SOURCE*" (""=all)
    mode           spectral gridding type
    nchan          number of channels (planes) in output image (-1=all)
    start          start of output spectral dimension, e.g. "0", "110GHz", "-20km/s"
    width          width of output spectral channels
    veltype        velocity definition
    outframe       velocity frame of output image (""=current frame or LSRK for multiple-MS inputs)
    gridfunction   gridding function for imaging (see description in help)
    convsupport    convolution support for gridding
    truncate       truncation radius for gridding
    gwidth         HWHM for gaussian
    jwidth         c-parameter for jinc function
    imsize         x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)
    cell           x and y cell size, (e.g., ["8arcsec","8arcsec"]. default unit arcmin. ("" = 1/3 of FWHM of primary beam)
    phasecenter    image center direction: position or field index, e.g., "J2000 17:30:15.0 -25.30.00.0". ("" = the center of pointing directions in MSes)
    projection     map projection type
    ephemsrcname   ephemeris source name, e.g. "MARS"
    pointingcolumn pointing data column to use
    restfreq       rest frequency to assign to image, e.g., "114.5GHz"
    stokes         stokes parameters or polarization types to image, e.g. "I", "XX"
    minweight      Minimum weight ratio to the median of weight used in weight correction and weight beased masking
    brightnessunit Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\']
    clipminmax     Clip minimum and maximum value from each pixel. Note the benefit of clipping is lost when the number of integrations contributing to each gridded pixel is small, or where the incidence of spurious datapoints is approximately or greater than the number of beams (in area) encompassed by expected image.
    [1;42mRETURNS[1;m           void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infiles -- a list of names of input SD Measurementsets
    example: 'm100.PM01.ms'
    ['m100.PM01.ms','m100.PM03.ms']; multiple MSes
    outfile -- name of output image
    default: ''
    example: 'mySDimage.im'
    overwrite -- overwrite the output file if already exists
    options: (bool) True,False
    default: False (do NOT overwrite)
    example: if True, existing file will be overwritten
    field -- select data by field IDs and names
    If field string is a non-negative integer, it is assumed to
    be a field index otherwise, it is assumed to be a
    field name
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 3 or filed named 3C273)
    For multiple MS input, a list of field strings can be used:
    field = ['0~2','0~4'] (field ids 0-2 for the first MS and 0-4
    for the second)
    field = '0~2' (field ids 0-2 for all input MSes)
    this selection is in addition to the other selections to data
    spw -- select data by spectral window IDs/channels
    NOTE: channels de-selected here will contain all zeros if
    selected by the parameter mode subparameters.
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    For multiple MS input, a list of spw strings can be used:
    spw=['0','0~3'] (spw ids 0 for the first MS and 0-3 for the second)
    spw='0~3' (spw ids 0-3 for all input MSes)
    this selection is in addition to the other selections to data
    antenna -- select data by antenna names or IDs
    If antenna string is a non-negative integer, it is
    assumed to be an antenna index, otherwise, it is
    considered an antenna name.
    default: '' (all baselines, i.e. all antenna in case of auto data)
    example: antenna='PM03'
    For multiple MS input, a list of antenna strings can be used:
    antenna=['5','6'] (antenna id5 for the first MS and 6 for the second)
    antenna='5' (antenna index 5 for all input MSes)
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    For multiple MS input, a list of scan strings can be used:
    scan=['0~100','10~200'] (scan ids 0-100 for the first MS
    and 10-200 for the second)
    scan='0~100 (scan ids 0-100 for all input MSes)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: 'OBSERVE_TARGET#ON_SOURCE' (ALMA ON-source intent)
    example: intent='' (use all scan intents)
    intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    For multiple MS input, a list of scan-intent expressions can be used:
    intent=['ON_SOURCE','CALIBRATE_BANDPASS'] (scan intent ON_SOURCE for the first MS
    and CALIBRATE_BANDPASS for the second)
    this selection is in addition to the other selections to data
    mode -- spectral gridding type
    options: 'channel', 'velocity', 'frequency'
    default: 'channel'
    >>> mode expandable parameters
    nchan -- Total number of channels in the output image.
    default: -1; Automatically selects enough channels to cover
    data selected by 'spw' consistent with 'start' and 'width'.
    It is often easiest to leave nchan at the default value.
    example: nchan=100
    start -- First channel, velocity, or frequency.
    For mode='channel'; This selects the channel index number
    from the MS (0 based) that you want to correspond to the
    first channel of the output cube. The output cube will be
    in frequency space with the first channel having the
    frequency of the MS channel selected by start.  start=0
    refers to the first channel in the first selected spw, even
    if that channel is de-selected in the spw parameter.
    Channels de-selected by the spw parameter will be filled with
    zeros if included by the start parameter. For example,
    spw=3~8:3~100 and start=2 will produce a cube that starts on
    the third channel (recall 0 based) of spw index 3, and the
    first channel will be blank.
    default: '' (the first input channel of first input spw)
    example: start=100 (mode='channel')
    start='22.3GHz' (mode='frequency')
    start='5.0km/s' (mode='velocity')
    width -- Output channel width
    For mode='channel', default=1; width>1 indicates channel averaging
    example: width=4.
    For mode= 'velocity' or 'frequency', default=''; width of
    first input channel, or more precisely, the difference
    in frequencies between the first two selected channels.
    -- For example if channels 1 and 3 are selected with spw,
    then the default width will be the difference between their
    frequencies, and not the width of channel 1.
    -- Similarly, if the selected data has uneven channel-spacing,
    the default width will be picked from the first two selected
    channels. In this case, please specify the desired width.
    When specifying the width, one must give units
    examples: width='1.0km/s', or width='24.2kHz'.
    Setting width>0 gives channels of increasing frequency for
    mode='frequency', and increasing velocity for mode='velocity'.
    veltype -- Velocity definition
    Options: 'radio','optical','true','relativistic'
    default: 'radio'
    outframe -- velocity reference frame of output image
    Options: '','LSRK','LSRD','BARY','GEO','TOPO','GALACTO',
    'LGROUP','CMB'
    default: ''; same as input data or 'LSRK' for multiple-MS inputs
    example: frame='bary' for Barycentric frame
    gridfunction -- gridding function for imaging
    options: 'BOX' (Box-car), 'SF' (Spheroidal),
    'PB' (Primary-beam), 'GAUSS' (Gaussian),
    'GJINC' (Gaussian*Jinc)
    default: 'BOX'
    example: 'SF'
    >>> gridfunction expandable parameter:
    convsupport -- convolution support for 'SF'
    default: -1 (use default for each gridfunction)
    example: 3
    truncate -- truncattion radius of convolution kernel.
    effective only for 'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    gwidth -- HWHM for gaussian. Effective only for
    'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    jwidth -- Width of jinc function. Effective only for
    'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    imsize -- x and y image size in pixels, symmetric for single value
    default: [] (=cover all pointings in MS)
    example: imsize=200 (equivalent to [200,200])
    cell -- x and y cell size. default unit arcmin
    default: '' (= 1/3 of FWHM of primary beam)
    example: cell=['0.2arcmin, 0.2arcmin']
    cell='0.2arcmin' (equivalent to example above)
    phasecenter -- image phase center: direction measure or field ID
    default: '' (= the center of pointing directions in
    POINTING table of infiles)
    example: 6 (field id), 'J2000 13h44m00 -17d02m00',
    'AZEL -123d48m29 15d41m41'
    projection -- map projection type. See Calabretta & Greisen (2002) for detail.
    default: 'SIN'
    options: 'SIN', 'CAR', 'TAN', 'SFL'
    ephemsrcname -- ephemeris source name for moving source (solar sytem objects)
    default: '' (none)
    If specified source name matches one of the solar system
    objects known by CASA (see examples below), the task realigns
    the data by correcting spatial shifts of the source during
    observation, so that the source appears to be fixed in the
    image. If specified name doesn't match, the task will fail.
    When moving source correction is applied, the source is fixed
    to the position at the beginning of the on-source observation
    in the data. Direction reference frame of output image refers
    phasecenter (it is 'J2000' if phasecenter is empty). Note that
    moving source correction is not applied unless the user
    explicitly set ephemsrcname even if target field is one of
    the solar system objects known by CASA. Note also that setting
    'pointing_offset' or 'source_offset' to directioncolumn
    disables moving source correction so that these values should
    not be used when the user wants to activate moving source
    correction.
    examples: 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN',
    'URANUS', 'NEPTUNE', 'PLUTO', 'SUN', 'MOON'
    pointingcolumn -- pointing data column to use
    option: 'direction', 'target', 'pointing_offset', 'source_offset', encoder'
    default: 'direction'
    restfreq -- specify rest frequency to use for output image
    default: '' (refer input data)
    example: 1.0e11, '100GHz'
    stokes -- stokes parameters or polarization types to image
    default: '' (use all polarizations)
    example: 'XX'
    minweight -- Minimum weight ratio to the median of weight used in
    weight correction and weight based masking
    default: 0.1
    example: minweight = 0.
    brightnessunit -- Overwrite the brightness unit in image.
    default: '' (use the unit in MS)
    Options: '', 'K' (Kelvin), 'Jy/beam'
    clipminmax -- Clip minimum and maximum value from each pixel.
    Note the benefit of clipping is lost when the number of
    integrations contributing to each gridded pixel is small,
    or where the incidence of spurious datapoints is
    approximately or greater than the number of beams (in area)
    encompassed by expected image.
    default: False
    option: True, False
    
    
    -----------------
    Gridding Kernel
    -----------------
    The parameter gridfunction sets gridding function (convolution kernel)
    for imaging. Currently, the task supports 'BOX' (Box-car), 'SF' (Prolate
    Spheroidal Wave Function), 'GAUSS' (Gaussian), 'GJINC' (Gaussian*Jinc),
    where Jinc(x) = J_1(pi*x/c)/(pi*x/c) with a first order Bessel function
    J_1, and 'PB' (Primary Beam). For 'PB', correct antenna informations
    should be included in input file.
    
    There are four subparameters for gridfunction: convsupport, truncate,
    gwidth, and jwidth. The convsupport is an integer specifying cut-off
    radius for 'SF' in units of pixel. By default (convsupport=-1),
    the cut-off radius is set to 3 pixels. The truncate is a cut-off
    radius for 'GAUSS' or 'GJINC'. It accepts integer, float, and
    string values of numeric plus unit. Allowed units are angular
    units such as 'deg', 'arcmin', 'arcsec', and 'pixel'. Default unit
    is 'pixel' so that string without unit or numerical values (integer
    or float) will be interpreted as radius in pixel. Default value
    for truncate, which is used when negative radius is set, is 3*HWHM
    for 'GAUSS' and radius at first null for 'GJINC'. The gwidth is
    the HWHM of gaussian for 'GAUSS' and 'GJINC'. Default value is
    sqrt(log(2)) pixel for 'GAUSS' and 2.52*sqrt(log(2)) pixel for
    'GJINC'. The jwidth specifies width of the jinc function (parameter
    'c' in the definition above). Default is 1.55 pixel. Both gwidth
    jwidth allows integer, float, or string of numeric plus unit.
    Default values for gwidth and jwidth are taken from Mangum et al.
    (2007). Formula for 'GAUSS' and 'GJINC' are taken from Table 1 in
    the paper, and are written as below using gwidth and jwidth:
    
    GAUSS: exp[-log(2)*(|r|/gwidth)**2]
    
    GJINC: J_1(pi*|r|/jwidth)/(pi*|r|/jwidth)
    * exp[-log(2)*(|r|/gwidth)^2]
    
    
    Reference: Mangum, et al. 2007, A&A, 474, 679-687
    
    --------------------
    Mask in Output Image
    --------------------
    The parameter minweight defines a threshold of weight values
    to mask. The pixels in outfile whose weight is smaller than
    minweight*median(weight) are masked out. The task also creates
    a weight image with the name outfile.weight.
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """SD task: imaging for total power and spectral data"""

    __schema = {'infiles': {'type': 'cReqPathVec', 'coerce': [_coerce.to_list,_coerce.expand_pathvec]}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'mode': {'type': 'cStr'}, 'nchan': {'type': 'cInt'}, 'start': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'width': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'veltype': {'type': 'cStr'}, 'outframe': {'type': 'cStr'}, 'gridfunction': {'type': 'cStr'}, 'convsupport': {'type': 'cInt'}, 'truncate': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'gwidth': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'jwidth': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'imsize': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'cell': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'projection': {'type': 'cStr'}, 'ephemsrcname': {'type': 'cStr'}, 'pointingcolumn': {'type': 'cStr'}, 'restfreq': {'anyof': [{'type': 'cStr'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'stokes': {'type': 'cStr'}, 'minweight': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'brightnessunit': {'type': 'cStr'}, 'clipminmax': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __projection_dflt( self, glb ):
        return 'SIN'

    def __projection( self, glb ):
        if 'projection' in glb: return glb['projection']
        return 'SIN'

    def __gridfunction_dflt( self, glb ):
        return 'BOX'

    def __gridfunction( self, glb ):
        if 'gridfunction' in glb: return glb['gridfunction']
        return 'BOX'

    def __clipminmax_dflt( self, glb ):
        return False

    def __clipminmax( self, glb ):
        if 'clipminmax' in glb: return glb['clipminmax']
        return False

    def __pointingcolumn_dflt( self, glb ):
        return 'direction'

    def __pointingcolumn( self, glb ):
        if 'pointingcolumn' in glb: return glb['pointingcolumn']
        return 'direction'

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __outframe_dflt( self, glb ):
        return ''

    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        return ''

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __cell_dflt( self, glb ):
        return ''

    def __cell( self, glb ):
        if 'cell' in glb: return glb['cell']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __restfreq_dflt( self, glb ):
        return ''

    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        return ''

    def __brightnessunit_dflt( self, glb ):
        return ''

    def __brightnessunit( self, glb ):
        if 'brightnessunit' in glb: return glb['brightnessunit']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __imsize_dflt( self, glb ):
        return [  ]

    def __imsize( self, glb ):
        if 'imsize' in glb: return glb['imsize']
        return [  ]

    def __ephemsrcname_dflt( self, glb ):
        return ''

    def __ephemsrcname( self, glb ):
        if 'ephemsrcname' in glb: return glb['ephemsrcname']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __mode_dflt( self, glb ):
        return 'channel'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'channel'

    def __minweight_dflt( self, glb ):
        return float(0.1)

    def __minweight( self, glb ):
        if 'minweight' in glb: return glb['minweight']
        return float(0.1)

    def __infiles_dflt( self, glb ):
        return [  ]

    def __infiles( self, glb ):
        if 'infiles' in glb: return glb['infiles']
        return [  ]

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False

    def __intent_dflt( self, glb ):
        return 'OBSERVE_TARGET#ON_SOURCE'

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return 'OBSERVE_TARGET#ON_SOURCE'



    #--------- return inp/go default --------------------------------------------------
    def __convsupport_dflt( self, glb ):
        if self.__gridfunction( glb ) == "SF": return int(-1)
        if self.__gridfunction( glb ) == "sf": return int(-1)
        return None
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        return None
    def __truncate_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __gwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __veltype_dflt( self, glb ):
        if self.__mode( glb ) == "velocity": return "radio"
        return None
    def __jwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        dflt = self.__veltype_dflt( glb )
        if dflt is not None: return dflt
        return 'radio'
    def __convsupport( self, glb ):
        if 'convsupport' in glb: return glb['convsupport']
        dflt = self.__convsupport_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __truncate( self, glb ):
        if 'truncate' in glb: return glb['truncate']
        dflt = self.__truncate_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __gwidth( self, glb ):
        if 'gwidth' in glb: return glb['gwidth']
        dflt = self.__gwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __jwidth( self, glb ):
        if 'jwidth' in glb: return glb['jwidth']
        dflt = self.__jwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)

    #--------- subparam inp output ----------------------------------------------------
    def __infiles_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__infiles( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'infiles': value},{'infiles': self.__schema['infiles']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('infiles',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'spectral gridding type ["channel", "frequency", "velocity"]'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __nchan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nchan',pre,self.__to_string_(value),post,description))
    def __start_inp(self):
        out = self.__stdout or sys.stdout
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__start( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('start',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__width( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __veltype_inp(self):
        out = self.__stdout or sys.stdout
        if self.__veltype_dflt( self.__globals_( ) ) is not None:
             description = 'velocity definition ["radio", "optical", "true" or "relativistic"] '
             value = self.__veltype( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('veltype',pre,self.__to_string_(value),post,description))
    def __outframe_inp(self):
        out = self.__stdout or sys.stdout
        description = 'velocity frame of output image ["lsrk", "lsrd", "bary", "geo", "topo", "galacto", "lgroup", "cmb"] (""=current frame or LSRK for multiple-MS inputs) '
        value = self.__outframe( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('outframe',pre,self.__to_string_(value),post,description))
    def __gridfunction_inp(self):
        out = self.__stdout or sys.stdout
        description = 'gridding function for imaging ["BOX", "SF", "PB", "GAUSS" or "GJINC"] (see description in help)'
        value = self.__gridfunction( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gridfunction': value},{'gridfunction': self.__schema['gridfunction']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gridfunction',pre,self.__to_string_(value),post,description))
    def __convsupport_inp(self):
        out = self.__stdout or sys.stdout
        if self.__convsupport_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__convsupport( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'convsupport': value},{'convsupport': self.__schema['convsupport']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('convsupport',pre,self.__to_string_(value),post,description))
    def __truncate_inp(self):
        out = self.__stdout or sys.stdout
        if self.__truncate_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__truncate( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'truncate': value},{'truncate': self.__schema['truncate']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('truncate',pre,self.__to_string_(value),post,description))
    def __gwidth_inp(self):
        out = self.__stdout or sys.stdout
        if self.__gwidth_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__gwidth( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'gwidth': value},{'gwidth': self.__schema['gwidth']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gwidth',pre,self.__to_string_(value),post,description))
    def __jwidth_inp(self):
        out = self.__stdout or sys.stdout
        if self.__jwidth_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__jwidth( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'jwidth': value},{'jwidth': self.__schema['jwidth']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('jwidth',pre,self.__to_string_(value),post,description))
    def __imsize_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imsize( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imsize': value},{'imsize': self.__schema['imsize']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('imsize',pre,self.__to_string_(value),post,description))
    def __cell_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__cell( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'cell': value},{'cell': self.__schema['cell']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('cell',pre,self.__to_string_(value),post,description))
    def __phasecenter_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('phasecenter',pre,self.__to_string_(value),post,description))
    def __projection_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__projection( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'projection': value},{'projection': self.__schema['projection']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('projection',pre,self.__to_string_(value),post,description))
    def __ephemsrcname_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__ephemsrcname( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'ephemsrcname': value},{'ephemsrcname': self.__schema['ephemsrcname']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('ephemsrcname',pre,self.__to_string_(value),post,description))
    def __pointingcolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = 'pointing data column to use ["direction", "target", "pointing_offset", "source_offset" or "encoder"]'
        value = self.__pointingcolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'pointingcolumn': value},{'pointingcolumn': self.__schema['pointingcolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('pointingcolumn',pre,self.__to_string_(value),post,description))
    def __restfreq_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__restfreq( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('restfreq',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __minweight_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Minimum weight ratio to use'
        value = self.__minweight( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'minweight': value},{'minweight': self.__schema['minweight']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('minweight',pre,self.__to_string_(value),post,description))
    def __brightnessunit_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__brightnessunit( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'brightnessunit': value},{'brightnessunit': self.__schema['brightnessunit']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('brightnessunit',pre,self.__to_string_(value),post,description))
    def __clipminmax_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Clip minimum and maximum value from each pixel'
        value = self.__clipminmax( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'clipminmax': value},{'clipminmax': self.__schema['clipminmax']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('clipminmax',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'brightnessunit' in glb: del glb['brightnessunit']
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'field' in glb: del glb['field']
        if 'convsupport' in glb: del glb['convsupport']
        if 'projection' in glb: del glb['projection']
        if 'intent' in glb: del glb['intent']
        if 'nchan' in glb: del glb['nchan']
        if 'pointingcolumn' in glb: del glb['pointingcolumn']
        if 'truncate' in glb: del glb['truncate']
        if 'imsize' in glb: del glb['imsize']
        if 'scan' in glb: del glb['scan']
        if 'gwidth' in glb: del glb['gwidth']
        if 'restfreq' in glb: del glb['restfreq']
        if 'clipminmax' in glb: del glb['clipminmax']
        if 'veltype' in glb: del glb['veltype']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'cell' in glb: del glb['cell']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'overwrite' in glb: del glb['overwrite']
        if 'minweight' in glb: del glb['minweight']
        if 'ephemsrcname' in glb: del glb['ephemsrcname']
        if 'jwidth' in glb: del glb['jwidth']
        if 'start' in glb: del glb['start']
        if 'gridfunction' in glb: del glb['gridfunction']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'infiles' in glb: del glb['infiles']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__infiles_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__veltype_inp( )
        self.__outframe_inp( )
        self.__gridfunction_inp( )
        self.__convsupport_inp( )
        self.__truncate_inp( )
        self.__gwidth_inp( )
        self.__jwidth_inp( )
        self.__imsize_inp( )
        self.__cell_inp( )
        self.__phasecenter_inp( )
        self.__projection_inp( )
        self.__ephemsrcname_inp( )
        self.__pointingcolumn_inp( )
        self.__restfreq_inp( )
        self.__stokes_inp( )
        self.__minweight_inp( )
        self.__brightnessunit_inp( )
        self.__clipminmax_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("sdimaging.last"):
                filename = "sdimaging.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, infiles=None, outfile=None, overwrite=None, field=None, spw=None, antenna=None, scan=None, intent=None, mode=None, nchan=None, start=None, width=None, veltype=None, outframe=None, gridfunction=None, convsupport=None, truncate=None, gwidth=None, jwidth=None, imsize=None, cell=None, phasecenter=None, projection=None, ephemsrcname=None, pointingcolumn=None, restfreq=None, stokes=None, minweight=None, brightnessunit=None, clipminmax=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdimaging.pre')
        _postfile = os.path.realpath('sdimaging.last')
        _return_result_ = None
        _arguments = [infiles,outfile,overwrite,field,spw,antenna,scan,intent,mode,nchan,start,width,veltype,outframe,gridfunction,convsupport,truncate,gwidth,jwidth,imsize,cell,phasecenter,projection,ephemsrcname,pointingcolumn,restfreq,stokes,minweight,brightnessunit,clipminmax]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infiles is not None: local_global['infiles'] = infiles
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if antenna is not None: local_global['antenna'] = antenna
            if scan is not None: local_global['scan'] = scan
            if intent is not None: local_global['intent'] = intent
            if mode is not None: local_global['mode'] = mode
            if outframe is not None: local_global['outframe'] = outframe
            if gridfunction is not None: local_global['gridfunction'] = gridfunction
            if imsize is not None: local_global['imsize'] = imsize
            if cell is not None: local_global['cell'] = cell
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if projection is not None: local_global['projection'] = projection
            if ephemsrcname is not None: local_global['ephemsrcname'] = ephemsrcname
            if pointingcolumn is not None: local_global['pointingcolumn'] = pointingcolumn
            if restfreq is not None: local_global['restfreq'] = restfreq
            if stokes is not None: local_global['stokes'] = stokes
            if minweight is not None: local_global['minweight'] = minweight
            if brightnessunit is not None: local_global['brightnessunit'] = brightnessunit
            if clipminmax is not None: local_global['clipminmax'] = clipminmax

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infiles'] = self.__infiles( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['outframe'] = self.__outframe( local_global )
            _invocation_parameters['gridfunction'] = self.__gridfunction( local_global )
            _invocation_parameters['imsize'] = self.__imsize( local_global )
            _invocation_parameters['cell'] = self.__cell( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['projection'] = self.__projection( local_global )
            _invocation_parameters['ephemsrcname'] = self.__ephemsrcname( local_global )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( local_global )
            _invocation_parameters['restfreq'] = self.__restfreq( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['minweight'] = self.__minweight( local_global )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( local_global )
            _invocation_parameters['clipminmax'] = self.__clipminmax( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['veltype'] = self.__veltype( _invocation_parameters ) if veltype is None else veltype
            _invocation_parameters['convsupport'] = self.__convsupport( _invocation_parameters ) if convsupport is None else convsupport
            _invocation_parameters['truncate'] = self.__truncate( _invocation_parameters ) if truncate is None else truncate
            _invocation_parameters['gwidth'] = self.__gwidth( _invocation_parameters ) if gwidth is None else gwidth
            _invocation_parameters['jwidth'] = self.__jwidth( _invocation_parameters ) if jwidth is None else jwidth

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['gridfunction'] = self.__gridfunction( self.__globals_( ) )
            _invocation_parameters['convsupport'] = self.__convsupport( self.__globals_( ) )
            _invocation_parameters['truncate'] = self.__truncate( self.__globals_( ) )
            _invocation_parameters['gwidth'] = self.__gwidth( self.__globals_( ) )
            _invocation_parameters['jwidth'] = self.__jwidth( self.__globals_( ) )
            _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
            _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['projection'] = self.__projection( self.__globals_( ) )
            _invocation_parameters['ephemsrcname'] = self.__ephemsrcname( self.__globals_( ) )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['minweight'] = self.__minweight( self.__globals_( ) )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( self.__globals_( ) )
            _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-14s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdimaging( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _sdimaging_t( _invocation_parameters['infiles'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['antenna'],_invocation_parameters['scan'],_invocation_parameters['intent'],_invocation_parameters['mode'],_invocation_parameters['nchan'],_invocation_parameters['start'],_invocation_parameters['width'],_invocation_parameters['veltype'],_invocation_parameters['outframe'],_invocation_parameters['gridfunction'],_invocation_parameters['convsupport'],_invocation_parameters['truncate'],_invocation_parameters['gwidth'],_invocation_parameters['jwidth'],_invocation_parameters['imsize'],_invocation_parameters['cell'],_invocation_parameters['phasecenter'],_invocation_parameters['projection'],_invocation_parameters['ephemsrcname'],_invocation_parameters['pointingcolumn'],_invocation_parameters['restfreq'],_invocation_parameters['stokes'],_invocation_parameters['minweight'],_invocation_parameters['brightnessunit'],_invocation_parameters['clipminmax'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

sdimaging = _sdimaging( )

