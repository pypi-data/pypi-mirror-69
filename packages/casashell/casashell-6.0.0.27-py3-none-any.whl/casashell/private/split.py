##################### generated by xml-casa (v2) from split.xml #####################
##################### 4f4939f48df6d95ab11c44115a8d0423 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import split as _split_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _split:
    """
    split ---- Create a visibility subset from an existing visibility set

    
    Split is the general purpose program to make a new data set that is a
    subset or averaged form of an existing data set. General selection
    parameters are included, and one or all of the various data columns
    (DATA, LAG_DATA and/or FLOAT_DATA, MODEL_DATA and/or CORRECTED_DATA)
    can be selected.
    
    Split is often used after the initial calibration of the data to make
    a smaller Measurement Set with only the data that will be used in
    further flagging, imaging and/or self-calibration. Split can average
    over frequency (channels) and time (integrations).
    
    The split task uses the MSTransform framework underneath. Split also
    supports the Multi-MS (MMS) format as input.

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file
                Default: none
                
                   Example: vis='ngc5921.ms'
    outputvis   Name of output visibility file
                Default: '' (same as vis)
                
                   Example: outputvis='ngc5921_out.ms'
                
                IMPORTANT: if a .flagversions file with the name
                of the output MS exist, this task will exit with
                an error. The user needs to rename or remove the
                existing flagbackup or choose a different output
                name for the MS.
    keepmms     Create a Multi-MS as the output if the input is a
                Multi-MS.
                Default: True
                Options: True|False
                
                By default it will create a Multi-MS when the
                input is a Multi-MS. The output Multi-MS will
                have the same partition axis of the input
                MMS. See CASA Docs for more information on
                the MMS format.
                
                NOTE: It is not possible to do time average with
                combine='scan' if the input MMS was partitioned
                with separationaxis='scan' or 'auto'. In this
                case, the task will abort with an error.
    field       Select field using field id(s) or field name(s)
                Default: '' (all fields)
                
                Use 'go listobs' to obtain the list id's or
                names. If field string is a non-negative integer,
                it is assumed a field index,  otherwise, it is
                assumed a field name.
                
                   Examples:
                   field='0~2'; field ids 0,1,2
                   field='0,4,5~7'; field ids 0,4,5,6,7
                   field='3C286,3C295'; field named 3C286 and
                   3C295
                   field = '3,4C*'; field id 3, all names
                   starting with 4C
    spw         Select spectral window/channels
                          Default: ''=all spectral windows and channels
                
                             Examples:
                             spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                             spw='<2';  spectral windows less than 2 (i.e. 0,1)
                             spw='0:5~61'; spw 0, channels 5 to 61
                             spw='0,10,3:3~45'; spw 0,10 all channels, spw
                             3 - chans 3 to 45.
                             spw='0~2:2~6'; spw 0,1,2 with channels 2
                             through 6 in each.
                             spw = '*:3~64'  channels 3 through 64 for all sp id's
                             spw = ' :3~64' will NOT work.
                
                          NOTE: mstransform does not support multiple
                          channel ranges per spectral window (';').
    scan        Scan number range
                Subparameter of selectdata=True
                Default: '' = all
    antenna     Select data based on antenna/baseline
                                   Subparameter of selectdata=True
                                   Default: '' (all)
                
                                   If antenna string is a non-negative integer, it
                                   is assumed an antenna index, otherwise, it is
                                   assumed as an antenna name
                
                                       Examples: 
                                       antenna='5&6'; baseline between antenna
                                       index 5 and index 6.
                                       antenna='VA05&VA06'; baseline between VLA
                                       antenna 5 and 6.
                                       antenna='5&6;7&8'; baselines with
                                       indices 5-6 and 7-8
                                       antenna='5'; all baselines with antenna index
                                       5
                                       antenna='05'; all baselines with antenna
                                       number 05 (VLA old name)
                                       antenna='5,6,10'; all baselines with antennas
                                       5,6,10 index numbers
    correlation Select data based on correlation
                Default: '' ==> all
                
                   Example: correlation="XX,YY".
    timerange   Select data based on time range
                Subparameter of selectdata=True
                Default = '' (all)
                
                   Examples:
                   timerange =
                   'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                   (Note: if YYYY/MM/DD is missing date defaults
                   to first day in data set.)
                   timerange='09:14:0~09:54:0' picks 40 min on
                   first day 
                   timerange= '25:00:00~27:30:00' picks 1 hr to 3
                   hr 30min on NEXT day
                   timerange='09:44:00' pick data within one
                   integration of time
                   timerange='>10:24:00' data after this time
    intent      Select observing intent
                Default: '' (no selection by intent)
                
                   Example: intent='*BANDPASS*'  (selects data
                   labelled with BANDPASS intent)
    array       (Sub)array number range
                Default: '' (all)
    uvrange     Select data by baseline length.
                Default = '' (all)
                
                   Examples:
                   uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                   uvrange='>4klambda';uvranges greater than 4 kilo-lambda
                   uvrange='0~1000km'; uvrange in kilometers
    observation Select by observation ID(s)
                Subparameter of selectdata=True
                Default: '' = all
                
                    Example: observation='0~2,4'
    feed        Selection based on the feed 
                NOT IMPLEMENTED YET!
                Default: '' = all
    datacolumn  Which data column(s) to use for processing
                                 (case-insensitive).
                                 Default: 'corrected'
                                 Options: 'data', 'model', 'corrected',
                                 'all','float_data', 'lag_data',
                                 'float_data,data', 'lag_data,data'
                
                                    Example: datacolumn='data'
                
                                 NOTE: 'all' = whichever of the above that are
                                 present. If the requested column does not exist,
                                 the task will exit with an error.
    keepflags   Keep *completely flagged rows* instead of dropping them.
                Default: True (keep completely flagged rows in
                the output)
                Options: True|False
                
                Keepflags has no effect on partially flagged
                rows. All of the channels and correlations of a
                row must be flagged for it to be droppable, and a
                row must be well defined to be keepable.
                
                IMPORTANT: Regardless of this parameter, flagged
                data is never included in channel averaging. On
                the other hand, partially flagged rows will
                always be included in time averaging. The average
                value of the flagged data for averages containing
                ONLY flagged data in the relevant output channel
                will be written to the output with the
                corresponding flag set to True, while only
                unflagged data is used on averages where there is
                some unflagged data with the flag set to False.
    width       Number of channels to average to form one output channel
                If a list is given, each bin will apply to one
                spw in the selection.
                Default: 1 (no channel average)
                Options: (int)|[int]
                
                   Example: chanbin=[2,3] => average 2 channels
                   of 1st selected spectral window and 3 in the
                   second one.
    timebin     Bin width for time averaging
                Default: '0s'
                
                Bin width for time averaging. When timebin is
                greater than 0s, the task will average data in
                time. Flagged data will be included in the
                average calculation, unless the parameter
                keepflags is set to False. In this case only
                partially flagged rows will be used in the
                average.
    combine     Let the timebin span across scan, state or both.
                Default: '' (separate time bins by both of the
                above)
                Options: 'scan', 'state', 'state,scan'
                
                State is equivalent to sub-scans. One scan may
                have several state ids. For ALMA MSs, the
                sub-scans are limited to about 30s duration
                each. In these cases, the task will automatically
                add state to the combine parameter. To see the
                number of states in an MS, use the msmd tool. See
                help msmd.
                
                   Examples: 
                 * combine = 'scan'; can be useful when the scan
                   number goes up with each integration as in
                   many WSRT MSs.
                 * combine = ['scan', 'state']: disregard scan
                   and state numbers when time averaging.
                 * combine = 'state,scan'; same as above.
                
                NOTE: It is not possible to do time average with
                combine='scan' if the input MMS was partitioned
                with separationaxis='scan' or 'auto'. In this
                case, the task will abort with an error.

    --------- examples -----------------------------------------------------------

    
    
    For more information, see the task pages of split in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Create a visibility subset from an existing visibility set"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'keepmms': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'correlation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'array': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'feed': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'datacolumn': {'type': 'cStr'}, 'keepflags': {'type': 'cBool'}, 'width': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'timebin': {'type': 'cStr'}, 'combine': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __width_dflt( self, glb ):
        return int(1)

    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        return int(1)

    def __feed_dflt( self, glb ):
        return ''

    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        return ''

    def __keepmms_dflt( self, glb ):
        return True

    def __keepmms( self, glb ):
        if 'keepmms' in glb: return glb['keepmms']
        return True

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __correlation_dflt( self, glb ):
        return ''

    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __array_dflt( self, glb ):
        return ''

    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        return ''

    def __datacolumn_dflt( self, glb ):
        return 'corrected'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'corrected'

    def __observation_dflt( self, glb ):
        return ''

    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __uvrange_dflt( self, glb ):
        return ''

    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __keepflags_dflt( self, glb ):
        return True

    def __keepflags( self, glb ):
        if 'keepflags' in glb: return glb['keepflags']
        return True

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __timebin_dflt( self, glb ):
        return '0s'

    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        return '0s'

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __combine_dflt( self, glb ):
        if self.__timebin( glb ) != "0s": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        dflt = self.__combine_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __outputvis_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of output visibility file'
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('outputvis',pre,self.__to_string_(value),post,description))
    def __keepmms_inp(self):
        out = self.__stdout or sys.stdout
        description = 'If the input is a Multi-MS the output will also be a Multi-MS.'
        value = self.__keepmms( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'keepmms': value},{'keepmms': self.__schema['keepmms']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('keepmms',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Scan number range'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select data based on antenna/baseline'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __correlation_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select data based on correlation'
        value = self.__correlation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('correlation',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select data based on time range'
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select (sub)array(s) by array ID number.'
        value = self.__array( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __uvrange_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select data by baseline length.'
        value = self.__uvrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('uvrange',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select by observation ID(s)'
        value = self.__observation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __feed_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Multi-feed numbers: Not yet implemented.'
        value = self.__feed( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('feed',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Which data column(s) to process.'
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))
    def __keepflags_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__keepflags( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'keepflags': value},{'keepflags': self.__schema['keepflags']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('keepflags',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Number of channels to average to form one output channel'
        value = self.__width( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-11.11s = %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __timebin_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Bin width for time averaging'
        value = self.__timebin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timebin',pre,self.__to_string_(value),post,description))
    def __combine_inp(self):
        out = self.__stdout or sys.stdout
        if self.__combine_dflt( self.__globals_( ) ) is not None:
             description = 'Span the timebin across scan, state or both'
             value = self.__combine( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-8.8s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('combine',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'keepmms' in glb: del glb['keepmms']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'intent' in glb: del glb['intent']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'timebin' in glb: del glb['timebin']
        if 'keepflags' in glb: del glb['keepflags']
        if 'array' in glb: del glb['array']
        if 'correlation' in glb: del glb['correlation']
        if 'feed' in glb: del glb['feed']
        if 'combine' in glb: del glb['combine']
        if 'uvrange' in glb: del glb['uvrange']
        if 'observation' in glb: del glb['observation']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__keepmms_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__antenna_inp( )
        self.__correlation_inp( )
        self.__timerange_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__uvrange_inp( )
        self.__observation_inp( )
        self.__feed_inp( )
        self.__datacolumn_inp( )
        self.__keepflags_inp( )
        self.__width_inp( )
        self.__timebin_inp( )
        self.__combine_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("split.last"):
                filename = "split.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, outputvis=None, keepmms=None, field=None, spw=None, scan=None, antenna=None, correlation=None, timerange=None, intent=None, array=None, uvrange=None, observation=None, feed=None, datacolumn=None, keepflags=None, width=None, timebin=None, combine=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('split.pre')
        _postfile = os.path.realpath('split.last')
        _return_result_ = None
        _arguments = [vis,outputvis,keepmms,field,spw,scan,antenna,correlation,timerange,intent,array,uvrange,observation,feed,datacolumn,keepflags,width,timebin,combine]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if keepmms is not None: local_global['keepmms'] = keepmms
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if antenna is not None: local_global['antenna'] = antenna
            if correlation is not None: local_global['correlation'] = correlation
            if timerange is not None: local_global['timerange'] = timerange
            if intent is not None: local_global['intent'] = intent
            if array is not None: local_global['array'] = array
            if uvrange is not None: local_global['uvrange'] = uvrange
            if observation is not None: local_global['observation'] = observation
            if feed is not None: local_global['feed'] = feed
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if keepflags is not None: local_global['keepflags'] = keepflags
            if width is not None: local_global['width'] = width
            if timebin is not None: local_global['timebin'] = timebin

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['keepmms'] = self.__keepmms( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['correlation'] = self.__correlation( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['array'] = self.__array( local_global )
            _invocation_parameters['uvrange'] = self.__uvrange( local_global )
            _invocation_parameters['observation'] = self.__observation( local_global )
            _invocation_parameters['feed'] = self.__feed( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['keepflags'] = self.__keepflags( local_global )
            _invocation_parameters['width'] = self.__width( local_global )
            _invocation_parameters['timebin'] = self.__timebin( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['combine'] = self.__combine( _invocation_parameters ) if combine is None else combine

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['keepmms'] = self.__keepmms( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['keepflags'] = self.__keepflags( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#split( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _split_t( _invocation_parameters['vis'],_invocation_parameters['outputvis'],_invocation_parameters['keepmms'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['scan'],_invocation_parameters['antenna'],_invocation_parameters['correlation'],_invocation_parameters['timerange'],_invocation_parameters['intent'],_invocation_parameters['array'],_invocation_parameters['uvrange'],_invocation_parameters['observation'],_invocation_parameters['feed'],_invocation_parameters['datacolumn'],_invocation_parameters['keepflags'],_invocation_parameters['width'],_invocation_parameters['timebin'],_invocation_parameters['combine'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

split = _split( )

