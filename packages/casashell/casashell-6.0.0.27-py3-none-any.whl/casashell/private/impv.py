##################### generated by xml-casa (v2) from impv.xml ######################
##################### 362d7c778d9402a21003b21c2c571fd8 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import impv as _impv_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _impv:
    """
    impv ---- Construct a position-velocity image by choosing two points in the direction plane.

    --------- parameter descriptions ---------------------------------------------

    imagename Name of the input image
    outfile   Output image name. If empty, no image is written.
    mode      If "coords", use start and end values. If "length", use center, length, and pa values.
    start     The starting pixel in the direction plane (array of two values).
    end       The ending pixel in the direction plane (array of two values).
    center    The center point in the direction plane (array of two values). If specified, length and pa must also be specified and neither of start nor end may be specified.
    length    The length of the segment in the direction plane. If specified, center and pa must also be specified and neither of start nor end may be specified.
    pa        The position angle of the segment in the direction plane, measured from north through east. If specified, center and length must also be specified and neither of start nor end may be specified.
    width     Width of slice for averaging pixels perpendicular to the slice. Must be an odd positive integer or valid quantity. See help for details.
    unit      Unit for the offset axis in the resulting image. Must be a unit of angular measure.
    overwrite Overwrite the output if it exists?
    region    Region selection. Default is entire image. No selection is permitted in the direction plane.
    chans     Channels to use.  Channels must be contiguous. Default is to use all channels.
    stokes    Stokes planes to use. Planes must be contiguous. Default is to use all stokes.
    mask      Mask to use. Default is none.
    stretch   Stretch the mask if necessary and possible? Default False
    [1;42mRETURNS[1;m      image

    --------- examples -----------------------------------------------------------

    
    PARAMETER SUMMARY
    imagename        Name of the input (CASA, FITS, MIRIAD) image
    outfile          Name of output CASA image. Must be specified.
    mode             Indicates which sets of parameters to use for defining the slice. mode="coords" means use
    start and end parameters. mode="length" means use center, length, and pa parameters to define
    the slice.
    start            The starting pixel in the direction plane (array of two values), such as [20, 5] or ["14h20m20.5s","-30d45m25.4s"].
    Used iff mode="coords".
    end              The ending pixel in the direction plane (array of two values), such as [200, 300].
    Used iff mode="coords".
    center           The center of the slice in the direction plane (array of two values), such as [20, 5] or ["14h20m20.5s","-30d45m25.4s"].
    Used iff mode="length".
    length           The length of the slice in the direction plane. May be specified as a single numerical value, in which
    case it is interpreted as the number of pixels, or as a valid quantity which must be conformant with
    the direction axes units (eg "40arcsec", {"value": 40, "unit": "arcsec"}).
    Used iff mode="length".
    pa               Position angle of the slice, measured from the direction of positive latitude of the positive longitude
    (eg north through east in an equatorial coordinate system). Must be expressed as a valid angular
    quantity (eg "40deg", {"value": 40, "unit": "deg"}).
    Used iff mode="length".
    width            Width of slice for averaging pixels perpendicular to the slice which must be an odd positive integer or
    valid quantity. The averaging using this value occurs after the image has been rotated so the slice lies horizontally.
    An integer value is interpreted as the number of pixels to average.
    A value of 1 means no averaging. A value of 3 means average one pixel on each
    side of the slice and the pixel on the slice. A value of 5 means average 2 pixels
    on each side of the slice and the pixel on the slice, etc. If a quantity (eg. "4arcsec", qa.quantity("4arcsec"))
    is specified, the equivalent number of pixels is calculated, and if necessary, rounded up
    to the next odd integer.
    unit             Allows the user to set the unit for the angular offset axis. Must be a unit of angular
    measure.
    overwrite        If output file is specified, this parameter controls if an already existing file by the
    same name can be overwritten. If true, the user is not prompted, the file
    if it exists is automatically overwritten.
    region           Region specification. Default is to not use a region. If specified,
    the entire direction plane must be specified. If specified do not specify chans or stokes.
    chans            Optional contiguous frequency channel number specification. Default is all channels.
    If specified, do not specify region.
    stokes           Contiguous stokes planes specification. If specified, do not specify region.
    mask             Mask to use. Default is none.
    stretch          Stretch the input mask if necessary and possible. Only used if a mask is specified.
    
    
    Create a position-velocity image. The way the slice is specified is controlled by the mode parameter. When
    mode="coords", start end end are used to specified the points between which a slice is taken in the direction
    coordinate. If mode="length"  center, pa (position angle), and length are used to specify the slice. The spectral
    extent of the resulting image will be that provided by the region specification or the entire spectral range of
    the input image if no region is specified. One may not specify a region in direction space; that is accomplished by
    specifying the slice as described previously. The parameters start and end may be specified as two
    element arrays of numerical values, in which case these values will be interpreted as pixel locations in the input
    image. Alternatively, they may be expressed as arrays of two strings each representing the direction. These strings
    can either represent quantities (eg ["40.5deg", "0.5rad") or be sexigesimal format (eg ["14h20m20.5s","-30d45m25.4s"],
    ["14:20:20.5s","-30.45.25.4"]). In addition, they may be expressed as a single string containing the longitude-like and
    latitude-like values and optionally a reference frame value, eg "J2000 14:20:20.5s -30.45.25.4".The center parameter can
    be specified in the same way. The length parameter may be specified as a single numerical value, in which case it is
    interpreted as the length in pixels, or a valid quantity, in which case it must have units conformant with the
    direction axes units. The pa (position angle) parameter must be specified as a valid quantity with angular units.
    The position angle is interpreted in the usual astronomical sense; eg measured from north through east in an equatorial
    coordinate system. The slice in this case starts at the specified position angle and ends on the opposite side of
    the specified center. Thus pa="45deg" means start at a point at a pa of 45 degrees relative to the specified center and
    end at a point at a pa of 215 degrees relative to the center. Either start/end or center/pa/length must be specified;
    if a parameter from one of these sets is specified, a parameter from the other set may not be specified. In either
    case, the end points of the segment must fail within the input image, and they both must be at least 2 pixels from the
    edge of the input image to facilite rotation (see below).
    
    One may specify a width, which represents the number of pixels centered along and perpendicular
    to the direction slice that are used for averaging along the slice. The width may be specified as an integer, in which
    case it must be positive and odd. Alternatively, it may be specified as a valid quantity string (eg, "4arcsec") or
    quantity record (eg qa.quantity("4arcsec"). In this case, units must be conformant to the direction axes units (usually
    angular units) and the specified quantity will be rounded up, if necessary, to the next highest equivalent odd integer number
    of pixels. The default value of 1 represents no averaging.
    A value of 3 means average one pixel on each side of the slice and the pixel on the slice.
    Note that this width is applied to pixels in the image after it has been rotated (see below for a description
    of the algorithm used).
    
    One may specify the unit for the angular offset axis.
    
    Internally, the image is first rotated, padding if necessary to include relevant pixels that would otherwise
    be excluded by the rotation operation, so that the slice is horizontal, with the starting pixel left of the
    ending pixel. Then, the pixels within the specified width of the slice are averaged and the resulting image is
    written and/or returned. The output image has a linear coordinate in place of the direction coordinate of the
    input image, and the corresponding axis represents angular offset with the center pixel having a value of 0.
    
    The equivalent coordinate system, with a (usually) rotated direction coordinate (eg, RA and Dec) is written
    to the output image as a table record. It can be retrieved using the table tool as shown in the example below.
    
    # create a pv image with the position axis running from ra, dec pixel positions of [45, 50] to [100, 120]
    # in the input image
    impv(imagename="my_spectral_cube.im", outfile="mypv.im", start=[45,50], end=[100,120])
    # analyze the pv image, such as get statistics
    pvstats = imstat("mypv.im")
    #
    # get the alternate coordinate system information
    tb.open("mypv.im")
    alternate_csys_record = tb.getkeyword("misc")["secondary_coordinates"]
    tb.done()
    


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Construct a position-velocity image by choosing two points in the direction plane."""

    __schema = {'imagename': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outfile': {'type': 'cStr'}, 'mode': {'type': 'cStr'}, 'start': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'end': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'center': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'length': {'anyof': [{'type': 'cStr'}, {'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cDict'}]}, 'pa': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'width': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cDict'}]}, 'unit': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'region': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'chans': {'type': 'cStr'}, 'stokes': {'type': 'cStr'}, 'mask': {'type': 'cStr'}, 'stretch': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __width_dflt( self, glb ):
        return int(1)

    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        return int(1)

    def __mode_dflt( self, glb ):
        return 'coords'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'coords'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __mask_dflt( self, glb ):
        return ''

    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __unit_dflt( self, glb ):
        return 'arcsec'

    def __unit( self, glb ):
        if 'unit' in glb: return glb['unit']
        return 'arcsec'

    def __chans_dflt( self, glb ):
        return ''

    def __chans( self, glb ):
        if 'chans' in glb: return glb['chans']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    #--------- return non subparam/when values ---------------------------------------------
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        return ''
    def __end( self, glb ):
        if 'end' in glb: return glb['end']
        return ''

    #--------- return inp/go default --------------------------------------------------
    def __pa_dflt( self, glb ):
        if self.__mode( glb ) == "length": return ""
        return None
    def __center_dflt( self, glb ):
        if self.__mode( glb ) == "length": return ""
        return None
    def __stretch_dflt( self, glb ):
        if self.__mask( glb ) != "": return bool(False)
        return None
    def __region_dflt( self, glb ):
        if self.__chans( glb ) == "": return ""
        return None
    def __end_dflt( self, glb ):
        if self.__mode( glb ) == "coords": return ""
        return None
    def __length_dflt( self, glb ):
        if self.__mode( glb ) == "length": return ""
        return None
    def __overwrite_dflt( self, glb ):
        if self.__outfile( glb ) != "": return bool(False)
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "coords": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __center( self, glb ):
        if 'center' in glb: return glb['center']
        dflt = self.__center_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __length( self, glb ):
        if 'length' in glb: return glb['length']
        dflt = self.__length_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __pa( self, glb ):
        if 'pa' in glb: return glb['pa']
        dflt = self.__pa_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        dflt = self.__overwrite_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __region( self, glb ):
        if 'region' in glb: return glb['region']
        dflt = self.__region_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __stretch( self, glb ):
        if 'stretch' in glb: return glb['stretch']
        dflt = self.__stretch_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __start_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__start( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('start',pre,self.__to_string_(value),post,description))
    def __end_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__end( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'end': value},{'end': self.__schema['end']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('end',pre,self.__to_string_(value),post,description))
    def __center_inp(self):
        out = self.__stdout or sys.stdout
        if self.__center_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__center( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'center': value},{'center': self.__schema['center']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('center',pre,self.__to_string_(value),post,description))
    def __length_inp(self):
        out = self.__stdout or sys.stdout
        if self.__length_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__length( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'length': value},{'length': self.__schema['length']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('length',pre,self.__to_string_(value),post,description))
    def __pa_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pa_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pa( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pa': value},{'pa': self.__schema['pa']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pa',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__width( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __unit_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__unit( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'unit': value},{'unit': self.__schema['unit']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('unit',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        if self.__overwrite_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__overwrite( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))
    def __region_inp(self):
        out = self.__stdout or sys.stdout
        if self.__region_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__region( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'region': value},{'region': self.__schema['region']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('region',pre,self.__to_string_(value),post,description))
    def __chans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chans': value},{'chans': self.__schema['chans']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('chans',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __mask_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mask( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mask',pre,self.__to_string_(value),post,description))
    def __stretch_inp(self):
        out = self.__stdout or sys.stdout
        if self.__stretch_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__stretch( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'stretch': value},{'stretch': self.__schema['stretch']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('stretch',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'mask' in glb: del glb['mask']
        if 'pa' in glb: del glb['pa']
        if 'center' in glb: del glb['center']
        if 'stretch' in glb: del glb['stretch']
        if 'imagename' in glb: del glb['imagename']
        if 'chans' in glb: del glb['chans']
        if 'region' in glb: del glb['region']
        if 'mode' in glb: del glb['mode']
        if 'end' in glb: del glb['end']
        if 'length' in glb: del glb['length']
        if 'unit' in glb: del glb['unit']
        if 'overwrite' in glb: del glb['overwrite']
        if 'start' in glb: del glb['start']
        if 'width' in glb: del glb['width']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__outfile_inp( )
        self.__mode_inp( )
        self.__start_inp( )
        self.__end_inp( )
        self.__center_inp( )
        self.__length_inp( )
        self.__pa_inp( )
        self.__width_inp( )
        self.__unit_inp( )
        self.__overwrite_inp( )
        self.__region_inp( )
        self.__chans_inp( )
        self.__stokes_inp( )
        self.__mask_inp( )
        self.__stretch_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("impv.last"):
                filename = "impv.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, outfile=None, mode=None, start=None, end=None, center=None, length=None, pa=None, width=None, unit=None, overwrite=None, region=None, chans=None, stokes=None, mask=None, stretch=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('impv.pre')
        _postfile = os.path.realpath('impv.last')
        _return_result_ = None
        _arguments = [imagename,outfile,mode,start,end,center,length,pa,width,unit,overwrite,region,chans,stokes,mask,stretch]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if outfile is not None: local_global['outfile'] = outfile
            if mode is not None: local_global['mode'] = mode
            if start is not None: local_global['start'] = start
            if end is not None: local_global['end'] = end
            if width is not None: local_global['width'] = width
            if unit is not None: local_global['unit'] = unit
            if chans is not None: local_global['chans'] = chans
            if stokes is not None: local_global['stokes'] = stokes
            if mask is not None: local_global['mask'] = mask

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['start'] = self.__start( local_global )
            _invocation_parameters['end'] = self.__end( local_global )
            _invocation_parameters['width'] = self.__width( local_global )
            _invocation_parameters['unit'] = self.__unit( local_global )
            _invocation_parameters['chans'] = self.__chans( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['mask'] = self.__mask( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['center'] = self.__center( _invocation_parameters ) if center is None else center
            _invocation_parameters['length'] = self.__length( _invocation_parameters ) if length is None else length
            _invocation_parameters['pa'] = self.__pa( _invocation_parameters ) if pa is None else pa
            _invocation_parameters['overwrite'] = self.__overwrite( _invocation_parameters ) if overwrite is None else overwrite
            _invocation_parameters['region'] = self.__region( _invocation_parameters ) if region is None else region
            _invocation_parameters['stretch'] = self.__stretch( _invocation_parameters ) if stretch is None else stretch

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['end'] = self.__end( self.__globals_( ) )
            _invocation_parameters['center'] = self.__center( self.__globals_( ) )
            _invocation_parameters['length'] = self.__length( self.__globals_( ) )
            _invocation_parameters['pa'] = self.__pa( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['unit'] = self.__unit( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['region'] = self.__region( self.__globals_( ) )
            _invocation_parameters['chans'] = self.__chans( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['stretch'] = self.__stretch( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#impv( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _impv_t( _invocation_parameters['imagename'],_invocation_parameters['outfile'],_invocation_parameters['mode'],_invocation_parameters['start'],_invocation_parameters['end'],_invocation_parameters['center'],_invocation_parameters['length'],_invocation_parameters['pa'],_invocation_parameters['width'],_invocation_parameters['unit'],_invocation_parameters['overwrite'],_invocation_parameters['region'],_invocation_parameters['chans'],_invocation_parameters['stokes'],_invocation_parameters['mask'],_invocation_parameters['stretch'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

impv = _impv( )

