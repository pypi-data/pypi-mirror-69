##################### generated by xml-casa (v2) from partition.xml #################
##################### 5c3184bb965f46461599d93bce700a75 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import partition as _partition_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _partition:
    """
    partition ---- Task to produce Multi-MSs using parallelism

    
    Partition is a task to create a Multi-MS out of an MS. General selection
    parameters are included, and one or all of the various data columns
    (DATA, LAG_DATA and/or FLOAT_DATA, and possibly MODEL_DATA and/or
    CORRECTED_DATA) can be selected.
    
    The partition task creates a Multi-MS in parallel, using the CASA MPI framework.
    The user should start CASA as follows in order to run it in parallel.
    
    1) Start CASA on a single node with 8 engines. The first engine will be used as the
    MPIClient, where the user will see the CASA prompt. All other engines will be used
    as MPIServers and will process the data in parallel.
    mpicasa -n 8 casa --nogui --log2term
    partition(.....)
    
    2) Running on a group of nodes in a cluster.
    mpicasa -hostfile user_hostfile casa ....
    partition(.....)
    
    where user_hostfile contains the names of the nodes and the number of engines to use
    in each one of them. Example:
    pc001234a, slots=5
    pc001234b, slots=4
    
    If CASA is started without mpicasa, it is still possible to create an MMS, but
    the processing will be done in sequential.
    
    A multi-MS is structured to have a reference MS on the top directory and a
    sub-directory called SUBMSS, which contain each partitioned sub-MS. The
    reference MS contains links to the sub-tables of the first sub-MS. The other
    sub-MSs contain a copy of the sub-tables each. A multi-MS looks like this in disk.
    
    ls ngc5921.mms
    ANTENNA           FLAG_CMD     POLARIZATION  SPECTRAL_WINDOW  table.dat
    DATA_DESCRIPTION  HISTORY      PROCESSOR     STATE            table.info
    FEED              OBSERVATION  SORTED_TABLE  SUBMSS           WEATHER
    FIELD             POINTING     SOURCE        SYSCAL
    
    ls ngc5921.mms/SUBMSS/
    ngc5921.0000.ms/  ngc5921.0002.ms/  ngc5921.0004.ms/  ngc5921.0006.ms/
    ngc5921.0001.ms/  ngc5921.0003.ms/  ngc5921.0005.ms/
    
    Inside casapy, one can use the task listpartition to list the information
    from a multi-MS.
    
    When partition processes an MMS in parallel, each sub-MS is processed independently in an engine.
    The log messages of the engines are identified by the string MPIServer-#, where # gives the number
    of the engine running that process. When the task runs sequentially, it shows the MPIClient text
    in the origin of the log messages or does not show anything.
    

    --------- parameter descriptions ---------------------------------------------

    vis             Name of input measurement set
    outputvis       Name of output measurement set
    createmms       Should this create a multi-MS output
    separationaxis  Axis to do parallelization across(scan, spw, baseline, auto)
    numsubms        The number of SubMSs to create (auto or any number)
    flagbackup      Create a backup of the FLAG column in the MMS.
    datacolumn      Which data column(s) to process.
    field           Select field using ID(s) or name(s).
    spw             Select spectral window/channels.
    scan            Select data by scan numbers.
    antenna         Select data based on antenna/baseline.
    correlation     Correlation: '' ==> all, correlation="XX,YY".
    timerange       Select data by time range.
    intent          Select data by scan intent.
    array           Select (sub)array(s) by array ID number.
    uvrange         Select data by baseline length.
    observation     Select by observation ID(s).
    feed            Multi-feed numbers: Not yet implemented.
    disableparallel Create a multi-MS in parallel.
    ddistart        Do not change this parameter. For internal use only.
    taql            Table query for nested selections

    --------- examples -----------------------------------------------------------

    
    
    
    ----- Detailed description of keyword arguments -----
    
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    
    outputvis -- Name of output visibility file
    default: none; example: outputvis='ngc5921.mms'
    
    createmms -- Create a multi-MS as the output.
    default: True
    If False, it will work like the split task and create a
    normal MS, split according to the given data selection parameters.
    Note that, when this parameter is set to False, a cluster
    will not be used.
    
    separationaxis -- Axis to do parallelization across.
    default: 'auto'
    Options: 'scan', 'spw', 'baseline', 'auto'
    
    * The 'auto' option will partition per scan/spw to obtain optimal load balancing with the
    following criteria:
    
    1 - Maximize the scan/spw/field distribution across sub-MSs
    2 - Generate sub-MSs with similar size
    
    * The 'scan' or 'spw' axes will partition the MS into scan or spw. The individual sub-MSs may
    not be balanced with respect to the number of rows.
    
    * The 'baseline' axis is mostly useful for Single-Dish data. This axis will partition the MS
    based on the available baselines. If the user wants only auto-correlations, use the
    antenna selection such as antenna='*&&&' together with this separation axis. Note that in
    if numsubms='auto', partition will try to create as many subMSs as the number of available
    servers in the cluster. If the user wants to have one subMS for each baseline, set the numsubms
    parameter to a number higher than the number of baselines to achieve this.
    
    numsubms -- The number of sub-MSs to create.
    default: 'auto'
    Options: any integer number (example: numsubms=4)
    
    The default 'auto' is to partition using the number of available servers in the cluster.
    If the task is unable to determine the number of running servers, or the user did not start CASA
    using mpicasa, numsubms will use 8 as the default.
    
    Example: Launch CASA with 5 engines, where 4 of them will be used to create the MMS. The first
    engine is used as the MPIClient.
    
    mpicasa -n 5 casa --nogui --log2term
    CASA> partition('uid__A1', outputvis='test.mms')
    
    flagbackup -- Make a backup of the FLAG column of the output MMS. When the
    MMS is created, the .flagversions of the input MS are not transferred,
    therefore it is necessary to re-create it for the new MMS. Note
    that multiple backups from the input MS will not be preserved. This
    will create a single backup of all the flags present in the input
    MS at the time the MMS is created.
    default: True
    
    datacolumn -- Which data column to use when partitioning the MS.
    default='all'; example: datacolumn='data'
    Options: 'data', 'model', 'corrected', 'all',
    'float_data', 'lag_data', 'float_data,data', and
    'lag_data,data'.
    N.B.: 'all' = whichever of the above that are present.
    
    ---- Data selection parameters (see help par.selectdata for more detailed
    information)
    
    field -- Select field using field id(s) or field name(s).
    [run listobs to obtain the list iof d's or names]
    default: ''=all fields If field string is a non-negative
    integer, it is assumed to be a field index
    otherwise, it is assumed to be a field name
    field='0~2'; field ids 0,1,2
    field='0,4,5~7'; field ids 0,4,5,6,7
    field='3C286,3C295'; fields named 3C286 and 3C295
    field = '3,4C*'; field id 3, all names starting with 4C
    
    spw -- Select spectral window/channels
    default: ''=all spectral windows and channels
    spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
    spw='<2';  spectral windows less than 2 (i.e. 0,1)
    spw='0:5~61'; spw 0, channels 5 to 61
    spw='0,10,3:3~45'; spw 0,10 all channels, spw 3 - chans 3 to 45.
    spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
    spw = '*:3~64'  channels 3 through 64 for all sp id's
    spw = ' :3~64' will NOT work.
    spw = '*:0;60~63'  channel 0 and channels 60 to 63 for all IFs
    ';' needed to separate different channel ranges in one spw
    spw='0:0~10;15~60'; spectral window 0 with channels 0-10,15-60
    spw='0:0~10,1:20~30,2:1;2;4'; spw 0, channels 0-10,
    spw 1, channels 20-30, and spw 2, channels, 1, 2 and 4
    
    antenna -- Select data based on antenna/baseline
    default: '' (all)
    Non-negative integers are assumed to be antenna indices, and
    anything else is taken as an antenna name.
    
    Examples:
    antenna='5&6': baseline between antenna index 5 and index 6.
    antenna='VA05&VA06': baseline between VLA antenna 5 and 6.
    antenna='5&6;7&8': baselines 5-6 and 7-8
    antenna='5': all baselines with antenna 5
    antenna='5,6,10': all baselines including antennas 5, 6, or 10
    antenna='5,6,10&': all baselines with *only* antennas 5, 6, or
    10.  (cross-correlations only.  Use &&
    to include autocorrelations, and &&&
    to get only autocorrelations.)
    antenna='!ea03,ea12,ea17': all baselines except those that
    include EVLA antennas ea03, ea12, or
    ea17.
    
    timerange -- Select data based on time range:
    default = '' (all); examples,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: if YYYY/MM/DD is missing date, timerange defaults to the
    first day in the dataset
    timerange='09:14:0~09:54:0' picks 40 min on first day
    timerange='25:00:00~27:30:00' picks 1 hr to 3 hr 30min
    on next day
    timerange='09:44:00' data within one integration of time
    timerange='>10:24:00' data after this time
    
    array -- (Sub)array number range
    default: ''=all
    
    uvrange -- Select data within uvrange (default units meters)
    default: ''=all; example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
    uvrange='>4klambda';uvranges greater than 4 kilo-lambda
    uvrange='0~1000km'; uvrange in kilometers
    
    scan -- Scan number range
    default: ''=all
    
    observation -- Select by observation ID(s)
    default: ''=all
    
    
    ------ EXAMPLES ------
    
    1) Create a Multi-MS of some spws, partitioned per spw. The MS contains 16 spws.
    partition('uid001.ms', outpuvis='source.mms', spw='1,3~10', separationaxis='spw')
    
    2) Create a Multi-MS but select only the first channels of all spws. Do not back up the FLAG
    column.
    partition('uid0001.ms', outputvis='fechans.mms', spw='*:1~10', flagbackup=False)
    
    3) Create a Multi-MS using both separation axes.
    partition('uid0001.ms', outputvis='myuid.mms', createmms=True, separationaxis='auto')
    
    4) Create a single-dish Multi-MS using the baseline axis only for the auto-correlations.
    partition('uid0001.ms', outputvis='myuid.mms', createmms=True, separationaxis='baseline', antenna='*&&&')


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Task to produce Multi-MSs using parallelism"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cStr'}, 'createmms': {'type': 'cBool'}, 'separationaxis': {'type': 'cStr'}, 'numsubms': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'flagbackup': {'type': 'cBool'}, 'datacolumn': {'type': 'cStr'}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'correlation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'array': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'feed': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'disableparallel': {'type': 'cBool'}, 'ddistart': {'type': 'cInt'}, 'taql': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __feed_dflt( self, glb ):
        return ''

    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __correlation_dflt( self, glb ):
        return ''

    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __array_dflt( self, glb ):
        return ''

    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        return ''

    def __observation_dflt( self, glb ):
        return ''

    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        return ''

    def __datacolumn_dflt( self, glb ):
        return 'all'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'all'

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __uvrange_dflt( self, glb ):
        return ''

    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __createmms_dflt( self, glb ):
        return True

    def __createmms( self, glb ):
        if 'createmms' in glb: return glb['createmms']
        return True



    #--------- return inp/go default --------------------------------------------------
    def __numsubms_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return "auto"
        if self.__createmms( glb ) == bool(False): return "auto"
        return None
    def __disableparallel_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return bool(False)
        if self.__createmms( glb ) == bool(False): return bool(False)
        return None
    def __ddistart_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return int(-1)
        if self.__createmms( glb ) == bool(False): return int(-1)
        return None
    def __flagbackup_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return bool(True)
        if self.__createmms( glb ) == bool(False): return bool(True)
        return None
    def __taql_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return ""
        if self.__createmms( glb ) == bool(False): return ""
        return None
    def __separationaxis_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return "auto"
        if self.__createmms( glb ) == bool(False): return "auto"
        return None

    #--------- return subparam values -------------------------------------------------
    def __separationaxis( self, glb ):
        if 'separationaxis' in glb: return glb['separationaxis']
        dflt = self.__separationaxis_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __numsubms( self, glb ):
        if 'numsubms' in glb: return glb['numsubms']
        dflt = self.__numsubms_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __flagbackup( self, glb ):
        if 'flagbackup' in glb: return glb['flagbackup']
        dflt = self.__flagbackup_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __disableparallel( self, glb ):
        if 'disableparallel' in glb: return glb['disableparallel']
        dflt = self.__disableparallel_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __ddistart( self, glb ):
        if 'ddistart' in glb: return glb['ddistart']
        dflt = self.__ddistart_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __taql( self, glb ):
        if 'taql' in glb: return glb['taql']
        dflt = self.__taql_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __outputvis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('outputvis',pre,self.__to_string_(value),post,description))
    def __createmms_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__createmms( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'createmms': value},{'createmms': self.__schema['createmms']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('createmms',pre,self.__to_string_(value),post,description))
    def __separationaxis_inp(self):
        out = self.__stdout or sys.stdout
        if self.__separationaxis_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__separationaxis( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'separationaxis': value},{'separationaxis': self.__schema['separationaxis']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('separationaxis',pre,self.__to_string_(value),post,description))
    def __numsubms_inp(self):
        out = self.__stdout or sys.stdout
        if self.__numsubms_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__numsubms( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'numsubms': value},{'numsubms': self.__schema['numsubms']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('numsubms',pre,self.__to_string_(value),post,description))
    def __flagbackup_inp(self):
        out = self.__stdout or sys.stdout
        if self.__flagbackup_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__flagbackup( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'flagbackup': value},{'flagbackup': self.__schema['flagbackup']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('flagbackup',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __correlation_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__correlation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('correlation',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__array( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __uvrange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__uvrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('uvrange',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__observation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __feed_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__feed( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-18.18s = %s%-23.22s%s # %-.60s\n' % ('feed',pre,self.__to_string_(value),post,description))
    def __disableparallel_inp(self):
        out = self.__stdout or sys.stdout
        if self.__disableparallel_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__disableparallel( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'disableparallel': value},{'disableparallel': self.__schema['disableparallel']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('disableparallel',pre,self.__to_string_(value),post,description))
    def __ddistart_inp(self):
        out = self.__stdout or sys.stdout
        if self.__ddistart_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__ddistart( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'ddistart': value},{'ddistart': self.__schema['ddistart']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('ddistart',pre,self.__to_string_(value),post,description))
    def __taql_inp(self):
        out = self.__stdout or sys.stdout
        if self.__taql_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__taql( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'taql': value},{'taql': self.__schema['taql']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-15.15s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('taql',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'numsubms' in glb: del glb['numsubms']
        if 'intent' in glb: del glb['intent']
        if 'createmms' in glb: del glb['createmms']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'disableparallel' in glb: del glb['disableparallel']
        if 'array' in glb: del glb['array']
        if 'ddistart' in glb: del glb['ddistart']
        if 'correlation' in glb: del glb['correlation']
        if 'feed' in glb: del glb['feed']
        if 'uvrange' in glb: del glb['uvrange']
        if 'observation' in glb: del glb['observation']
        if 'flagbackup' in glb: del glb['flagbackup']
        if 'spw' in glb: del glb['spw']
        if 'taql' in glb: del glb['taql']
        if 'timerange' in glb: del glb['timerange']
        if 'separationaxis' in glb: del glb['separationaxis']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__createmms_inp( )
        self.__separationaxis_inp( )
        self.__numsubms_inp( )
        self.__flagbackup_inp( )
        self.__datacolumn_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__antenna_inp( )
        self.__correlation_inp( )
        self.__timerange_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__uvrange_inp( )
        self.__observation_inp( )
        self.__feed_inp( )
        self.__disableparallel_inp( )
        self.__ddistart_inp( )
        self.__taql_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("partition.last"):
                filename = "partition.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, outputvis=None, createmms=None, separationaxis=None, numsubms=None, flagbackup=None, datacolumn=None, field=None, spw=None, scan=None, antenna=None, correlation=None, timerange=None, intent=None, array=None, uvrange=None, observation=None, feed=None, disableparallel=None, ddistart=None, taql=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('partition.pre')
        _postfile = os.path.realpath('partition.last')
        _return_result_ = None
        _arguments = [vis,outputvis,createmms,separationaxis,numsubms,flagbackup,datacolumn,field,spw,scan,antenna,correlation,timerange,intent,array,uvrange,observation,feed,disableparallel,ddistart,taql]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if createmms is not None: local_global['createmms'] = createmms
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if antenna is not None: local_global['antenna'] = antenna
            if correlation is not None: local_global['correlation'] = correlation
            if timerange is not None: local_global['timerange'] = timerange
            if intent is not None: local_global['intent'] = intent
            if array is not None: local_global['array'] = array
            if uvrange is not None: local_global['uvrange'] = uvrange
            if observation is not None: local_global['observation'] = observation
            if feed is not None: local_global['feed'] = feed

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['createmms'] = self.__createmms( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['correlation'] = self.__correlation( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['array'] = self.__array( local_global )
            _invocation_parameters['uvrange'] = self.__uvrange( local_global )
            _invocation_parameters['observation'] = self.__observation( local_global )
            _invocation_parameters['feed'] = self.__feed( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['separationaxis'] = self.__separationaxis( _invocation_parameters ) if separationaxis is None else separationaxis
            _invocation_parameters['numsubms'] = self.__numsubms( _invocation_parameters ) if numsubms is None else numsubms
            _invocation_parameters['flagbackup'] = self.__flagbackup( _invocation_parameters ) if flagbackup is None else flagbackup
            _invocation_parameters['disableparallel'] = self.__disableparallel( _invocation_parameters ) if disableparallel is None else disableparallel
            _invocation_parameters['ddistart'] = self.__ddistart( _invocation_parameters ) if ddistart is None else ddistart
            _invocation_parameters['taql'] = self.__taql( _invocation_parameters ) if taql is None else taql

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['createmms'] = self.__createmms( self.__globals_( ) )
            _invocation_parameters['separationaxis'] = self.__separationaxis( self.__globals_( ) )
            _invocation_parameters['numsubms'] = self.__numsubms( self.__globals_( ) )
            _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['disableparallel'] = self.__disableparallel( self.__globals_( ) )
            _invocation_parameters['ddistart'] = self.__ddistart( self.__globals_( ) )
            _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-15s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#partition( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _partition_t( _invocation_parameters['vis'],_invocation_parameters['outputvis'],_invocation_parameters['createmms'],_invocation_parameters['separationaxis'],_invocation_parameters['numsubms'],_invocation_parameters['flagbackup'],_invocation_parameters['datacolumn'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['scan'],_invocation_parameters['antenna'],_invocation_parameters['correlation'],_invocation_parameters['timerange'],_invocation_parameters['intent'],_invocation_parameters['array'],_invocation_parameters['uvrange'],_invocation_parameters['observation'],_invocation_parameters['feed'],_invocation_parameters['disableparallel'],_invocation_parameters['ddistart'],_invocation_parameters['taql'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

partition = _partition( )

