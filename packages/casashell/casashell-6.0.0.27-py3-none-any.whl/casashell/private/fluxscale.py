##################### generated by xml-casa (v2) from fluxscale.xml #################
##################### 9ece0abc9bf57aeb38dbb5c2eb4e6df5 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import fluxscale as _fluxscale_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _fluxscale:
    """
    fluxscale ---- Bootstrap the flux density scale from standard calibrators

    
    Bootstrap the flux density scale from standard calibrators.
    

    --------- parameter descriptions ---------------------------------------------

    vis           Name of input visibility file
                  Default: none
                  
                     Example: vis='ngc5921.ms'
    caltable      Name of input calibration table
                  Default: none
                  
                     Example: caltable='ngc5921.gcal'. This cal
                     table was obtained from task gaincal.=
    fluxtable     Name of output, flux-scaled calibration table (required)
                  Default: none
                  
                     Example: fluxtable='ngc5921.gcal2'
                  
                  The gains in this table have been adjusted by the
                  derived flux density each calibrator.  The
                  MODEL_DATA column has NOT been updated for the
                  flux density of the calibrator.  Use setjy to do
                  this if it is a point source.
    reference     Reference field name(s) (transfer flux scale FROM)
                  Default: none
                  
                     Example: reference='1328+307'
                  
                  The names of the fields with a known flux
                  densities or visibilities that have been placed
                  in the MODEL column by setjy or ft for a model
                  not in the CASA system. The syntax is similar to
                  field.  Hence field index or names can be used.
    transfer      Transfer field name(s) (transfer flux scale TO)
                  Default: '' (all sources in caltable that are not
                  specified as reference sources.  Do not include
                  unknown target sources)
                  
                  The names of the fields with unknown flux
                  densities. These should be point-like calibrator
                  sources The syntax is similar to field.  Hence
                  source index or names can be used.
                  
                     Examples: transfer='1445+099, 3C84'; transfer
                     = '0,4'
                  
                  NOTE: All fields in reference and transfer must
                  have solutions in the caltable.
    listfile      Name of listfile that contains the fit information.
                  Default: '' (no fit listfile will be created)
                  
                  The list file contains the flux density, flux
                  density error, S/N, and number of solutions (all
                  antennas and feeds) for each spectral window.  
                  NOTE: The nominal spectral window frequencies
                  will be included in the future.
    append        Append fluxscaled solutions to the fluxtable?
                  Default: False (the fluxtable must not exist)
                  Options: False|True
    refspwmap     Vector of spectral windows enabling scaling across
                  spectral windows
                  Default: [-1] (none)
                  
                     Example with 4 spectral windows:
                     If the reference fields were observed only in
                     spw=1 and 3, and the transfer fields were
                     observed in all 4 spws (0,1,2,3), specify
                     refspwmap=[1,1,3,3]. This will ensure that
                     transfer fields observed in spws 0,1,2,3 will
                     be referenced to reference field solutions
                     only in spw 1 or 3.
    gainthreshold Threshold in the input gain solutions to be used in % deviation from median values.
                  Default: -1 (no threshold)
                  
                     Example: gainthreshold=0.15 (only used the
                     gain solutions within 15% (inclusive) of the
                     median gain value (per field and per spw).
    antenna       Select data based on antenna/baseline
                                     Subparameter of antenna
                                     Default: '' (all)
                  
                                     If antenna string is a non-negative integer, it
                                     is assumed an antenna index, otherwise, it is
                                     assumed as an antenna name
                  
                                         Examples: 
                                         antenna='5&6'; baseline between antenna
                                         index 5 and index 6.
                                         antenna='VA05&VA06'; baseline between VLA
                                         antenna 5 and 6.
                                         antenna='5&6;7&8'; baselines with
                                         indices 5-6 and 7-8
                                         antenna='5'; all baselines with antenna index
                                         5
                                         antenna='05'; all baselines with antenna
                                         number 05 (VLA old name)
                                         antenna='5,6,10'; all baselines with antennas
                                         5,6,10 index numbers
    timerange     Select data based on time range
                  Subparameter of antenna
                  Default = '' (all)
                  
                     Examples:
                     timerange =
                     'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                     (Note: if YYYY/MM/DD is missing date defaults
                     to first day in data set.)
                     timerange='09:14:0~09:54:0' picks 40 min on
                     first day 
                     timerange= '25:00:00~27:30:00' picks 1 hr to 3
                     hr 30min on NEXT day
                     timerange='09:44:00' pick data within one
                     integration of time
                     timerange='>10:24:00' data after this time
    scan          Scan number range
                  Subparameter of antenna
                  Default: '' = all
    incremental   Create an incremental caltable containing only gain
                  correction factors ( flux density= 1/(gain correction factor)**2)?
                  Default: False
                  Options: False|True
                  
                     Example: incremental=True (output a caltable
                     containing flux scale factors.)
                  
                  NOTE: If you use the incremental option, note
                  that BOTH this incremental fluxscale table AND an
                  amplitude vs. time table should be supplied in
                  applycal.
    fitorder      Polynomial order of the spectral fitting for valid flux
                  densities
                  Default: 1
                  
                  It falls back to a lower fitorder if there are
                  not enough solutions to fit with the requested
                  fitorder.
    display       Display statistics and/or spectral fitting results.
                  Default: False
                  Options: False|True
                  
                  Currently only a histogram of the correction
                  factors to derive the final flux density for each
                  spectral window will be plotted.

    --------- examples -----------------------------------------------------------

    
    For more information, see the task pages of fluxscale in CASA Docs:
    
    https://casa.nrao.edu/casadocs/
    


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Bootstrap the flux density scale from standard calibrators"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cStr'}, 'fluxtable': {'type': 'cStr'}, 'reference': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'transfer': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'listfile': {'type': 'cStr'}, 'append': {'type': 'cBool'}, 'refspwmap': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'gainthreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'antenna': {'type': 'cStr'}, 'timerange': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'incremental': {'type': 'cBool'}, 'fitorder': {'type': 'cInt'}, 'display': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __display_dflt( self, glb ):
        return False

    def __display( self, glb ):
        if 'display' in glb: return glb['display']
        return False

    def __listfile_dflt( self, glb ):
        return ''

    def __listfile( self, glb ):
        if 'listfile' in glb: return glb['listfile']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __incremental_dflt( self, glb ):
        return False

    def __incremental( self, glb ):
        if 'incremental' in glb: return glb['incremental']
        return False

    def __gainthreshold_dflt( self, glb ):
        return float(-1.0)

    def __gainthreshold( self, glb ):
        if 'gainthreshold' in glb: return glb['gainthreshold']
        return float(-1.0)

    def __refspwmap_dflt( self, glb ):
        return [ int(-1) ]

    def __refspwmap( self, glb ):
        if 'refspwmap' in glb: return glb['refspwmap']
        return [ int(-1) ]

    def __transfer_dflt( self, glb ):
        return [  ]

    def __transfer( self, glb ):
        if 'transfer' in glb: return glb['transfer']
        return [  ]

    def __fitorder_dflt( self, glb ):
        return int(1)

    def __fitorder( self, glb ):
        if 'fitorder' in glb: return glb['fitorder']
        return int(1)

    def __append_dflt( self, glb ):
        return False

    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        return False

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __reference_dflt( self, glb ):
        return [  ]

    def __reference( self, glb ):
        if 'reference' in glb: return glb['reference']
        return [  ]

    def __fluxtable_dflt( self, glb ):
        return ''

    def __fluxtable( self, glb ):
        if 'fluxtable' in glb: return glb['fluxtable']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __timerange_dflt( self, glb ):
        if self.__antenna( glb ) != "": return ""
        return None
    def __scan_dflt( self, glb ):
        if self.__antenna( glb ) != "": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __caltable_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of input calibration table'
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('caltable',pre,self.__to_string_(value),post,description))
    def __fluxtable_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of output, flux-scaled calibration table (required)'
        value = self.__fluxtable( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'fluxtable': value},{'fluxtable': self.__schema['fluxtable']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('fluxtable',pre,self.__to_string_(value),post,description))
    def __reference_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Reference field name(s) (transfer flux scale FROM)'
        value = self.__reference( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'reference': value},{'reference': self.__schema['reference']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('reference',pre,self.__to_string_(value),post,description))
    def __transfer_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Transfer field name(s) (transfer flux scale TO), \'\' -> all'
        value = self.__transfer( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'transfer': value},{'transfer': self.__schema['transfer']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('transfer',pre,self.__to_string_(value),post,description))
    def __listfile_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of listfile that contains the fit information.  Default is '' (no file).'
        value = self.__listfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'listfile': value},{'listfile': self.__schema['listfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('listfile',pre,self.__to_string_(value),post,description))
    def __append_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Append solutions?'
        value = self.__append( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('append',pre,self.__to_string_(value),post,description))
    def __refspwmap_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Scale across spectral window boundaries'
        value = self.__refspwmap( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'refspwmap': value},{'refspwmap': self.__schema['refspwmap']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('refspwmap',pre,self.__to_string_(value),post,description))
    def __gainthreshold_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Threshold (% deviation from the median) on gain amplitudes to be used in the flux scale calculation'
        value = self.__gainthreshold( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'gainthreshold': value},{'gainthreshold': self.__schema['gainthreshold']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('gainthreshold',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Select data based on antenna/baseline'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __incremental_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Incremental caltable'
        value = self.__incremental( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'incremental': value},{'incremental': self.__schema['incremental']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('incremental',pre,self.__to_string_(value),post,description))
    def __fitorder_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Order of spectral fitting'
        value = self.__fitorder( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'fitorder': value},{'fitorder': self.__schema['fitorder']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('fitorder',pre,self.__to_string_(value),post,description))
    def __display_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Display some statistics of flux scaling'
        value = self.__display( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'display': value},{'display': self.__schema['display']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('display',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'reference' in glb: del glb['reference']
        if 'gainthreshold' in glb: del glb['gainthreshold']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'fitorder' in glb: del glb['fitorder']
        if 'transfer' in glb: del glb['transfer']
        if 'refspwmap' in glb: del glb['refspwmap']
        if 'fluxtable' in glb: del glb['fluxtable']
        if 'listfile' in glb: del glb['listfile']
        if 'caltable' in glb: del glb['caltable']
        if 'timerange' in glb: del glb['timerange']
        if 'incremental' in glb: del glb['incremental']
        if 'display' in glb: del glb['display']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__fluxtable_inp( )
        self.__reference_inp( )
        self.__transfer_inp( )
        self.__listfile_inp( )
        self.__append_inp( )
        self.__refspwmap_inp( )
        self.__gainthreshold_inp( )
        self.__antenna_inp( )
        self.__timerange_inp( )
        self.__scan_inp( )
        self.__incremental_inp( )
        self.__fitorder_inp( )
        self.__display_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("fluxscale.last"):
                filename = "fluxscale.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, caltable=None, fluxtable=None, reference=None, transfer=None, listfile=None, append=None, refspwmap=None, gainthreshold=None, antenna=None, timerange=None, scan=None, incremental=None, fitorder=None, display=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('fluxscale.pre')
        _postfile = os.path.realpath('fluxscale.last')
        _return_result_ = None
        _arguments = [vis,caltable,fluxtable,reference,transfer,listfile,append,refspwmap,gainthreshold,antenna,timerange,scan,incremental,fitorder,display]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if fluxtable is not None: local_global['fluxtable'] = fluxtable
            if reference is not None: local_global['reference'] = reference
            if transfer is not None: local_global['transfer'] = transfer
            if listfile is not None: local_global['listfile'] = listfile
            if append is not None: local_global['append'] = append
            if refspwmap is not None: local_global['refspwmap'] = refspwmap
            if gainthreshold is not None: local_global['gainthreshold'] = gainthreshold
            if antenna is not None: local_global['antenna'] = antenna
            if incremental is not None: local_global['incremental'] = incremental
            if fitorder is not None: local_global['fitorder'] = fitorder
            if display is not None: local_global['display'] = display

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['fluxtable'] = self.__fluxtable( local_global )
            _invocation_parameters['reference'] = self.__reference( local_global )
            _invocation_parameters['transfer'] = self.__transfer( local_global )
            _invocation_parameters['listfile'] = self.__listfile( local_global )
            _invocation_parameters['append'] = self.__append( local_global )
            _invocation_parameters['refspwmap'] = self.__refspwmap( local_global )
            _invocation_parameters['gainthreshold'] = self.__gainthreshold( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['incremental'] = self.__incremental( local_global )
            _invocation_parameters['fitorder'] = self.__fitorder( local_global )
            _invocation_parameters['display'] = self.__display( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['fluxtable'] = self.__fluxtable( self.__globals_( ) )
            _invocation_parameters['reference'] = self.__reference( self.__globals_( ) )
            _invocation_parameters['transfer'] = self.__transfer( self.__globals_( ) )
            _invocation_parameters['listfile'] = self.__listfile( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['refspwmap'] = self.__refspwmap( self.__globals_( ) )
            _invocation_parameters['gainthreshold'] = self.__gainthreshold( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['incremental'] = self.__incremental( self.__globals_( ) )
            _invocation_parameters['fitorder'] = self.__fitorder( self.__globals_( ) )
            _invocation_parameters['display'] = self.__display( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#fluxscale( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _fluxscale_t( _invocation_parameters['vis'],_invocation_parameters['caltable'],_invocation_parameters['fluxtable'],_invocation_parameters['reference'],_invocation_parameters['transfer'],_invocation_parameters['listfile'],_invocation_parameters['append'],_invocation_parameters['refspwmap'],_invocation_parameters['gainthreshold'],_invocation_parameters['antenna'],_invocation_parameters['timerange'],_invocation_parameters['scan'],_invocation_parameters['incremental'],_invocation_parameters['fitorder'],_invocation_parameters['display'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

fluxscale = _fluxscale( )

