##################### generated by xml-casa (v2) from flagdata.xml ##################
##################### 9143e3752cde49e0a24895596bdd7770 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import flagdata as _flagdata_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _flagdata:
    """
    flagdata ---- All-purpose flagging task based on data-selections and flagging modes/algorithms.

    
    This task can flag a Measurement Set or a calibration table. It has
    two main types of operation. One type will read the parameters from
    the interface and flag using any of the various available modes. The
    other type will read the commands from a text file, a list of files or
    a Python list of strings, containing a list of flag commands.
    
    It is also possible to only save the parameters set in the interface
    without flagging. The parameters can be saved in the FLAG_CMD
    sub-table or in a text file. Note that when saving to an external
    file, the parameters will be appended to the given file.
    
    The current flags can be automatically backed up before applying new
    flags if the parameter flagbackup is set. Previous flag versions can
    be recovered using the flagmanager task.
    
    Flagdata can also flag many types of calibration tables. For detailed
    information, see the task pages of flagdata in CASA Docs
    (https://casa.nrao.edu/casadocs/)

    --------- parameter descriptions ---------------------------------------------

    vis                Name of input visibility file
                       Default: none
                       
                          Example: vis='ngc5921.ms'
    mode               Flagging mode
                                           Default: 'manual'
                                           Options: 'list', 'manual', 'clip', 'quack',
                                           'shadow', 'elevation', 'tfcrop', 'rflag',
                                           'antint', 'extend', 'unflag', 'summary'
                       
                       
                                           * 'list': Flag according to the data selection
                                             and flag commands specified in the input
                                             list. The input list may come from a text file,
                                             a list of text files or from a Python list of
                                             strings. Each input line may contain data
                                             selection parameters and any parameter
                                             specific to the mode given in the line. Default
                                             values will be used for the parameters that are
                                             not present in the line. Each line will be
                                             taken as a command to the task. If data is
                                             pre-selected using any of the selection
                                             parameters, then flagging will apply only to
                                             that subset of the MS.
                                                          
                                             For optimization and whenever possible, the
                                             task will create a union of the data selection
                                             parameters present in the list and select only
                                             that portion of the MS.
                       
                                             NOTE1: the flag commands will be applied only
                                             when action='apply'. If action='calculate' the
                                             flags will be calculated, but not applied. This
                                             is useful if display is set to something other
                                             than 'none'. If action='' or 'none', the flag
                                             commands will not be applied either. An empty
                                             action is useful only to save the parameters of
                                             the list to a file or to the FLAG_CMD
                                             sub-table.
                       
                                             NOTE2: In list mode the parameter
                                             quackincrement=True is not supported as part of
                                             any quack flag command, unless it is the first
                                             command of the list. See more about this in the
                                             quack mode section of this help.
                       
                       
                                           * 'manual': Flag according to the data selection
                                             specified. This is the default mode 
                       
                       
                                           * 'clip': Clip data according to values of the
                                             following subparameters. The polarization
                                             expression is given by the correlation
                                             parameter. For calibration tables, the
                                             solutions are also given by the correlation
                                             parameter.
                       
                       
                                           * 'quack': Option to remove specified part of
                                             scan beginning/end.
                       
                       
                                           * 'shadow': Option to flag data of shadowed
                                             antennas. This mode is not available for cal
                                             tables.
                                       
                                             All antennas in the antenna-subtable of the MS
                                             (and the corresponding diameters) will be
                                             considered for shadow-flag calculations. For a
                                             given timestep, an antenna is flagged if any of
                                             its baselines (projected onto the uv-plane) is
                                             shorter than  radius_1 + radius_2 -
                                             tolerance. The value of 'w' is used to
                                             determine which antenna is behind the
                                             other. The phase-reference center is used for
                                             antenna-pointing direction. 
                       
                       
                                           * 'elevation': Option to flag based on antenna
                                             elevation. This mode is not available for cal
                                             tables.
                       
                       
                                           * 'tfcrop': Flag using the TFCrop autoflag
                                             algorithm.
                       
                                             For each field, spw, timerange (specified by
                                             ntime), and baseline, 
                                             (1) Average visibility amplitudes along time
                                             dimension to form an average spectrum
                                             (2) Calculate a robust piece-wise polynomial
                                             fit for the band-shape at the base of RFI
                                             spikes. Calculate 'stddev' of (data - fit).
                                             (3) Flag points deviating from the fit by more
                                             than N-stddev
                                             (4) Repeat (1-3) along the other dimension.
                       
                                             This algorithm is designed to operate on
                                             un-calibrated data (step (2)), as well as
                                             calibrated data. It is recommended to extend
                                             the flags after running this algorithm. See the
                                             sub-parameter extendflags below.
                       
                       
                                           * 'rflag': Detect outliers based on the RFlag
                                             algorithm (ref. E.Greisen, AIPS, 2011). The
                                             polarization expression is given by the
                                             correlation parameter.
                       
                                             Iterate through the data in chunks of time.
                                             For each chunk, calculate local statistics, and
                                             apply flags based on user supplied (or
                                             auto-calculated) thresholds.
                       
                                             Step 1 : Time analysis (for each channel)
                                               -- calculate local rms of real and imag
                                               visibilities, within a sliding time window
                                               -- calculate the median rms across time
                                               windows, deviations of local rms from this
                                               median, and the median deviation 
                                               -- flag if local rms is larger than
                                               timedevscale x (medianRMS + medianDev)
                       
                                             Step 2 : Spectral analysis (for each time)
                                               -- calculate avg of real and imag
                                               visibilities and their rms across channels
                                               -- calculate the deviation of each channel
                                               from this avg, and the median-deviation
                                               -- flag if deviation is larger than
                                               freqdevscale x medianDev
                       
                                             It is recommended to extend the flags after
                                             running this algorithm. See the sub-parameter
                                             extendflags below.
                       
                                             Note that by default the flag implementation in
                                             CASA is able to calculate the thresholds and
                                             apply them on-the-fly (OTF). There is a
                                             significant performancegain with this approach,
                                             as the visibilities don't have to be read
                                             twice,and therefore is highly
                                             recommended. Otherwise it is possible
                                             toreproduce the AIPS usage pattern by doing a
                                             first run with 'calculate' mode and a second
                                             run with 'apply' mode. The advantage of this
                                             approach is that the thresholdsare calculated
                                             using the data from all scans, instead of
                                             calculating them for one scan only.
                       
                                             For more information and examples of 'rflag',
                                             see the task pages of rflag in CASA Docs
                                             (https://casa.nrao.edu/casadocs/)
                                             
                       
                                           * 'antint': Flag integrations if all baselines to
                                             a specified antenna are flagged
                       
                                             This mode flag all integrations in which a
                                             specified antenna is flagged. This mode
                                             operates for an spectral window. It flags any
                                             integration in which all baselines to a
                                             specified antenna are flagged, but only if this
                                             condition is satisfied in a fraction of
                                             channels within the spectral window of interest
                                             greater than a nominated fraction. For
                                             simplicity, it assumes that all polarization
                                             products must be unflagged for a baseline to be
                                             deemed unflagged. The antint mode implements
                                             the flagging approach introduced in
                                             'antintflag'
                                             (https://doi.org/10.5281/zenodo.163546)
                       
                                             The motivating application for introducing this
                                             mode is removal of data that will otherwise
                                             lead to changes in reference antenna during
                                             gain calibration, which will in turn lead to
                                             corrupted polarization.
                       
                       
                                           * 'extend': Extend and/or grow flags beyond what
                                             the basic algorithms detect. This mode will
                                             extend the accumulated flags available in the
                                             MS, regardless of which algorithm created them.
                       
                                             It is recommended that any autoflag (tfcrop,
                                             rflag) algorithm be followed up by a flag
                                             extension.
                                               
                                             Extensions will apply only within the selected
                                             data, according to the settings of
                                             extendpols,growtime,growfreq,growaround,
                                             flagneartime,flagnearfreq.
                                              
                                             Note : Runtime summary counts in the logger can
                                             sometimes report larger flag percentages than
                                             what is actually flagged. This is because
                                             extensions onto already-flagged data-points are
                                             counted as new flags. An accurate flag count
                                             can be obtained via the summary mode.
                       
                       
                                           * 'unflag': Unflag according to the data
                                             selection specified.
                       
                       
                                           * 'summary': List the number of rows and flagged
                                             data points for the MS's meta-data. The
                                             resulting summary will be returned as a Python
                                             dictionary.
    autocorr           Flag only the auto-correlations?
                       Subparameter of mode='manual'
                       Default: False
                       Options: False|True
                       
                       NOTE: this parameter is only active when set to
                       True. If set to False it does NOT mean "do not
                       flag auto-correlations". When set to True, it
                       will only flag data from a processor of type
                       CORRELATOR.
    inpfile            Input ASCII file, list of files or Python list of strings
                       with flag commands.
                       Subparameter of mode='list'
                       Default: ''
                       Options: [] with flag commands or 
                                [] with filenames or 
                                '' with a filename.
                       
                       The parser will be strict and accept only valid
                       flagdata parameters in the list. The parser
                       evaluates the commands in the list and considers
                       only existing Python types.It will check each
                       parameter name and type and exit with an error if
                       any of them is wrong. 
                       
                       NOTE: There should be no whitespace between
                       KEY=VALUE since the parser first breaks command
                       lines on whitespace, then on "=". Use only one
                       whitespace to separate the parameters (no
                       commas).
    reason             Select flag commands based on REASON(s)
                       Subparameter of mode='list'
                       Default: 'any' (all flags regardless of reason)
                       Can be a string, or list of strings
                       
                          Examples: 
                          reason='FOCUS_ERROR'
                          reason=['FOCUS_ERROR','SUBREFLECTOR_ERROR']
                       
                       If inpfile is a list of files, the reasons given
                       in this parameter will apply to all the files.
                       
                       NOTE: what is within the string is literally
                       matched, e.g. reason='' matches only blank
                       reasons, and reason =
                       'FOCUS_ERROR,SUBREFLECTOR_ERROR' matches this
                       compound reason string only.
    tbuff              A time buffer or list of time buffers to pad the
                       timerange parameters in flag commands.
                       Subparameter of mode='list'
                       Default: 0.0 (it will not apply any time padding)
                       
                       When a list of 2 time buffers is given, it will
                       subtract the first value from the lower time and
                       the second value will be added to the upper time
                       in the range. The 2 time buffer values can be
                       different, allowing to have an irregular time
                       buffer padding to time ranges. If the list
                       contains only one time buffer, it will use it to
                       subtract from t0 and add to t1. If more than one
                       list of input files is given, tbuff will apply to
                       all of the flag commands that have timerange
                       parameters in the files. Each tbuff value should
                       be a Float number given in seconds.
                       
                          Examples:
                          tbuff=[0.5, 0.8]                   
                          inpfile=['online.txt','userflags.txt']
                       
                          The timeranges in the online.txt file are
                          first converted to seconds. Then, 0.5 is
                          subtracted from t0 and 0.8 is added to t1,
                          where t0 and t1 are the two intervals given in
                          timerange. Similarly, tbuff will be applied to
                          any timerange in userflags.txt. 
                       
                       IMPORTANT: This parameter assumes that timerange
                       = t0 ~ t1, therefore it will not work if only t0
                       or t1 is given.
                       
                       NOTE: The most common use-case for tbuff is to
                       apply the online flags that are created by
                       importasdm when savecmds=True. The value of a
                       regular time buffer should be
                       tbuff=0.5*max(integration time).
    spw                Select spectral window/channels
                       Default: '' (all spectral windows and channels)
                       
                          Examples:
                          spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                          spw='<2';  spectral windows less than 2 (i.e. 0,1)
                          spw='0:5~61'; spw 0, channels 5 to 61
                          spw='0,10,3:3~45'; spw 0,10 all channels, spw
                          3 - chans 3 to 45.
                          spw='0~2:2~6'; spw 0,1,2 with channels 2
                          through 6 in each.
                          spw = '*:3~64'  channels 3 through 64 for all sp id's
                          spw = ' :3~64' will NOT work.
                       
                       NOTE: For modes clip, tfcrop and rflag,
                       channel-ranges can be excluded from flagging by
                       leaving them out of the selection range. This is
                       a way to protect known spectral-lines from being
                       flagged by the autoflag algorithms. For example,
                       if spectral-lines fall in channels 6~9, set the
                       selection range to spw='0:0~5;10~63'.
    field              Select field using field id(s) or field name(s)
                       Default: '' (all fields)
                       
                       Use 'go listobs' to obtain the list id's or
                       names. If field string is a non-negative integer,
                       it is assumed a field index,  otherwise, it is
                       assumed a field name.
                       
                          Examples:
                          field='0~2'; field ids 0,1,2
                          field='0,4,5~7'; field ids 0,4,5,6,7
                          field='3C286,3C295'; field named 3C286 and
                          3C295
                          field = '3,4C*'; field id 3, all names
                          starting with 4C
    antenna            Select data based on antenna/baseline
                                          Subparameter of selectdata=True
                                          Default: '' (all)
                       
                                          If antenna string is a non-negative integer, it
                                          is assumed an antenna index, otherwise, it is
                                          assumed as an antenna name
                       
                                              Examples: 
                                              antenna='5&6'; baseline between antenna
                                              index 5 and index 6.
                                              antenna='VA05&VA06'; baseline between VLA
                                              antenna 5 and 6.
                                              antenna='5&6;7&8'; baselines with
                                              indices 5-6 and 7-8
                                              antenna='5'; all baselines with antenna index
                                              5
                                              antenna='05'; all baselines with antenna
                                              number 05 (VLA old name)
                                              antenna='5,6,10'; all baselines with antennas
                                              5,6,10 index numbers
                       
                                          NOTE: for some antenna-based calibration tables,
                                          selecting baselines with the & syntax do not
                                          apply.
    uvrange            Select data by baseline length.
                       Default = '' (all)
                       
                          Examples:
                          uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                          uvrange='>4klambda';uvranges greater than 4 kilo-lambda
                          uvrange='0~1000km'; uvrange in kilometers
                       
                       NOTE: uvrange selection is not supported for cal tables.
    timerange          Select data based on time range
                       Subparameter of selectdata=True
                       Default = '' (all)
                       
                          Examples:
                          timerange =
                          'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                          (Note: if YYYY/MM/DD is missing date defaults
                          to first day in data set.)
                          timerange='09:14:0~09:54:0' picks 40 min on
                          first day 
                          timerange= '25:00:00~27:30:00' picks 1 hr to 3
                          hr 30min on NEXT day
                          timerange='09:44:00' pick data within one
                          integration of time
                          timerange='>10:24:00' data after this time
    correlation        Select data based on correlation
                       Default: '' ==> all
                       Options: Any of 'ABS', 'ARG', 'REAL', 'IMAG',
                       'NORM' followed by any of 'ALL', 'I', 'XX', 'YY',
                       'RR', 'LL', 'WVR' ('WVR' = water vapour
                       radiometer of ALMA data).
                       
                          Example: correlation="XX,YY".
                       
                       For modes clip, tfcrop or rflag, the default
                       means ABS_ALL. If the input is cal table that
                       does not contain a complex data column, the
                       default will fall back to REAL_ALL.
                       For calibration tables, the solutions are:
                       'Sol1', 'Sol2', Sol3, Sol4.
                       
                       NOTE: correlation selection is not supported for
                       modes other than clip, tfcrop or rflag in cal
                       tables.
    scan               Scan number range
                       Subparameter of selectdata=True
                       Default: '' = all
    intent             Select observing intent
                       Default: '' (no selection by intent)
                       
                          Example: intent='*BANDPASS*'  (selects data
                          labelled with BANDPASS intent)
                       
                       NOTE: intent selection is not supported for cal
                       tables.
    array              Selection based on the antenna array
                       Default: '' (all)
                       
                       NOTE: array selection is not supported for cal
                       tables.
    observation        Select by observation ID(s)
                       Subparameter of selectdata=True
                       Default: '' = all
                       
                           Example: observation='0~2,4'
    feed               Selection based on the feed: Not yet implemented
    clipminmax         Range to use for clipping
                       Subparameter of mode='clip'
                       Default: [] (it will flag only NaN and Infs)
                       
                       It will always flag the NaN/Inf data, even when a range is specified. 
                       
                          Example: [0.0,1.5]
    datacolumn         Data column to image (data or observed, corrected)
                       Subparameter of mode='clip|tfcrop|rflag'
                       Default:'corrected'
                       Options: data, corrected, model, weight, etc.
                       
                       If 'corrected' does not exist, it will use 'data'
                       instead
    clipoutside        Clip outside the range?
                       Subparameter of mode='clip'
                       Default: True
                       Options: True|False
    channelavg         Pre-average data across channels before analyzing
                       visibilities for flagging
                       Subparameter of mode='clip|tfcrop|rflag'
                       Default: False
                       Options: False|True
                       
                       Pre-average data across channels before analyzing
                       visibilities for flagging. Partially flagged data
                       is  not be included in the average unless all
                       data contributing to a given output channel is
                       flagged. If present, WEIGHT_SPECTRUM /
                       SIGMA_SPECTRUM are used to compute a weighted
                       average (WEIGHT_SPECTRUM for CORRECTED_DATA and
                       SIGMA_SPECTRUM for DATA).
                       
                       NOTE 1: Pre-average across channels is not
                       supported in list mode.
                       
                       NOTE 2: Pre-average across channels is not
                       supported for calibration tables
    chanbin            Bin width for channel average in number of input channels
                       Subparameter of mode='clip|tfcrop|rflag'
                       Default: 1
                       
                       Bin width for channel average in number of input
                       channels. If a list is given, each bin applies to
                       one of the selected SPWs. When chanbin is set to
                       1 all input channels are used considered for the
                       average to produce a single output channel, this
                       behaviour aims to be preserve backwards
                       compatibility with the previous pre-averaging
                       feature of clip mode.
    timeavg            Pre-average data across time before analyzing
                       visibilities for flagging.
                       Subparameter of mode='clip|tfcrop|rflag'
                       Default: False
                       Options: False|True
                       
                       Pre-average data across time before analyzing
                       visibilities for flagging. Partially flagged data
                       is  not be included in the average unless all
                       data contributing to a given output channel is
                       flagged. If present, WEIGHT_SPECTRUM /
                       SIGMA_SPECTRUM are used to compute a weighted
                       average (WEIGHT_SPECTRUM for  CORRECTED_DATA and
                       SIGMA_SPECTRUM for DATA). Otherwise WEIGHT/SIGMA
                       are used to average together data from different
                       integrations.
                       
                       NOTE 1: Pre-average across time is not
                       supported in list mode.
                       
                       NOTE 2: Pre-average across time is not
                       supported for calibration tables
    timebin            Bin width for time average in seconds
                       Subparameter of mode='clip|tfcrop|rflag'
                       Default: '0s'
    clipzeros          Clip zero-value data
                       Subparameter of mode='clip'
                       Default: False
                       Options: False|True
    quackinterval      Time in seconds from scan beginning or end to flag.
                       Subparameter of mode='quack'
                       Default: 0.0
                       
                       Note: Make time slightly smaller than the desired
                       time.
    quackmode          Quack mode. beg: first n seconds of scan; endb: last n
                       seconds of scan; end: all but first n seconds of scan; tail: all but
                       last n seconds of scan.
                         Subparameter of mode='quack'
                         Default: 'beg'
                         Options: 
                       * 'beg': flag an interval at the beginning of scan
                       * 'endb': flag an interval at the end of scan 
                       * 'tail': flag all but an interval at the beginning
                                 of scan
                       * 'end': flag all but an interval at end of scan
                       
                         Visual representation of quack mode flagging one
                         scan with 1s duration. The following diagram
                         shows what is flagged for each quack mode when
                         quackinterval is set to 0.25s. The flagged part
                         is represented by crosses (+++++++++)
                       
                                     scan with 1s duration
                         --------------------------------------------
                         beg
                         +++++++++++---------------------------------
                                                          endb
                         ---------------------------------+++++++++++
                                    tail
                         -----------+++++++++++++++++++++++++++++++++
                         end
                         +++++++++++++++++++++++++++++++++-----------
    quackincrement     Increment quack flagging in time taking into account
                       flagged data or not.
                       Subparameter of mode='quack'
                       Default: False
                       Options: False|True
                       
                       False: the quack interval is counted from the
                       scan boundaries, as determined by the quackmode
                       parameter, regardless of if data has been flagged
                       or not.
                       True: the quack interval is counted from the
                       first unflagged data in the scan.
                       
                       NOTE: on adding quack to a command in 'list'
                       mode: quackincrement = True works based on the
                       state of prior flagging, and unless it is the
                       first item in the list the agent doing the
                       quacking in list mode doesn't know about the
                       state of prior flags. In this case, the command
                       with quackincrement=True will be ignored and the
                       task will issue a WARNING.
    tolerance          Amount of shadowing allowed (or tolerated), in meters. 
                       Subparameter of mode='shadow'
                       Default: 0.0
                       
                       A positive number allows antennas to overlap in
                       projection. A negative number forces antennas
                       apart in projection. Zero implies a distance of
                       radius_1+radius_2 between antenna centers.
    addantenna         File name or dictionary with additional antenna names,
                       positions and diameters
                         Subparameter of mode='shadow'
                         Default: ''
                       
                         It can be either a file name with additional
                         antenna names, positions and diameters, or a
                         Python dictionary with the same information. You
                         can use the flaghelper functions to create the
                         dictionary from a file. 
                       
                         To create a dictionary inside casapy.
                         > import flaghelper as fh
                         > antdic = fh.readAntennaList(antfile)
                       
                         Where antfile is a text file in disk that
                         contains information such as:
                         name=VLA01
                         diameter=25.0
                         position=[-1601144.96146691, -5041998.01971858,
                         3554864.76811967]
                         name=VLA02
                         diameter=25.0
                         position=[-1601105.7664601889,
                         -5042022.3917835914, 3554847.245159178]
    lowerlimit         Lower limiting elevation (in degrees)
                       Subparameter of mode='elevation'
                       Default: 0.0
                       
                       Lower limiting elevation in degrees. Data coming
                       from a baseline where one or both antennas were
                       pointing at a strictly lower elevation (as
                       function of time), will be flagged.
    upperlimit         Upper limiting elevation (in degrees)
                       Subparameter of mode='elevation'
                       Default: 90.0
                       
                       Upper limiting elevation in degrees. Data coming
                       from a baseline where one or both antennas were
                       pointing at a strictly higher elevation (as
                       function of time), will be flagged.
    ntime              Timerange (in seconds or minutes) over which to buffer
                       data before running the algorithm. 
                       Subparameter of mode='tfcrop|rflag|extend'
                       Default: 'scan'
                       Options: 'scan' or any other float value or
                       string containing the units.
                       
                       The dataset will be iterated through in
                       time-chunks defined here.
                       
                          Example: ntime='1.5min'; 1.2 (taken in
                          seconds)
                       
                       WARNING: if ntime='scan' and combinescans=True,
                       all the scans will be loaded at once, thus
                       requesting a lot of memory depending on the
                       available spws.
    combinescans       Accumulate data across scans depending on the value of
                       ntime.
                       Subparameter of mode='tfcrop|rflag|extend'
                       Default: False
                       Options: False|True
                       
                       This parameter should be set to True only when
                       ntime is specified as a time-interval (not
                       'scan'). When set to True, it will remove SCAN
                       from the sorting columns, therefore it will only
                       accumulate across scans if ntime is not set to
                       'scan'.
    timecutoff         Flagging thresholds in units of deviation from the fit
                       Subparameter of mode='tfcrop'
                       Default: 4.0
                       
                       Flag all data-points further than N-stddev from
                       the fit. This threshold catches time-varying RFI
                       spikes (narrow and broad-band), but will not
                       catch RFI that is persistent in time.
                       
                       Flagging is done in upto 5 iterations. The stddev
                       calculation is adaptive and converges to a value
                       that reflects only the data and no RFI. At each
                       iteration, the same relative threshold is applied
                       to detect flags. (Step (3) of the algorithm).
    freqcutoff         Flag threshold in frequency.
                       Subparameter of mode='tfcrop'
                       Default: 3.0
                       
                       Flag all data-points further than N-stddev from
                       the fit. Same as timecutoff, but along the
                       frequency-dimension. This threshold catches
                       narrow-band RFI that may or may not be persistent
                       in time.
    timefit            Fitting function for the time direction (poly/line)
                       Subparameter of mode='tfcrop'
                       Default: 'line'
                       Options: line|poly
                       
                       'line': fit is a robust straight-line fit across
                       the entire timerange (defined by 'ntime').
                       'poly': fit is a robust piece-wise polynomial fit
                       across the timerange.
                       
                       NOTE: A robust fit is computed in upto 5
                       iterations. At each iteration, the stddev between
                       the data and the fit is computed, values beyond
                       N-stddev are flagged, and the fit and stddev are
                       re-calculated with the remaining points. This
                       stddev calculation is adaptive, and converges to
                       a value that reflects only the data and no RFI.
                       It also provides a varying set of flagging
                       thresholds, that allows deep flagging only when
                       the fit best represents the true data.
                       
                       Choose 'poly' only if the visibilities are
                       expected to vary significantly over the timerange
                       selected by 'ntime', or if there is a lot of
                       strong but intermittent RFI.
    freqfit            Fitting function for the frequency direction (poly/line)
                       Subparameter of mode='tfcrop'
                       Default: 'poly'
                       Options: line|poly
                       
                       Same as for the 'timefit' parameter.
                       
                       Choose 'line' only if you are operating on
                       bandpass-corrected data, or residuals,and expect
                       that the bandshape is linear. The 'poly' option
                       works better on uncalibrated bandpasses with
                       narrow-band RFI spikes.
    maxnpieces         Number of pieces in the polynomial-fits (for "freqfit" or
                       "timefit" = "poly")
                       Subparameter of mode='tfcrop'
                       Default: 7
                       Options: 1-9
                       
                       This parameter is used only if 'timefit' or
                       'freqfit' are chosen as 'poly'. If there is
                       significant broad-band RFI, reduce this
                       number. Using too many pieces could result in the
                       RFI being fitted in the 'clean' bandpass. In
                       later stages of the fit, a third-order polynomial
                       is fit per piece, so for best results, please
                       ensure that nchan/maxnpieces is at-least 10.
    flagdimension      Choose the directions along which to perform flagging
                       Subparameter of mode='tfcrop'
                       Default: 'freqtime' (first flag along frequency,
                       and then along time) 
                       Options: 'time', 'freq', 'timefreq', 'freqtime'
                       
                       For most cases, 'freqtime' or 'timefreq' are
                       appropriate, and differences between these
                       choices are apparant only if RFI in one dimension
                       is significantly stronger than the other. The
                       goal is to flag the dominant RFI first.
                       If there are very few (less than 5) channels of
                       data, then choose 'time'. Similarly for 'freq'.
    usewindowstats     Use sliding-window statistics to find additional flags.
                       Subparameter of mode='tfcrop'
                       Default: 'none' 
                       Options: 'none', 'sum', 'std', 'both'   
                       
                       NOTE: This is experimental!
                       The 'sum' option chooses to flag a point, if the
                       mean-value in a window centered on that point
                       deviates from the fit by more than N-stddev/2.0. 
                       
                       NOTE: stddev is calculated between the data and
                       fit as explained in Step (2). This option is an
                       attempt to catch broad-band or time-persistent
                       RFI  that the above polynomial fits will
                       mistakenly fit as the clean band. It is an
                       approximation to the sumThreshold method found to
                       be effective by Offringa et.al (2010) for LOFAR
                       data. The 'std' option chooses to flag a point,
                       if the 'local' stddev calculated in a window
                       centered on that point is larger than
                       N-stddev/2.0. This option is an attempt to catch
                       noisy RFI that is not excluded in the polynomial
                       fits, and which increases the global stddev, and
                       results in fewer flags (based on the N-stddev
                       threshold).
    halfwin            Half-width of sliding window to use with "usewindowstats"
                       (1,2,3).
                       Subparameter of mode='tfcrop'
                       Default: 1  (a 3-point window size)
                       Options: 1, 2, 3
                       
                       NOTE: This is experimental!
    extendflags        Extend flags along time, frequency and correlation.
                       Subparameter of mode='tfcrop|rflag'
                       Default: True
                       Options: True|False
                       
                       NOTE: It is usually helpful to extend the flags
                       along time, frequency, and correlation using this
                       parameter, which will run the "extend" mode after
                       "tfcrop" and extend the flags if more than 50% of
                       the timeranges are already flagged, and if more
                       than 80% of the channels are already flagged. It
                       will also extend the flags to the other
                       polarizations. The user may also set extendflags
                       to False and run the "extend" mode in a second
                       step within the same flagging run:
                       
                          Example: cmd=["mode='tfcrop' freqcutoff=3.0
                          usewindowstats='sum' extendflags=False",
                          "mode='extend' extendpols=True growtime=50.0
                          growaround=True"]
                          flagdata(vis, mode='list', inpfile=cmd)
    winsize            Number of timesteps in the sliding time window ( fparm(1)
                       in AIPS )
                       Subparameter of mode='rflag'
                       Default: 3
    timedev            Time-series noise estimate ( noise in AIPS )
                       Subparameter of mode='rflag'
                       Default: []
                       
                          Examples: 
                          timedev = 0.5 : Use this noise-estimate to
                          calculate flags. Do not recalculate.
                          timedev = [ [1,9,0.2], [1,10,0.5] ] :  Use
                          noise-estimate of 0.2 for field 1, spw 9, and
                          noise-estimate of 0.5 for field 1, spw 10.
                          timedev = [] : Auto-calculate noise
                          estimates. 
                          'tdevfile.txt' : Auto-calculate noise
                          estimates and write them into a file with the
                          name given (any string will be interpreted as
                          a file name which will be checked for
                          existence).
    freqdev            Spectral noise estimate ( scutoff in AIPS )
                       Subparameter of mode='rflag'
                       Default: []
                       
                       This step depends on having a relatively-flat
                       bandshape. Same parameter-options as 'timedev'.
    timedevscale       Threshold scaling for timedev( fparm(9) in AIPS ).
                       For Step 1 (time analysis), flag a point if local
                       rms around it is larger than 'timedevscale' x
                       'timedev' (fparm(0) in AIPS)
                       Subparameter of mode='rflag'
                       Default: 5.0
                       
                       This scale parameter is only applied when
                       flagging (action='apply') and displaying reports
                       (display option). It is not used when the
                       thresholds are simply calculated and saved into
                       files (action='calculate', as in the two-passes
                       usage pattern of AIPS)
    freqdevscale       Threshold scaling for freqdev (fparm(10) in AIPS ). 
                       For Step 2 (spectral analysis), flag a point if
                       local rms around it is larger than 'freqdevscale'
                       x 'freqdev' (fparm(10) in AIPS)
                       Subparameter of mode='rflag'
                       Default: 5.0
                       
                       Similarly as with timedevscale, freqdevscale is
                       used when applying flags and displaying
                       reports. It is not used when the thresholds are
                       simply calculated and saved into files
                       (action='calculate', as in the two-passes usage
                       pattern of AIPS)
    spectralmax        Flag whole spectrum if 'freqdev' is greater than
                       spectralmax ( fparm(6) in AIPS )
                       Subparameter of mode='rflag'
                       Default: 1E6
    spectralmin        Flag whole spectrum if 'freqdev' is less than spectralmin
                       ( fparm(5) in AIPS )
                       Subparameter of mode='rflag'
                       Default: 0.0
    antint_ref_antenna Antenna of interest. Baselines with this antenna will be
                       checked for flagged channels.
                       Subparameter of mode='antint'
                       
                       Note that this is not the same as the general
                       'antenna' parameter of flagdata. The parameter
                       antint_ref_antenna is mandatory with the 'antint'
                       mode and chooses the antenna for which the
                       fraction of channels flagged will be checked.
    minchanfrac        Minimum fraction of flagged channels required for a
                       baseline to be deemed as flagged
                       Subparameter of mode='antint'
                       Takes values between 0-1 (float).
                       
                       In this mode flagdata does the following for
                       every point in time. It checks the fraction of
                       channels flagged for any of the polarization
                       products and for every baseline to the antenna of
                       interest. If the fraction is higher than this
                       'minchanfrac' threshold then the data are flagged
                       for this pont in time (this includes all the rows
                       selected with the flagdata command that have that
                       timestamp).
                       This parameter will be ignored if spw specifies a
                       channel.
    verbose            Print timestamps of flagged integrations to the log
                       Subparameter of mode='antint'
                       
                          Examples: 
                          flagdata(vis, ..., spw='9',
                          antint_ref_antenna='ea01')
                          flagdata(vis, ..., spw='9',
                          antint_ref_antenna='ea01', minchanfrac=0.3,
                          verbose=True) ==> reduce the fraction of
                          channels that are required to be flagged, and
                          print information for every integration that
                          is flagged.
    extendpols         Extend flags to all selected correlations
                       Subparameter of mode='extend'
                       Default: True
                       Options: True|False
                       
                          For example, to extend flags from RR to only
                          RL and LR, a data-selection of
                          correlation='RR,LR,RL' is required along with
                          extendpols=True.
    growtime           For any channel, flag the entire timerange in the current
                       2D chunk (set by 'ntime') if more than X% of the timerange is already
                       flagged.
                       Subparameter of mode='extend'
                       Default: 50.0
                       Options:  0.0 - 100.0
                       
                       This option catches the low-intensity parts of
                       time-persistent RFI.
    growfreq           For any timestep, flag all channels in the current 2D
                       chunk (set by  data-selection) if more than X% of the channels are
                       already flagged.
                       Subparameter of mode='extend'
                       Default: 50.0
                       Options:  0.0 - 100.0
                       
                       This option catches broad-band RFI that is
                       partially identified by earlier steps.
    growaround         Flag a point based on the number of flagged points around it.
                       Subparameter of mode='extend'
                       Default: False
                       Options: False|True
                       
                       For every un-flagged point on the 2D time/freq
                       plane, if more than four surrounding points are
                       already flagged, flag that point. This option
                       catches some wings of strong RFI spikes.
    flagneartime       Flag points before and after every flagged one, in the
                       time-direction.
                       Subparameter of mode='extend'
                       Default: False
                       Options: False|True
                       
                       NOTE: This can result in excessive flagging.
    flagnearfreq       Flag points before and after every flagged one, in the
                       frequency-direction
                       Subparameter of mode='extend'
                       Default: False
                       Options: False|True
                       
                       NOTE:  This can result in excessive flagging
    minrel             Minimum number of flags (relative) to include in
                       histogram
                       Subparameter of mode='summary'
                       Default: 0.0
    maxrel             Maximum number of flags (relative) to include in
                       histogram
                       Subparameter of mode='summary'
                       Default: 1.0
    minabs             Minimum number of flags (absolute, inclusive) to include
                       in histogram
                       Subparameter of mode='summary'
                       Default: 0
    maxabs             Maximum number of flags (absolute, inclusive) to include
                       in histogram
                       Subparameter of mode='summary'
                       Default: -1
                       
                       To indicate infinity, use any negative number.
    spwchan            List the number of flags per spw and per channel.
                       Subparameter of mode='summary'
                       Default: False
                       Options: False|True
    spwcorr            List the number of flags per spw and per correlation.
                       Subparameter of mode='summary'
                       Default: False
                       Options: False|True
    basecnt            List the number of flags per baseline
                       Subparameter of mode='summary'
                       Default: False
                       Options: False|True
    fieldcnt           Produce a separated breakdown per field
                       Subparameter of mode='summary'
                       Default: False
                       Options: False|True
    name               Name for this summary, to be used as a key in the
                       returned Python dictionary
                                    Subparameter of mode='summary'
                                    Default: 'Summary'
                       
                                    It is possible to call the summary mode multiple
                                    times in list mode. When calling the summary mode
                                    as a command in a list, one can give different
                                    names to each one of them so that they can be
                                    easily pulled out of the summary's dictionary.
                       
                                   In summary mode, the task returns a dictionary of flagging statistics.
                       
                                   Example 1:
                                   s = flagdata(..., mode='summary')
                                   Then s will be a dictionary which contains
                                   s['total']   : total number of data
                                   s['flagged'] : amount of flagged data
                       
                                   Example 2: 
                                   Two summary commands in list mode, intercalating a
                                   manual flagging command.
                                   s = flagdata(..., mode='list',
                                   inpfile=["mode='summary' name='InitFlags'",
                                   "mode='manual' autocorr=True", "mode='summary'
                                   name='Autocorr'"])
                       
                                   The dictionary returned in 's' will contain two
                                   dictionaries, one for each of the two summary
                                   modes. 
                                   s['report0']['name'] : 'InitFlags'
                                   s['report1']['name'] : 'Autocorr'
    action             Action to perform in MS/cal table or in the input list of
                       parameters.
                       Default: 'apply'
                       Options:  'none', 'apply','calculate'
                       
                       * 'apply': Apply the flags to the MS.
                       * 'calculate': Only calculate the flags but do
                         not write them to the MS. This is useful if
                         used together with the display to analyse the
                         results before writing to the MS.
                       * '': When set to empty, the underlying tool will
                         not be executed and no flags will be
                         produced. No data selection will be done
                         either. This is useful when used together with
                         the parameter savepars to only save the current
                         parameters (or list of parameters) to the
                         FLAG_CMD sub-table or to an external file.
    display            Display data and/or end-of-MS reports at runtime.
                       Subparameter of action='apply|calculate'
                       Default: 'none'
                       Options: 'none', 'data', 'report', 'both'
                       
                       * 'none': will not display anything.
                       * 'data': display data and flags per-chunk at
                         run-time, within an interactive GUI.
                         This option opens a GUI to show the 2D
                         time-freq planes of the data with old and new
                         flags, for all correlations per baseline.
                         -- The GUI allows stepping through all
                         baselines (prev/next) in the current chunk (set
                         by 'ntime'), and stepping to the next-chunk.
                         -- The 'flagdata' task can be quit from the
                         GUI, in case it becomes obvious that the
                         current set of parameters is just wrong.
                         -- There is an option to stop the display but
                         continue flagging.
                       * 'report': displays end-of-MS reports on the
                         screen.
                       * 'both': displays data per chunk and end-of-MS
                         reports on the screen
    flagbackup         Automatically backup flags before the run?
                       Default: True
                       Options: True|False
                       
                       Flagversion names are chosen automatically, and
                       are based on the mode being used.
    savepars           Save the current parameters to the FLAG_CMD table of the
                       MS or to an output text file?
                       Default: False
                       Options: False|True
                       
                       Note that when display is set to anything other
                       than 'none', savepars will be disabled. This is
                       done because in an interactive mode, the user may
                       skip data which may invalidate the initial input
                       parameters and there is no way to save the
                       interactive commands. When the input is a
                       calibration table it is only possible to save the
                       parameters to a file.
    cmdreason          A string containing a reason to save to the FLAG_CMD
                       table or to an output text file given by the outfile sub-parameter.
                       Subparameter of savepars=True
                       Default: '' (no reason will be added to output)
                       
                       If the input  contains any reason, they will be
                       replaced with this one. At the moment it is not
                       possible to add more than one reason. 
                       
                          Example: cmdreason='CLIP_ZEROS'
    outfile            Name of output file to save current parameters. If empty,
                       save to FLAG_CMD
                       Subparameter of savepars=True
                       Default: '' (save the parameters to the FLAG_CMD
                       table of the MS)
                       
                          Example: outfile='flags.txt' will save the
                          parameters in a text file.
    overwrite          Overwrite the existing file given in 'outfile'
                       Default: True
                       Options: True|False
                       
                       The default True will remove the existing file
                       given in 'outfile' and save the current flag
                       commands to a new file with the same name. When
                       set to False, the task will exit with an error
                       message if the file exist.
    writeflags         Internal hidden parameter. Do not modify.
    [1;42mRETURNS[1;m               void

    --------- examples -----------------------------------------------------------

    
    
    FOR MORE INFORMATION, SEE THE TASK PAGES OF FLAGDATA IN CASA DOCS:
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """editing"""
    _info_desc_ = """All-purpose flagging task based on data-selections and flagging modes/algorithms."""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'mode': {'type': 'cStr'}, 'autocorr': {'type': 'cBool'}, 'inpfile': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'reason': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'tbuff': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'correlation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'array': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'feed': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'clipminmax': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'datacolumn': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'clipoutside': {'anyof': [{'type': 'cBool'}, {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}]}, 'channelavg': {'anyof': [{'type': 'cBool'}, {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}]}, 'chanbin': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'timeavg': {'anyof': [{'type': 'cBool'}, {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}]}, 'timebin': {'type': 'cStr'}, 'clipzeros': {'type': 'cBool'}, 'quackinterval': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'quackmode': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'quackincrement': {'anyof': [{'type': 'cBool'}, {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}]}, 'tolerance': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'addantenna': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'lowerlimit': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'upperlimit': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'ntime': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cStr'}]}, 'combinescans': {'type': 'cBool'}, 'timecutoff': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqcutoff': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'timefit': {'type': 'cStr'}, 'freqfit': {'type': 'cStr'}, 'maxnpieces': {'type': 'cInt'}, 'flagdimension': {'type': 'cStr'}, 'usewindowstats': {'type': 'cStr'}, 'halfwin': {'type': 'cInt'}, 'extendflags': {'type': 'cBool'}, 'winsize': {'type': 'cInt'}, 'timedev': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'freqdev': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'timedevscale': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqdevscale': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'spectralmax': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'spectralmin': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'antint_ref_antenna': {'type': 'cStr'}, 'minchanfrac': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'verbose': {'type': 'cBool'}, 'extendpols': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'growtime': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'growfreq': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'growaround': {'type': 'cBool'}, 'flagneartime': {'type': 'cBool'}, 'flagnearfreq': {'type': 'cBool'}, 'minrel': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'maxrel': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'minabs': {'type': 'cInt'}, 'maxabs': {'type': 'cInt'}, 'spwchan': {'type': 'cBool'}, 'spwcorr': {'type': 'cBool'}, 'basecnt': {'type': 'cBool'}, 'fieldcnt': {'type': 'cBool'}, 'name': {'type': 'cStr'}, 'action': {'type': 'cStr'}, 'display': {'type': 'cStr'}, 'flagbackup': {'type': 'cBool'}, 'savepars': {'type': 'cBool'}, 'cmdreason': {'type': 'cStr'}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'writeflags': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __savepars_dflt( self, glb ):
        return False

    def __savepars( self, glb ):
        if 'savepars' in glb: return glb['savepars']
        return False

    def __mode_dflt( self, glb ):
        return 'manual'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'manual'

    def __writeflags_dflt( self, glb ):
        return True

    def __writeflags( self, glb ):
        if 'writeflags' in glb: return glb['writeflags']
        return True

    def __action_dflt( self, glb ):
        return 'apply'

    def __action( self, glb ):
        if 'action' in glb: return glb['action']
        return 'apply'



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "antint": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __inpfile_dflt( self, glb ):
        if self.__mode( glb ) == "list": return ""
        return None
    def __timefit_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return "line"
        return None
    def __spwchan_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return bool(False)
        return None
    def __lowerlimit_dflt( self, glb ):
        if self.__mode( glb ) == "elevation": return float(0.0)
        return None
    def __antint_ref_antenna_dflt( self, glb ):
        if self.__mode( glb ) == "antint": return ""
        return None
    def __flagnearfreq_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return bool(False)
        return None
    def __timecutoff_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return float(4.0)
        return None
    def __name_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return "Summary"
        return None
    def __outfile_dflt( self, glb ):
        if self.__savepars( glb ) == bool(True): return ""
        return None
    def __minchanfrac_dflt( self, glb ):
        if self.__mode( glb ) == "antint": return float(.6)
        return None
    def __maxrel_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return float(1.0)
        return None
    def __clipzeros_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return bool(False)
        return None
    def __field_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "antint": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __datacolumn_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return "DATA"
        if self.__mode( glb ) == "tfcrop": return "DATA"
        if self.__mode( glb ) == "rflag": return "DATA"
        if self.__mode( glb ) == "antint": return "DATA"
        return None
    def __verbose_dflt( self, glb ):
        if self.__mode( glb ) == "antint": return bool(False)
        return None
    def __intent_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __maxabs_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return int(-1)
        return None
    def __basecnt_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return bool(False)
        return None
    def __tolerance_dflt( self, glb ):
        if self.__mode( glb ) == "shadow": return float(0.0)
        return None
    def __quackinterval_dflt( self, glb ):
        if self.__mode( glb ) == "quack": return 0.0
        return None
    def __extendflags_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return bool(True)
        if self.__mode( glb ) == "rflag": return bool(True)
        return None
    def __spectralmax_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return float(1E6)
        return None
    def __halfwin_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return int(1)
        return None
    def __timedev_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return ""
        return None
    def __ntime_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return "scan"
        if self.__mode( glb ) == "rflag": return "scan"
        if self.__mode( glb ) == "extend": return "scan"
        return None
    def __minrel_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return float(0.0)
        return None
    def __channelavg_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return False
        if self.__mode( glb ) == "tfcrop": return False
        if self.__mode( glb ) == "rflag": return False
        return None
    def __scan_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __timeavg_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return False
        if self.__mode( glb ) == "tfcrop": return False
        if self.__mode( glb ) == "rflag": return False
        return None
    def __timebin_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        return None
    def __flagdimension_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return "freqtime"
        return None
    def __freqdevscale_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return float(5.0)
        return None
    def __reason_dflt( self, glb ):
        if self.__mode( glb ) == "list": return "any"
        return None
    def __minabs_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return int(0)
        return None
    def __timedevscale_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return float(5.0)
        return None
    def __upperlimit_dflt( self, glb ):
        if self.__mode( glb ) == "elevation": return float(90.0)
        return None
    def __growtime_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return float(50.0)
        return None
    def __usewindowstats_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return "none"
        return None
    def __array_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __spwcorr_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return bool(False)
        return None
    def __chanbin_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return 1
        if self.__mode( glb ) == "tfcrop": return 1
        if self.__mode( glb ) == "rflag": return 1
        return None
    def __clipminmax_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return []
        return None
    def __correlation_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __addantenna_dflt( self, glb ):
        if self.__mode( glb ) == "shadow": return ""
        return None
    def __feed_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __spectralmin_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return float(0.0)
        return None
    def __freqdev_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return ""
        return None
    def __winsize_dflt( self, glb ):
        if self.__mode( glb ) == "rflag": return int(3)
        return None
    def __quackincrement_dflt( self, glb ):
        if self.__mode( glb ) == "quack": return False
        return None
    def __extendpols_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return True
        return None
    def __combinescans_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return bool(False)
        if self.__mode( glb ) == "rflag": return bool(False)
        if self.__mode( glb ) == "extend": return bool(False)
        return None
    def __fieldcnt_dflt( self, glb ):
        if self.__mode( glb ) == "summary": return bool(False)
        return None
    def __uvrange_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __growaround_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return bool(False)
        return None
    def __quackmode_dflt( self, glb ):
        if self.__mode( glb ) == "quack": return "beg"
        return None
    def __overwrite_dflt( self, glb ):
        if self.__savepars( glb ) == bool(True): return bool(True)
        return None
    def __observation_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __clipoutside_dflt( self, glb ):
        if self.__mode( glb ) == "clip": return True
        return None
    def __freqcutoff_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return float(3.0)
        return None
    def __tbuff_dflt( self, glb ):
        if self.__mode( glb ) == "list": return 0.0
        return None
    def __growfreq_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return float(50.0)
        return None
    def __flagbackup_dflt( self, glb ):
        if self.__action( glb ) == "apply": return bool(True)
        return None
    def __flagneartime_dflt( self, glb ):
        if self.__mode( glb ) == "extend": return bool(False)
        return None
    def __spw_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "antint": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __maxnpieces_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return int(7)
        return None
    def __freqfit_dflt( self, glb ):
        if self.__mode( glb ) == "tfcrop": return "poly"
        return None
    def __timerange_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return ""
        if self.__mode( glb ) == "manualflag": return ""
        if self.__mode( glb ) == "clip": return ""
        if self.__mode( glb ) == "quack": return ""
        if self.__mode( glb ) == "shadow": return ""
        if self.__mode( glb ) == "elevation": return ""
        if self.__mode( glb ) == "tfcrop": return ""
        if self.__mode( glb ) == "rflag": return ""
        if self.__mode( glb ) == "extend": return ""
        if self.__mode( glb ) == "unflag": return ""
        if self.__mode( glb ) == "summary": return ""
        return None
    def __cmdreason_dflt( self, glb ):
        if self.__savepars( glb ) == bool(True): return ""
        return None
    def __display_dflt( self, glb ):
        if self.__action( glb ) == "apply": return ""
        if self.__action( glb ) == "calculate": return ""
        return None
    def __autocorr_dflt( self, glb ):
        if self.__mode( glb ) == "manual": return bool(False)
        if self.__mode( glb ) == "manualflag": return bool(False)
        return None

    #--------- return subparam values -------------------------------------------------
    def __autocorr( self, glb ):
        if 'autocorr' in glb: return glb['autocorr']
        dflt = self.__autocorr_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __inpfile( self, glb ):
        if 'inpfile' in glb: return glb['inpfile']
        dflt = self.__inpfile_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __reason( self, glb ):
        if 'reason' in glb: return glb['reason']
        dflt = self.__reason_dflt( glb )
        if dflt is not None: return dflt
        return 'any'
    def __tbuff( self, glb ):
        if 'tbuff' in glb: return glb['tbuff']
        dflt = self.__tbuff_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        dflt = self.__spw_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        dflt = self.__field_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        dflt = self.__correlation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        dflt = self.__array_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        dflt = self.__feed_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __clipminmax( self, glb ):
        if 'clipminmax' in glb: return glb['clipminmax']
        dflt = self.__clipminmax_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        dflt = self.__datacolumn_dflt( glb )
        if dflt is not None: return dflt
        return 'DATA'
    def __clipoutside( self, glb ):
        if 'clipoutside' in glb: return glb['clipoutside']
        dflt = self.__clipoutside_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __channelavg( self, glb ):
        if 'channelavg' in glb: return glb['channelavg']
        dflt = self.__channelavg_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __chanbin( self, glb ):
        if 'chanbin' in glb: return glb['chanbin']
        dflt = self.__chanbin_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __timeavg( self, glb ):
        if 'timeavg' in glb: return glb['timeavg']
        dflt = self.__timeavg_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        dflt = self.__timebin_dflt( glb )
        if dflt is not None: return dflt
        return '0s'
    def __clipzeros( self, glb ):
        if 'clipzeros' in glb: return glb['clipzeros']
        dflt = self.__clipzeros_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __quackinterval( self, glb ):
        if 'quackinterval' in glb: return glb['quackinterval']
        dflt = self.__quackinterval_dflt( glb )
        if dflt is not None: return dflt
        return float(1.0)
    def __quackmode( self, glb ):
        if 'quackmode' in glb: return glb['quackmode']
        dflt = self.__quackmode_dflt( glb )
        if dflt is not None: return dflt
        return 'beg'
    def __quackincrement( self, glb ):
        if 'quackincrement' in glb: return glb['quackincrement']
        dflt = self.__quackincrement_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __tolerance( self, glb ):
        if 'tolerance' in glb: return glb['tolerance']
        dflt = self.__tolerance_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __addantenna( self, glb ):
        if 'addantenna' in glb: return glb['addantenna']
        dflt = self.__addantenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __lowerlimit( self, glb ):
        if 'lowerlimit' in glb: return glb['lowerlimit']
        dflt = self.__lowerlimit_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __upperlimit( self, glb ):
        if 'upperlimit' in glb: return glb['upperlimit']
        dflt = self.__upperlimit_dflt( glb )
        if dflt is not None: return dflt
        return float(90.0)
    def __ntime( self, glb ):
        if 'ntime' in glb: return glb['ntime']
        dflt = self.__ntime_dflt( glb )
        if dflt is not None: return dflt
        return 'scan'
    def __combinescans( self, glb ):
        if 'combinescans' in glb: return glb['combinescans']
        dflt = self.__combinescans_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __timecutoff( self, glb ):
        if 'timecutoff' in glb: return glb['timecutoff']
        dflt = self.__timecutoff_dflt( glb )
        if dflt is not None: return dflt
        return float(4.0)
    def __freqcutoff( self, glb ):
        if 'freqcutoff' in glb: return glb['freqcutoff']
        dflt = self.__freqcutoff_dflt( glb )
        if dflt is not None: return dflt
        return float(3.0)
    def __timefit( self, glb ):
        if 'timefit' in glb: return glb['timefit']
        dflt = self.__timefit_dflt( glb )
        if dflt is not None: return dflt
        return 'line'
    def __freqfit( self, glb ):
        if 'freqfit' in glb: return glb['freqfit']
        dflt = self.__freqfit_dflt( glb )
        if dflt is not None: return dflt
        return 'poly'
    def __maxnpieces( self, glb ):
        if 'maxnpieces' in glb: return glb['maxnpieces']
        dflt = self.__maxnpieces_dflt( glb )
        if dflt is not None: return dflt
        return int(7)
    def __flagdimension( self, glb ):
        if 'flagdimension' in glb: return glb['flagdimension']
        dflt = self.__flagdimension_dflt( glb )
        if dflt is not None: return dflt
        return 'freqtime'
    def __usewindowstats( self, glb ):
        if 'usewindowstats' in glb: return glb['usewindowstats']
        dflt = self.__usewindowstats_dflt( glb )
        if dflt is not None: return dflt
        return 'none'
    def __halfwin( self, glb ):
        if 'halfwin' in glb: return glb['halfwin']
        dflt = self.__halfwin_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __extendflags( self, glb ):
        if 'extendflags' in glb: return glb['extendflags']
        dflt = self.__extendflags_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __winsize( self, glb ):
        if 'winsize' in glb: return glb['winsize']
        dflt = self.__winsize_dflt( glb )
        if dflt is not None: return dflt
        return int(3)
    def __timedev( self, glb ):
        if 'timedev' in glb: return glb['timedev']
        dflt = self.__timedev_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __freqdev( self, glb ):
        if 'freqdev' in glb: return glb['freqdev']
        dflt = self.__freqdev_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timedevscale( self, glb ):
        if 'timedevscale' in glb: return glb['timedevscale']
        dflt = self.__timedevscale_dflt( glb )
        if dflt is not None: return dflt
        return float(5.0)
    def __freqdevscale( self, glb ):
        if 'freqdevscale' in glb: return glb['freqdevscale']
        dflt = self.__freqdevscale_dflt( glb )
        if dflt is not None: return dflt
        return float(5.0)
    def __spectralmax( self, glb ):
        if 'spectralmax' in glb: return glb['spectralmax']
        dflt = self.__spectralmax_dflt( glb )
        if dflt is not None: return dflt
        return float(1E6)
    def __spectralmin( self, glb ):
        if 'spectralmin' in glb: return glb['spectralmin']
        dflt = self.__spectralmin_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __antint_ref_antenna( self, glb ):
        if 'antint_ref_antenna' in glb: return glb['antint_ref_antenna']
        dflt = self.__antint_ref_antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __minchanfrac( self, glb ):
        if 'minchanfrac' in glb: return glb['minchanfrac']
        dflt = self.__minchanfrac_dflt( glb )
        if dflt is not None: return dflt
        return float(0.6)
    def __verbose( self, glb ):
        if 'verbose' in glb: return glb['verbose']
        dflt = self.__verbose_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __extendpols( self, glb ):
        if 'extendpols' in glb: return glb['extendpols']
        dflt = self.__extendpols_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __growtime( self, glb ):
        if 'growtime' in glb: return glb['growtime']
        dflt = self.__growtime_dflt( glb )
        if dflt is not None: return dflt
        return float(50.0)
    def __growfreq( self, glb ):
        if 'growfreq' in glb: return glb['growfreq']
        dflt = self.__growfreq_dflt( glb )
        if dflt is not None: return dflt
        return float(50.0)
    def __growaround( self, glb ):
        if 'growaround' in glb: return glb['growaround']
        dflt = self.__growaround_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __flagneartime( self, glb ):
        if 'flagneartime' in glb: return glb['flagneartime']
        dflt = self.__flagneartime_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __flagnearfreq( self, glb ):
        if 'flagnearfreq' in glb: return glb['flagnearfreq']
        dflt = self.__flagnearfreq_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __minrel( self, glb ):
        if 'minrel' in glb: return glb['minrel']
        dflt = self.__minrel_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __maxrel( self, glb ):
        if 'maxrel' in glb: return glb['maxrel']
        dflt = self.__maxrel_dflt( glb )
        if dflt is not None: return dflt
        return float(1.0)
    def __minabs( self, glb ):
        if 'minabs' in glb: return glb['minabs']
        dflt = self.__minabs_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __maxabs( self, glb ):
        if 'maxabs' in glb: return glb['maxabs']
        dflt = self.__maxabs_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __spwchan( self, glb ):
        if 'spwchan' in glb: return glb['spwchan']
        dflt = self.__spwchan_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __spwcorr( self, glb ):
        if 'spwcorr' in glb: return glb['spwcorr']
        dflt = self.__spwcorr_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __basecnt( self, glb ):
        if 'basecnt' in glb: return glb['basecnt']
        dflt = self.__basecnt_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __fieldcnt( self, glb ):
        if 'fieldcnt' in glb: return glb['fieldcnt']
        dflt = self.__fieldcnt_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __name( self, glb ):
        if 'name' in glb: return glb['name']
        dflt = self.__name_dflt( glb )
        if dflt is not None: return dflt
        return 'Summary'
    def __display( self, glb ):
        if 'display' in glb: return glb['display']
        dflt = self.__display_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __flagbackup( self, glb ):
        if 'flagbackup' in glb: return glb['flagbackup']
        dflt = self.__flagbackup_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __cmdreason( self, glb ):
        if 'cmdreason' in glb: return glb['cmdreason']
        dflt = self.__cmdreason_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        dflt = self.__outfile_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        dflt = self.__overwrite_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __writeflags( self, glb ):
        if 'writeflags' in glb: return glb['writeflags']
        dflt = self.__writeflags_dflt( glb )
        if dflt is not None: return dflt
        return True

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-21.21s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Flagging mode (list/manual/clip/quack/shadow/elevation/tfcrop/rflag/antint/extent/unflag/summary)'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __autocorr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__autocorr_dflt( self.__globals_( ) ) is not None:
             description = 'Flag only the auto-correlations?'
             value = self.__autocorr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'autocorr': value},{'autocorr': self.__schema['autocorr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('autocorr',pre,self.__to_string_(value),post,description))
    def __inpfile_inp(self):
        out = self.__stdout or sys.stdout
        if self.__inpfile_dflt( self.__globals_( ) ) is not None:
             description = 'Input ASCII file, list of files or Python list of strings with flag commands.'
             value = self.__inpfile( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'inpfile': value},{'inpfile': self.__schema['inpfile']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('inpfile',pre,self.__to_string_(value),post,description))
    def __reason_inp(self):
        out = self.__stdout or sys.stdout
        if self.__reason_dflt( self.__globals_( ) ) is not None:
             description = 'Select by REASON types'
             value = self.__reason( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'reason': value},{'reason': self.__schema['reason']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('reason',pre,self.__to_string_(value),post,description))
    def __tbuff_inp(self):
        out = self.__stdout or sys.stdout
        if self.__tbuff_dflt( self.__globals_( ) ) is not None:
             description = 'List of time buffers (sec) to pad timerange in flag commands'
             value = self.__tbuff( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'tbuff': value},{'tbuff': self.__schema['tbuff']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('tbuff',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spw_dflt( self.__globals_( ) ) is not None:
             description = 'Select spectral window/channels'
             value = self.__spw( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        if self.__field_dflt( self.__globals_( ) ) is not None:
             description = 'Select field using field id(s) or field name(s)'
             value = self.__field( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on antenna/baseline'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __uvrange_inp(self):
        out = self.__stdout or sys.stdout
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data by baseline length.'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('uvrange',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __correlation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__correlation_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on correlation'
             value = self.__correlation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('correlation',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = 'Select observing intent'
             value = self.__intent( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        if self.__array_dflt( self.__globals_( ) ) is not None:
             description = '(Sub)array numbers'
             value = self.__array( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Select by observation ID(s)'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __feed_inp(self):
        out = self.__stdout or sys.stdout
        if self.__feed_dflt( self.__globals_( ) ) is not None:
             description = 'Multi-feed numbers: Not yet implemented'
             value = self.__feed( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('feed',pre,self.__to_string_(value),post,description))
    def __clipminmax_inp(self):
        out = self.__stdout or sys.stdout
        if self.__clipminmax_dflt( self.__globals_( ) ) is not None:
             description = 'Range to use for clipping'
             value = self.__clipminmax( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'clipminmax': value},{'clipminmax': self.__schema['clipminmax']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('clipminmax',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        if self.__datacolumn_dflt( self.__globals_( ) ) is not None:
             description = 'Data column on which to operate'
             value = self.__datacolumn( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))
    def __clipoutside_inp(self):
        out = self.__stdout or sys.stdout
        if self.__clipoutside_dflt( self.__globals_( ) ) is not None:
             description = 'Clip outside the range, or within it'
             value = self.__clipoutside( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'clipoutside': value},{'clipoutside': self.__schema['clipoutside']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('clipoutside',pre,self.__to_string_(value),post,description))
    def __channelavg_inp(self):
        out = self.__stdout or sys.stdout
        if self.__channelavg_dflt( self.__globals_( ) ) is not None:
             description = 'Pre-average data across channels before analyzing visibilities for flagging'
             value = self.__channelavg( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'channelavg': value},{'channelavg': self.__schema['channelavg']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('channelavg',pre,self.__to_string_(value),post,description))
    def __chanbin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__chanbin_dflt( self.__globals_( ) ) is not None:
             description = 'Bin width for channel average in number of input channels'
             value = self.__chanbin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'chanbin': value},{'chanbin': self.__schema['chanbin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('chanbin',pre,self.__to_string_(value),post,description))
    def __timeavg_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timeavg_dflt( self.__globals_( ) ) is not None:
             description = 'Pre-average data across time before analyzing visibilities for flagging.'
             value = self.__timeavg( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timeavg': value},{'timeavg': self.__schema['timeavg']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timeavg',pre,self.__to_string_(value),post,description))
    def __timebin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timebin_dflt( self.__globals_( ) ) is not None:
             description = 'Bin width for time average in seconds'
             value = self.__timebin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timebin',pre,self.__to_string_(value),post,description))
    def __clipzeros_inp(self):
        out = self.__stdout or sys.stdout
        if self.__clipzeros_dflt( self.__globals_( ) ) is not None:
             description = 'Clip zero-value data'
             value = self.__clipzeros( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'clipzeros': value},{'clipzeros': self.__schema['clipzeros']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('clipzeros',pre,self.__to_string_(value),post,description))
    def __quackinterval_inp(self):
        out = self.__stdout or sys.stdout
        if self.__quackinterval_dflt( self.__globals_( ) ) is not None:
             description = 'Quack n seconds from scan beginning or end'
             value = self.__quackinterval( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'quackinterval': value},{'quackinterval': self.__schema['quackinterval']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('quackinterval',pre,self.__to_string_(value),post,description))
    def __quackmode_inp(self):
        out = self.__stdout or sys.stdout
        if self.__quackmode_dflt( self.__globals_( ) ) is not None:
             description = 'Quack mode. beg: first n seconds of scan; endb: last n seconds of scan; end: all but first n seconds of scan; tail: all but last n seconds of scan.'
             value = self.__quackmode( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'quackmode': value},{'quackmode': self.__schema['quackmode']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('quackmode',pre,self.__to_string_(value),post,description))
    def __quackincrement_inp(self):
        out = self.__stdout or sys.stdout
        if self.__quackincrement_dflt( self.__globals_( ) ) is not None:
             description = 'Increment quack flagging in time taking into account flagged data or not.'
             value = self.__quackincrement( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'quackincrement': value},{'quackincrement': self.__schema['quackincrement']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('quackincrement',pre,self.__to_string_(value),post,description))
    def __tolerance_inp(self):
        out = self.__stdout or sys.stdout
        if self.__tolerance_dflt( self.__globals_( ) ) is not None:
             description = 'Amount of shadow allowed (in meters)'
             value = self.__tolerance( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'tolerance': value},{'tolerance': self.__schema['tolerance']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('tolerance',pre,self.__to_string_(value),post,description))
    def __addantenna_inp(self):
        out = self.__stdout or sys.stdout
        if self.__addantenna_dflt( self.__globals_( ) ) is not None:
             description = 'File name or dictionary with additional antenna names, positions and diameters'
             value = self.__addantenna( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'addantenna': value},{'addantenna': self.__schema['addantenna']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('addantenna',pre,self.__to_string_(value),post,description))
    def __lowerlimit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__lowerlimit_dflt( self.__globals_( ) ) is not None:
             description = 'Lower limiting elevation (in degrees)'
             value = self.__lowerlimit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'lowerlimit': value},{'lowerlimit': self.__schema['lowerlimit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('lowerlimit',pre,self.__to_string_(value),post,description))
    def __upperlimit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__upperlimit_dflt( self.__globals_( ) ) is not None:
             description = 'Upper limiting elevation (in degrees)'
             value = self.__upperlimit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'upperlimit': value},{'upperlimit': self.__schema['upperlimit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('upperlimit',pre,self.__to_string_(value),post,description))
    def __ntime_inp(self):
        out = self.__stdout or sys.stdout
        if self.__ntime_dflt( self.__globals_( ) ) is not None:
             description = 'Time-range to use for each chunk (in seconds or minutes)'
             value = self.__ntime( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'ntime': value},{'ntime': self.__schema['ntime']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('ntime',pre,self.__to_string_(value),post,description))
    def __combinescans_inp(self):
        out = self.__stdout or sys.stdout
        if self.__combinescans_dflt( self.__globals_( ) ) is not None:
             description = 'Accumulate data across scans depending on the value of ntime.'
             value = self.__combinescans( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'combinescans': value},{'combinescans': self.__schema['combinescans']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('combinescans',pre,self.__to_string_(value),post,description))
    def __timecutoff_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timecutoff_dflt( self.__globals_( ) ) is not None:
             description = 'Flagging thresholds in units of deviation from the fit'
             value = self.__timecutoff( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timecutoff': value},{'timecutoff': self.__schema['timecutoff']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timecutoff',pre,self.__to_string_(value),post,description))
    def __freqcutoff_inp(self):
        out = self.__stdout or sys.stdout
        if self.__freqcutoff_dflt( self.__globals_( ) ) is not None:
             description = ' Flagging thresholds in units of deviation from the fit'
             value = self.__freqcutoff( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'freqcutoff': value},{'freqcutoff': self.__schema['freqcutoff']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('freqcutoff',pre,self.__to_string_(value),post,description))
    def __timefit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timefit_dflt( self.__globals_( ) ) is not None:
             description = 'Fitting function for the time direction (poly/line)'
             value = self.__timefit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timefit': value},{'timefit': self.__schema['timefit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timefit',pre,self.__to_string_(value),post,description))
    def __freqfit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__freqfit_dflt( self.__globals_( ) ) is not None:
             description = 'Fitting function for the frequency direction (poly/line)'
             value = self.__freqfit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'freqfit': value},{'freqfit': self.__schema['freqfit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('freqfit',pre,self.__to_string_(value),post,description))
    def __maxnpieces_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maxnpieces_dflt( self.__globals_( ) ) is not None:
             description = 'Number of pieces in the polynomial-fits (for freqfit or timefit poly)'
             value = self.__maxnpieces( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maxnpieces': value},{'maxnpieces': self.__schema['maxnpieces']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maxnpieces',pre,self.__to_string_(value),post,description))
    def __flagdimension_inp(self):
        out = self.__stdout or sys.stdout
        if self.__flagdimension_dflt( self.__globals_( ) ) is not None:
             description = 'Dimensions along which to calculate fits (freq, time, freqtime, timefreq)'
             value = self.__flagdimension( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'flagdimension': value},{'flagdimension': self.__schema['flagdimension']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('flagdimension',pre,self.__to_string_(value),post,description))
    def __usewindowstats_inp(self):
        out = self.__stdout or sys.stdout
        if self.__usewindowstats_dflt( self.__globals_( ) ) is not None:
             description = 'Calculate additional flags using sliding window statistics (none, sum, std, both)'
             value = self.__usewindowstats( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'usewindowstats': value},{'usewindowstats': self.__schema['usewindowstats']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('usewindowstats',pre,self.__to_string_(value),post,description))
    def __halfwin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__halfwin_dflt( self.__globals_( ) ) is not None:
             description = 'Half-width of sliding window to use with usewindowstats (1,2,3).'
             value = self.__halfwin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'halfwin': value},{'halfwin': self.__schema['halfwin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('halfwin',pre,self.__to_string_(value),post,description))
    def __extendflags_inp(self):
        out = self.__stdout or sys.stdout
        if self.__extendflags_dflt( self.__globals_( ) ) is not None:
             description = 'Extend flags along time, frequency and correlation.'
             value = self.__extendflags( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'extendflags': value},{'extendflags': self.__schema['extendflags']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('extendflags',pre,self.__to_string_(value),post,description))
    def __winsize_inp(self):
        out = self.__stdout or sys.stdout
        if self.__winsize_dflt( self.__globals_( ) ) is not None:
             description = 'Number of timesteps in the sliding time window'
             value = self.__winsize( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'winsize': value},{'winsize': self.__schema['winsize']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('winsize',pre,self.__to_string_(value),post,description))
    def __timedev_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timedev_dflt( self.__globals_( ) ) is not None:
             description = 'Time-series noise estimate'
             value = self.__timedev( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timedev': value},{'timedev': self.__schema['timedev']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timedev',pre,self.__to_string_(value),post,description))
    def __freqdev_inp(self):
        out = self.__stdout or sys.stdout
        if self.__freqdev_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral noise estimate'
             value = self.__freqdev( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'freqdev': value},{'freqdev': self.__schema['freqdev']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('freqdev',pre,self.__to_string_(value),post,description))
    def __timedevscale_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timedevscale_dflt( self.__globals_( ) ) is not None:
             description = 'Threshold scaling for timedev'
             value = self.__timedevscale( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timedevscale': value},{'timedevscale': self.__schema['timedevscale']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timedevscale',pre,self.__to_string_(value),post,description))
    def __freqdevscale_inp(self):
        out = self.__stdout or sys.stdout
        if self.__freqdevscale_dflt( self.__globals_( ) ) is not None:
             description = 'Threshold scaling for freqdev.'
             value = self.__freqdevscale( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'freqdevscale': value},{'freqdevscale': self.__schema['freqdevscale']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('freqdevscale',pre,self.__to_string_(value),post,description))
    def __spectralmax_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spectralmax_dflt( self.__globals_( ) ) is not None:
             description = 'Flag whole spectrum if freqdev is greater than spectralmax'
             value = self.__spectralmax( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spectralmax': value},{'spectralmax': self.__schema['spectralmax']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spectralmax',pre,self.__to_string_(value),post,description))
    def __spectralmin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spectralmin_dflt( self.__globals_( ) ) is not None:
             description = 'Flag whole spectrum if freqdev is less than spectralmin'
             value = self.__spectralmin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spectralmin': value},{'spectralmin': self.__schema['spectralmin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spectralmin',pre,self.__to_string_(value),post,description))
    def __antint_ref_antenna_inp(self):
        out = self.__stdout or sys.stdout
        if self.__antint_ref_antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Antenna of interest. Baselines with this antenna will be checked for flagged channels.'
             value = self.__antint_ref_antenna( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'antint_ref_antenna': value},{'antint_ref_antenna': self.__schema['antint_ref_antenna']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('antint_ref_antenna',pre,self.__to_string_(value),post,description))
    def __minchanfrac_inp(self):
        out = self.__stdout or sys.stdout
        if self.__minchanfrac_dflt( self.__globals_( ) ) is not None:
             description = 'Minimum fraction of flagged channels required for a baseline to be deemed as flagged'
             value = self.__minchanfrac( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'minchanfrac': value},{'minchanfrac': self.__schema['minchanfrac']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('minchanfrac',pre,self.__to_string_(value),post,description))
    def __verbose_inp(self):
        out = self.__stdout or sys.stdout
        if self.__verbose_dflt( self.__globals_( ) ) is not None:
             description = 'Print timestamps of flagged integrations to the log'
             value = self.__verbose( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'verbose': value},{'verbose': self.__schema['verbose']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('verbose',pre,self.__to_string_(value),post,description))
    def __extendpols_inp(self):
        out = self.__stdout or sys.stdout
        if self.__extendpols_dflt( self.__globals_( ) ) is not None:
             description = 'If any correlation is flagged, flag all correlations'
             value = self.__extendpols( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'extendpols': value},{'extendpols': self.__schema['extendpols']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('extendpols',pre,self.__to_string_(value),post,description))
    def __growtime_inp(self):
        out = self.__stdout or sys.stdout
        if self.__growtime_dflt( self.__globals_( ) ) is not None:
             description = 'Flag all ntime integrations if more than X percent of the timerange is flagged (0-100)'
             value = self.__growtime( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'growtime': value},{'growtime': self.__schema['growtime']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('growtime',pre,self.__to_string_(value),post,description))
    def __growfreq_inp(self):
        out = self.__stdout or sys.stdout
        if self.__growfreq_dflt( self.__globals_( ) ) is not None:
             description = 'Flag all selected channels if more than X percent of the frequency range is flagged (0-100)'
             value = self.__growfreq( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'growfreq': value},{'growfreq': self.__schema['growfreq']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('growfreq',pre,self.__to_string_(value),post,description))
    def __growaround_inp(self):
        out = self.__stdout or sys.stdout
        if self.__growaround_dflt( self.__globals_( ) ) is not None:
             description = 'Flag data based on surrounding flags'
             value = self.__growaround( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'growaround': value},{'growaround': self.__schema['growaround']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('growaround',pre,self.__to_string_(value),post,description))
    def __flagneartime_inp(self):
        out = self.__stdout or sys.stdout
        if self.__flagneartime_dflt( self.__globals_( ) ) is not None:
             description = 'Flag one timestep before and after a flagged one (True/False)'
             value = self.__flagneartime( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'flagneartime': value},{'flagneartime': self.__schema['flagneartime']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('flagneartime',pre,self.__to_string_(value),post,description))
    def __flagnearfreq_inp(self):
        out = self.__stdout or sys.stdout
        if self.__flagnearfreq_dflt( self.__globals_( ) ) is not None:
             description = 'Flag one channel before and after a flagged one (True/False)'
             value = self.__flagnearfreq( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'flagnearfreq': value},{'flagnearfreq': self.__schema['flagnearfreq']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('flagnearfreq',pre,self.__to_string_(value),post,description))
    def __minrel_inp(self):
        out = self.__stdout or sys.stdout
        if self.__minrel_dflt( self.__globals_( ) ) is not None:
             description = 'Minimum number of flags (relative)'
             value = self.__minrel( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'minrel': value},{'minrel': self.__schema['minrel']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('minrel',pre,self.__to_string_(value),post,description))
    def __maxrel_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maxrel_dflt( self.__globals_( ) ) is not None:
             description = 'Maximum number of flags (relative)'
             value = self.__maxrel( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maxrel': value},{'maxrel': self.__schema['maxrel']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maxrel',pre,self.__to_string_(value),post,description))
    def __minabs_inp(self):
        out = self.__stdout or sys.stdout
        if self.__minabs_dflt( self.__globals_( ) ) is not None:
             description = 'Minimum number of flags (absolute)'
             value = self.__minabs( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'minabs': value},{'minabs': self.__schema['minabs']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('minabs',pre,self.__to_string_(value),post,description))
    def __maxabs_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maxabs_dflt( self.__globals_( ) ) is not None:
             description = 'Maximum number of flags (absolute). Use a negative value to indicate infinity.'
             value = self.__maxabs( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maxabs': value},{'maxabs': self.__schema['maxabs']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maxabs',pre,self.__to_string_(value),post,description))
    def __spwchan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwchan_dflt( self.__globals_( ) ) is not None:
             description = 'Print summary of channels per spw'
             value = self.__spwchan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwchan': value},{'spwchan': self.__schema['spwchan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwchan',pre,self.__to_string_(value),post,description))
    def __spwcorr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwcorr_dflt( self.__globals_( ) ) is not None:
             description = 'Print summary of correlation per spw'
             value = self.__spwcorr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwcorr': value},{'spwcorr': self.__schema['spwcorr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwcorr',pre,self.__to_string_(value),post,description))
    def __basecnt_inp(self):
        out = self.__stdout or sys.stdout
        if self.__basecnt_dflt( self.__globals_( ) ) is not None:
             description = 'Print summary counts per baseline'
             value = self.__basecnt( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'basecnt': value},{'basecnt': self.__schema['basecnt']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('basecnt',pre,self.__to_string_(value),post,description))
    def __fieldcnt_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fieldcnt_dflt( self.__globals_( ) ) is not None:
             description = 'Produce a separated breakdown for each field'
             value = self.__fieldcnt( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fieldcnt': value},{'fieldcnt': self.__schema['fieldcnt']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fieldcnt',pre,self.__to_string_(value),post,description))
    def __name_inp(self):
        out = self.__stdout or sys.stdout
        if self.__name_dflt( self.__globals_( ) ) is not None:
             description = 'Name of this summary report (key in summary dictionary)'
             value = self.__name( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'name': value},{'name': self.__schema['name']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('name',pre,self.__to_string_(value),post,description))
    def __action_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Action to perform in MS and/or in inpfile (none/apply/calculate)'
        value = self.__action( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'action': value},{'action': self.__schema['action']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('action',pre,self.__to_string_(value),post,description))
    def __display_inp(self):
        out = self.__stdout or sys.stdout
        if self.__display_dflt( self.__globals_( ) ) is not None:
             description = 'Display data and/or end-of-MS reports at runtime (data/report/both).'
             value = self.__display( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'display': value},{'display': self.__schema['display']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('display',pre,self.__to_string_(value),post,description))
    def __flagbackup_inp(self):
        out = self.__stdout or sys.stdout
        if self.__flagbackup_dflt( self.__globals_( ) ) is not None:
             description = 'Back up the state of flags before the run'
             value = self.__flagbackup( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'flagbackup': value},{'flagbackup': self.__schema['flagbackup']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('flagbackup',pre,self.__to_string_(value),post,description))
    def __savepars_inp(self):
        out = self.__stdout or sys.stdout
        description = 'Save the current parameters to the FLAG_CMD table or to a file'
        value = self.__savepars( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'savepars': value},{'savepars': self.__schema['savepars']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('savepars',pre,self.__to_string_(value),post,description))
    def __cmdreason_inp(self):
        out = self.__stdout or sys.stdout
        if self.__cmdreason_dflt( self.__globals_( ) ) is not None:
             description = 'Reason to save to output file or to FLAG_CMD table.'
             value = self.__cmdreason( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'cmdreason': value},{'cmdreason': self.__schema['cmdreason']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('cmdreason',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        if self.__outfile_dflt( self.__globals_( ) ) is not None:
             description = 'Name of output file to save current parameters. If empty, save to FLAG_CMD'
             value = self.__outfile( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        if self.__overwrite_dflt( self.__globals_( ) ) is not None:
             description = 'Overwrite an existing file to save the flag commands'
             value = self.__overwrite( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))
    def __writeflags_inp(self):
        out = self.__stdout or sys.stdout
        if self.__writeflags_dflt( self.__globals_( ) ) is not None:
             description = 'Internal hidden parameter. Do not modify.'
             value = self.__writeflags( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'writeflags': value},{'writeflags': self.__schema['writeflags']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-18.18s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('writeflags',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'inpfile' in glb: del glb['inpfile']
        if 'timefit' in glb: del glb['timefit']
        if 'spwchan' in glb: del glb['spwchan']
        if 'lowerlimit' in glb: del glb['lowerlimit']
        if 'antint_ref_antenna' in glb: del glb['antint_ref_antenna']
        if 'flagnearfreq' in glb: del glb['flagnearfreq']
        if 'timecutoff' in glb: del glb['timecutoff']
        if 'name' in glb: del glb['name']
        if 'outfile' in glb: del glb['outfile']
        if 'minchanfrac' in glb: del glb['minchanfrac']
        if 'maxrel' in glb: del glb['maxrel']
        if 'writeflags' in glb: del glb['writeflags']
        if 'clipzeros' in glb: del glb['clipzeros']
        if 'field' in glb: del glb['field']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'verbose' in glb: del glb['verbose']
        if 'intent' in glb: del glb['intent']
        if 'maxabs' in glb: del glb['maxabs']
        if 'basecnt' in glb: del glb['basecnt']
        if 'tolerance' in glb: del glb['tolerance']
        if 'quackinterval' in glb: del glb['quackinterval']
        if 'extendflags' in glb: del glb['extendflags']
        if 'spectralmax' in glb: del glb['spectralmax']
        if 'halfwin' in glb: del glb['halfwin']
        if 'timedev' in glb: del glb['timedev']
        if 'ntime' in glb: del glb['ntime']
        if 'minrel' in glb: del glb['minrel']
        if 'channelavg' in glb: del glb['channelavg']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'timeavg' in glb: del glb['timeavg']
        if 'timebin' in glb: del glb['timebin']
        if 'flagdimension' in glb: del glb['flagdimension']
        if 'freqdevscale' in glb: del glb['freqdevscale']
        if 'reason' in glb: del glb['reason']
        if 'minabs' in glb: del glb['minabs']
        if 'timedevscale' in glb: del glb['timedevscale']
        if 'upperlimit' in glb: del glb['upperlimit']
        if 'growtime' in glb: del glb['growtime']
        if 'usewindowstats' in glb: del glb['usewindowstats']
        if 'array' in glb: del glb['array']
        if 'spwcorr' in glb: del glb['spwcorr']
        if 'chanbin' in glb: del glb['chanbin']
        if 'clipminmax' in glb: del glb['clipminmax']
        if 'correlation' in glb: del glb['correlation']
        if 'addantenna' in glb: del glb['addantenna']
        if 'feed' in glb: del glb['feed']
        if 'spectralmin' in glb: del glb['spectralmin']
        if 'freqdev' in glb: del glb['freqdev']
        if 'winsize' in glb: del glb['winsize']
        if 'quackincrement' in glb: del glb['quackincrement']
        if 'mode' in glb: del glb['mode']
        if 'extendpols' in glb: del glb['extendpols']
        if 'combinescans' in glb: del glb['combinescans']
        if 'fieldcnt' in glb: del glb['fieldcnt']
        if 'uvrange' in glb: del glb['uvrange']
        if 'growaround' in glb: del glb['growaround']
        if 'quackmode' in glb: del glb['quackmode']
        if 'overwrite' in glb: del glb['overwrite']
        if 'observation' in glb: del glb['observation']
        if 'clipoutside' in glb: del glb['clipoutside']
        if 'freqcutoff' in glb: del glb['freqcutoff']
        if 'tbuff' in glb: del glb['tbuff']
        if 'growfreq' in glb: del glb['growfreq']
        if 'flagbackup' in glb: del glb['flagbackup']
        if 'flagneartime' in glb: del glb['flagneartime']
        if 'savepars' in glb: del glb['savepars']
        if 'spw' in glb: del glb['spw']
        if 'maxnpieces' in glb: del glb['maxnpieces']
        if 'freqfit' in glb: del glb['freqfit']
        if 'timerange' in glb: del glb['timerange']
        if 'action' in glb: del glb['action']
        if 'cmdreason' in glb: del glb['cmdreason']
        if 'display' in glb: del glb['display']
        if 'autocorr' in glb: del glb['autocorr']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__mode_inp( )
        self.__autocorr_inp( )
        self.__inpfile_inp( )
        self.__reason_inp( )
        self.__tbuff_inp( )
        self.__spw_inp( )
        self.__field_inp( )
        self.__antenna_inp( )
        self.__uvrange_inp( )
        self.__timerange_inp( )
        self.__correlation_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__observation_inp( )
        self.__feed_inp( )
        self.__clipminmax_inp( )
        self.__datacolumn_inp( )
        self.__clipoutside_inp( )
        self.__channelavg_inp( )
        self.__chanbin_inp( )
        self.__timeavg_inp( )
        self.__timebin_inp( )
        self.__clipzeros_inp( )
        self.__quackinterval_inp( )
        self.__quackmode_inp( )
        self.__quackincrement_inp( )
        self.__tolerance_inp( )
        self.__addantenna_inp( )
        self.__lowerlimit_inp( )
        self.__upperlimit_inp( )
        self.__ntime_inp( )
        self.__combinescans_inp( )
        self.__timecutoff_inp( )
        self.__freqcutoff_inp( )
        self.__timefit_inp( )
        self.__freqfit_inp( )
        self.__maxnpieces_inp( )
        self.__flagdimension_inp( )
        self.__usewindowstats_inp( )
        self.__halfwin_inp( )
        self.__extendflags_inp( )
        self.__winsize_inp( )
        self.__timedev_inp( )
        self.__freqdev_inp( )
        self.__timedevscale_inp( )
        self.__freqdevscale_inp( )
        self.__spectralmax_inp( )
        self.__spectralmin_inp( )
        self.__antint_ref_antenna_inp( )
        self.__minchanfrac_inp( )
        self.__verbose_inp( )
        self.__extendpols_inp( )
        self.__growtime_inp( )
        self.__growfreq_inp( )
        self.__growaround_inp( )
        self.__flagneartime_inp( )
        self.__flagnearfreq_inp( )
        self.__minrel_inp( )
        self.__maxrel_inp( )
        self.__minabs_inp( )
        self.__maxabs_inp( )
        self.__spwchan_inp( )
        self.__spwcorr_inp( )
        self.__basecnt_inp( )
        self.__fieldcnt_inp( )
        self.__name_inp( )
        self.__action_inp( )
        self.__display_inp( )
        self.__flagbackup_inp( )
        self.__savepars_inp( )
        self.__cmdreason_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )
        self.__writeflags_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("flagdata.last"):
                filename = "flagdata.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, mode=None, autocorr=None, inpfile=None, reason=None, tbuff=None, spw=None, field=None, antenna=None, uvrange=None, timerange=None, correlation=None, scan=None, intent=None, array=None, observation=None, feed=None, clipminmax=None, datacolumn=None, clipoutside=None, channelavg=None, chanbin=None, timeavg=None, timebin=None, clipzeros=None, quackinterval=None, quackmode=None, quackincrement=None, tolerance=None, addantenna=None, lowerlimit=None, upperlimit=None, ntime=None, combinescans=None, timecutoff=None, freqcutoff=None, timefit=None, freqfit=None, maxnpieces=None, flagdimension=None, usewindowstats=None, halfwin=None, extendflags=None, winsize=None, timedev=None, freqdev=None, timedevscale=None, freqdevscale=None, spectralmax=None, spectralmin=None, antint_ref_antenna=None, minchanfrac=None, verbose=None, extendpols=None, growtime=None, growfreq=None, growaround=None, flagneartime=None, flagnearfreq=None, minrel=None, maxrel=None, minabs=None, maxabs=None, spwchan=None, spwcorr=None, basecnt=None, fieldcnt=None, name=None, action=None, display=None, flagbackup=None, savepars=None, cmdreason=None, outfile=None, overwrite=None, writeflags=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('flagdata.pre')
        _postfile = os.path.realpath('flagdata.last')
        _return_result_ = None
        _arguments = [vis,mode,autocorr,inpfile,reason,tbuff,spw,field,antenna,uvrange,timerange,correlation,scan,intent,array,observation,feed,clipminmax,datacolumn,clipoutside,channelavg,chanbin,timeavg,timebin,clipzeros,quackinterval,quackmode,quackincrement,tolerance,addantenna,lowerlimit,upperlimit,ntime,combinescans,timecutoff,freqcutoff,timefit,freqfit,maxnpieces,flagdimension,usewindowstats,halfwin,extendflags,winsize,timedev,freqdev,timedevscale,freqdevscale,spectralmax,spectralmin,antint_ref_antenna,minchanfrac,verbose,extendpols,growtime,growfreq,growaround,flagneartime,flagnearfreq,minrel,maxrel,minabs,maxabs,spwchan,spwcorr,basecnt,fieldcnt,name,action,display,flagbackup,savepars,cmdreason,outfile,overwrite,writeflags]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if mode is not None: local_global['mode'] = mode
            if action is not None: local_global['action'] = action
            if savepars is not None: local_global['savepars'] = savepars

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['action'] = self.__action( local_global )
            _invocation_parameters['savepars'] = self.__savepars( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['autocorr'] = self.__autocorr( _invocation_parameters ) if autocorr is None else autocorr
            _invocation_parameters['inpfile'] = self.__inpfile( _invocation_parameters ) if inpfile is None else inpfile
            _invocation_parameters['reason'] = self.__reason( _invocation_parameters ) if reason is None else reason
            _invocation_parameters['tbuff'] = self.__tbuff( _invocation_parameters ) if tbuff is None else tbuff
            _invocation_parameters['spw'] = self.__spw( _invocation_parameters ) if spw is None else spw
            _invocation_parameters['field'] = self.__field( _invocation_parameters ) if field is None else field
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['correlation'] = self.__correlation( _invocation_parameters ) if correlation is None else correlation
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['array'] = self.__array( _invocation_parameters ) if array is None else array
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['feed'] = self.__feed( _invocation_parameters ) if feed is None else feed
            _invocation_parameters['clipminmax'] = self.__clipminmax( _invocation_parameters ) if clipminmax is None else clipminmax
            _invocation_parameters['datacolumn'] = self.__datacolumn( _invocation_parameters ) if datacolumn is None else datacolumn
            _invocation_parameters['clipoutside'] = self.__clipoutside( _invocation_parameters ) if clipoutside is None else clipoutside
            _invocation_parameters['channelavg'] = self.__channelavg( _invocation_parameters ) if channelavg is None else channelavg
            _invocation_parameters['chanbin'] = self.__chanbin( _invocation_parameters ) if chanbin is None else chanbin
            _invocation_parameters['timeavg'] = self.__timeavg( _invocation_parameters ) if timeavg is None else timeavg
            _invocation_parameters['timebin'] = self.__timebin( _invocation_parameters ) if timebin is None else timebin
            _invocation_parameters['clipzeros'] = self.__clipzeros( _invocation_parameters ) if clipzeros is None else clipzeros
            _invocation_parameters['quackinterval'] = self.__quackinterval( _invocation_parameters ) if quackinterval is None else quackinterval
            _invocation_parameters['quackmode'] = self.__quackmode( _invocation_parameters ) if quackmode is None else quackmode
            _invocation_parameters['quackincrement'] = self.__quackincrement( _invocation_parameters ) if quackincrement is None else quackincrement
            _invocation_parameters['tolerance'] = self.__tolerance( _invocation_parameters ) if tolerance is None else tolerance
            _invocation_parameters['addantenna'] = self.__addantenna( _invocation_parameters ) if addantenna is None else addantenna
            _invocation_parameters['lowerlimit'] = self.__lowerlimit( _invocation_parameters ) if lowerlimit is None else lowerlimit
            _invocation_parameters['upperlimit'] = self.__upperlimit( _invocation_parameters ) if upperlimit is None else upperlimit
            _invocation_parameters['ntime'] = self.__ntime( _invocation_parameters ) if ntime is None else ntime
            _invocation_parameters['combinescans'] = self.__combinescans( _invocation_parameters ) if combinescans is None else combinescans
            _invocation_parameters['timecutoff'] = self.__timecutoff( _invocation_parameters ) if timecutoff is None else timecutoff
            _invocation_parameters['freqcutoff'] = self.__freqcutoff( _invocation_parameters ) if freqcutoff is None else freqcutoff
            _invocation_parameters['timefit'] = self.__timefit( _invocation_parameters ) if timefit is None else timefit
            _invocation_parameters['freqfit'] = self.__freqfit( _invocation_parameters ) if freqfit is None else freqfit
            _invocation_parameters['maxnpieces'] = self.__maxnpieces( _invocation_parameters ) if maxnpieces is None else maxnpieces
            _invocation_parameters['flagdimension'] = self.__flagdimension( _invocation_parameters ) if flagdimension is None else flagdimension
            _invocation_parameters['usewindowstats'] = self.__usewindowstats( _invocation_parameters ) if usewindowstats is None else usewindowstats
            _invocation_parameters['halfwin'] = self.__halfwin( _invocation_parameters ) if halfwin is None else halfwin
            _invocation_parameters['extendflags'] = self.__extendflags( _invocation_parameters ) if extendflags is None else extendflags
            _invocation_parameters['winsize'] = self.__winsize( _invocation_parameters ) if winsize is None else winsize
            _invocation_parameters['timedev'] = self.__timedev( _invocation_parameters ) if timedev is None else timedev
            _invocation_parameters['freqdev'] = self.__freqdev( _invocation_parameters ) if freqdev is None else freqdev
            _invocation_parameters['timedevscale'] = self.__timedevscale( _invocation_parameters ) if timedevscale is None else timedevscale
            _invocation_parameters['freqdevscale'] = self.__freqdevscale( _invocation_parameters ) if freqdevscale is None else freqdevscale
            _invocation_parameters['spectralmax'] = self.__spectralmax( _invocation_parameters ) if spectralmax is None else spectralmax
            _invocation_parameters['spectralmin'] = self.__spectralmin( _invocation_parameters ) if spectralmin is None else spectralmin
            _invocation_parameters['antint_ref_antenna'] = self.__antint_ref_antenna( _invocation_parameters ) if antint_ref_antenna is None else antint_ref_antenna
            _invocation_parameters['minchanfrac'] = self.__minchanfrac( _invocation_parameters ) if minchanfrac is None else minchanfrac
            _invocation_parameters['verbose'] = self.__verbose( _invocation_parameters ) if verbose is None else verbose
            _invocation_parameters['extendpols'] = self.__extendpols( _invocation_parameters ) if extendpols is None else extendpols
            _invocation_parameters['growtime'] = self.__growtime( _invocation_parameters ) if growtime is None else growtime
            _invocation_parameters['growfreq'] = self.__growfreq( _invocation_parameters ) if growfreq is None else growfreq
            _invocation_parameters['growaround'] = self.__growaround( _invocation_parameters ) if growaround is None else growaround
            _invocation_parameters['flagneartime'] = self.__flagneartime( _invocation_parameters ) if flagneartime is None else flagneartime
            _invocation_parameters['flagnearfreq'] = self.__flagnearfreq( _invocation_parameters ) if flagnearfreq is None else flagnearfreq
            _invocation_parameters['minrel'] = self.__minrel( _invocation_parameters ) if minrel is None else minrel
            _invocation_parameters['maxrel'] = self.__maxrel( _invocation_parameters ) if maxrel is None else maxrel
            _invocation_parameters['minabs'] = self.__minabs( _invocation_parameters ) if minabs is None else minabs
            _invocation_parameters['maxabs'] = self.__maxabs( _invocation_parameters ) if maxabs is None else maxabs
            _invocation_parameters['spwchan'] = self.__spwchan( _invocation_parameters ) if spwchan is None else spwchan
            _invocation_parameters['spwcorr'] = self.__spwcorr( _invocation_parameters ) if spwcorr is None else spwcorr
            _invocation_parameters['basecnt'] = self.__basecnt( _invocation_parameters ) if basecnt is None else basecnt
            _invocation_parameters['fieldcnt'] = self.__fieldcnt( _invocation_parameters ) if fieldcnt is None else fieldcnt
            _invocation_parameters['name'] = self.__name( _invocation_parameters ) if name is None else name
            _invocation_parameters['display'] = self.__display( _invocation_parameters ) if display is None else display
            _invocation_parameters['flagbackup'] = self.__flagbackup( _invocation_parameters ) if flagbackup is None else flagbackup
            _invocation_parameters['cmdreason'] = self.__cmdreason( _invocation_parameters ) if cmdreason is None else cmdreason
            _invocation_parameters['outfile'] = self.__outfile( _invocation_parameters ) if outfile is None else outfile
            _invocation_parameters['overwrite'] = self.__overwrite( _invocation_parameters ) if overwrite is None else overwrite
            _invocation_parameters['writeflags'] = self.__writeflags( _invocation_parameters ) if writeflags is None else writeflags

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['autocorr'] = self.__autocorr( self.__globals_( ) )
            _invocation_parameters['inpfile'] = self.__inpfile( self.__globals_( ) )
            _invocation_parameters['reason'] = self.__reason( self.__globals_( ) )
            _invocation_parameters['tbuff'] = self.__tbuff( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['clipoutside'] = self.__clipoutside( self.__globals_( ) )
            _invocation_parameters['channelavg'] = self.__channelavg( self.__globals_( ) )
            _invocation_parameters['chanbin'] = self.__chanbin( self.__globals_( ) )
            _invocation_parameters['timeavg'] = self.__timeavg( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['clipzeros'] = self.__clipzeros( self.__globals_( ) )
            _invocation_parameters['quackinterval'] = self.__quackinterval( self.__globals_( ) )
            _invocation_parameters['quackmode'] = self.__quackmode( self.__globals_( ) )
            _invocation_parameters['quackincrement'] = self.__quackincrement( self.__globals_( ) )
            _invocation_parameters['tolerance'] = self.__tolerance( self.__globals_( ) )
            _invocation_parameters['addantenna'] = self.__addantenna( self.__globals_( ) )
            _invocation_parameters['lowerlimit'] = self.__lowerlimit( self.__globals_( ) )
            _invocation_parameters['upperlimit'] = self.__upperlimit( self.__globals_( ) )
            _invocation_parameters['ntime'] = self.__ntime( self.__globals_( ) )
            _invocation_parameters['combinescans'] = self.__combinescans( self.__globals_( ) )
            _invocation_parameters['timecutoff'] = self.__timecutoff( self.__globals_( ) )
            _invocation_parameters['freqcutoff'] = self.__freqcutoff( self.__globals_( ) )
            _invocation_parameters['timefit'] = self.__timefit( self.__globals_( ) )
            _invocation_parameters['freqfit'] = self.__freqfit( self.__globals_( ) )
            _invocation_parameters['maxnpieces'] = self.__maxnpieces( self.__globals_( ) )
            _invocation_parameters['flagdimension'] = self.__flagdimension( self.__globals_( ) )
            _invocation_parameters['usewindowstats'] = self.__usewindowstats( self.__globals_( ) )
            _invocation_parameters['halfwin'] = self.__halfwin( self.__globals_( ) )
            _invocation_parameters['extendflags'] = self.__extendflags( self.__globals_( ) )
            _invocation_parameters['winsize'] = self.__winsize( self.__globals_( ) )
            _invocation_parameters['timedev'] = self.__timedev( self.__globals_( ) )
            _invocation_parameters['freqdev'] = self.__freqdev( self.__globals_( ) )
            _invocation_parameters['timedevscale'] = self.__timedevscale( self.__globals_( ) )
            _invocation_parameters['freqdevscale'] = self.__freqdevscale( self.__globals_( ) )
            _invocation_parameters['spectralmax'] = self.__spectralmax( self.__globals_( ) )
            _invocation_parameters['spectralmin'] = self.__spectralmin( self.__globals_( ) )
            _invocation_parameters['antint_ref_antenna'] = self.__antint_ref_antenna( self.__globals_( ) )
            _invocation_parameters['minchanfrac'] = self.__minchanfrac( self.__globals_( ) )
            _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
            _invocation_parameters['extendpols'] = self.__extendpols( self.__globals_( ) )
            _invocation_parameters['growtime'] = self.__growtime( self.__globals_( ) )
            _invocation_parameters['growfreq'] = self.__growfreq( self.__globals_( ) )
            _invocation_parameters['growaround'] = self.__growaround( self.__globals_( ) )
            _invocation_parameters['flagneartime'] = self.__flagneartime( self.__globals_( ) )
            _invocation_parameters['flagnearfreq'] = self.__flagnearfreq( self.__globals_( ) )
            _invocation_parameters['minrel'] = self.__minrel( self.__globals_( ) )
            _invocation_parameters['maxrel'] = self.__maxrel( self.__globals_( ) )
            _invocation_parameters['minabs'] = self.__minabs( self.__globals_( ) )
            _invocation_parameters['maxabs'] = self.__maxabs( self.__globals_( ) )
            _invocation_parameters['spwchan'] = self.__spwchan( self.__globals_( ) )
            _invocation_parameters['spwcorr'] = self.__spwcorr( self.__globals_( ) )
            _invocation_parameters['basecnt'] = self.__basecnt( self.__globals_( ) )
            _invocation_parameters['fieldcnt'] = self.__fieldcnt( self.__globals_( ) )
            _invocation_parameters['name'] = self.__name( self.__globals_( ) )
            _invocation_parameters['action'] = self.__action( self.__globals_( ) )
            _invocation_parameters['display'] = self.__display( self.__globals_( ) )
            _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
            _invocation_parameters['savepars'] = self.__savepars( self.__globals_( ) )
            _invocation_parameters['cmdreason'] = self.__cmdreason( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['writeflags'] = self.__writeflags( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-18s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#flagdata( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _flagdata_t( _invocation_parameters['vis'],_invocation_parameters['mode'],_invocation_parameters['autocorr'],_invocation_parameters['inpfile'],_invocation_parameters['reason'],_invocation_parameters['tbuff'],_invocation_parameters['spw'],_invocation_parameters['field'],_invocation_parameters['antenna'],_invocation_parameters['uvrange'],_invocation_parameters['timerange'],_invocation_parameters['correlation'],_invocation_parameters['scan'],_invocation_parameters['intent'],_invocation_parameters['array'],_invocation_parameters['observation'],_invocation_parameters['feed'],_invocation_parameters['clipminmax'],_invocation_parameters['datacolumn'],_invocation_parameters['clipoutside'],_invocation_parameters['channelavg'],_invocation_parameters['chanbin'],_invocation_parameters['timeavg'],_invocation_parameters['timebin'],_invocation_parameters['clipzeros'],_invocation_parameters['quackinterval'],_invocation_parameters['quackmode'],_invocation_parameters['quackincrement'],_invocation_parameters['tolerance'],_invocation_parameters['addantenna'],_invocation_parameters['lowerlimit'],_invocation_parameters['upperlimit'],_invocation_parameters['ntime'],_invocation_parameters['combinescans'],_invocation_parameters['timecutoff'],_invocation_parameters['freqcutoff'],_invocation_parameters['timefit'],_invocation_parameters['freqfit'],_invocation_parameters['maxnpieces'],_invocation_parameters['flagdimension'],_invocation_parameters['usewindowstats'],_invocation_parameters['halfwin'],_invocation_parameters['extendflags'],_invocation_parameters['winsize'],_invocation_parameters['timedev'],_invocation_parameters['freqdev'],_invocation_parameters['timedevscale'],_invocation_parameters['freqdevscale'],_invocation_parameters['spectralmax'],_invocation_parameters['spectralmin'],_invocation_parameters['antint_ref_antenna'],_invocation_parameters['minchanfrac'],_invocation_parameters['verbose'],_invocation_parameters['extendpols'],_invocation_parameters['growtime'],_invocation_parameters['growfreq'],_invocation_parameters['growaround'],_invocation_parameters['flagneartime'],_invocation_parameters['flagnearfreq'],_invocation_parameters['minrel'],_invocation_parameters['maxrel'],_invocation_parameters['minabs'],_invocation_parameters['maxabs'],_invocation_parameters['spwchan'],_invocation_parameters['spwcorr'],_invocation_parameters['basecnt'],_invocation_parameters['fieldcnt'],_invocation_parameters['name'],_invocation_parameters['action'],_invocation_parameters['display'],_invocation_parameters['flagbackup'],_invocation_parameters['savepars'],_invocation_parameters['cmdreason'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'],_invocation_parameters['writeflags'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

flagdata = _flagdata( )

