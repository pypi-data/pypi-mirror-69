##################### generated by xml-casa (v2) from sdcal.xml #####################
##################### 48f8cc5c97934e1b62fbd0ff10ee6eeb ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import sdcal as _sdcal_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdcal:
    """
    sdcal ---- MS SD calibration task

    
    Task sdcal implements a single-dish data calibration scheme similar to that of
    interferometry, i.e., generate calibration tables (caltables) and apply them.
    Available calibration modes are:
    'ps', 'otfraster', 'otf' for sky calibration
    'tsys' for Tsys calibration
    Each mode generates a caltable.
    Caltables can be applied to the data by combining calibration
    modes with the keyword 'apply'.
    
    Calibration is applicable for fast moving source even like the moon which moves
    quickly outside of the field of view (see the note of 'otf' mode in below).
    
    Calibration mode must be set in accordance with the observing mode
    of the data. Use case for each mode is as follows:
    'ps': position switch (including OTF) with explicit
    reference (OFF) spectra
    'otfraster': raster OTF scan without explicit OFFs
    'otf': non-raster OTF (e.g. double-circle) scan without explicit OFFs
    
    So, if the data contains explicit reference spectra, 'ps' should
    be used. Otherwise, 'otfraster' or 'otf' should be used.
    In 'otfraster' and 'otf' modes, an edge marker automatically marks spectra from
    specific regions of the observation pattern as reference (OFF) spectra.
    These specific regions are:
    - in 'otfraster' mode: regions near the beginning and the end of the raster
    scan lines.
    - in 'otf' mode: regions near the periphery of the observation pattern.
    Note: The 'otfraster' mode is designed for OTF observations without explicit OFF
    spectra. However, it should work even if explicit reference spectra exist.
    In that case, these spectra are ignored and spectra marked by edge marker are
    used as reference.
    Note: Detection of periphery scans in 'otf' mode is available for fast moving
    sources, e.g., Sun, Moon. It is often the case antennas keep track of source motion
    during the observations of moving sources so that the source is always at the map center.
    In order to handle such observations, pheriphery search is done in the source frame
    for known moving sources, in which the source is always at a rest position.
    
    Apart from the way reference spectra are selected, the procedure to derive
    calibrated spectra is the same for all modes. Selected (or preset)
    OFF integrations are separated based on continuity in time domain,
    averaged in each segment, and then interpolated to timestamps for ON
    integrations. Effectively, it means that OFF integrations are
    averaged by each OFF spectrum for 'ps' mode, averaged by either ends
    of each raster row for 'otfraster' mode. The formula for calibrated
    spectrum is
    
    Tsys * (ON - OFF) / OFF.
    
    

    --------- parameter descriptions ---------------------------------------------

    infile     name of input SD dataset (must be MS)
    calmode    SD calibration mode
    fraction   fraction of the OFF data to mark
    noff       number of the OFF data to mark
    width      width of the pixel for edge detection
    elongated  whether observed area is elongated in one direction or not
    applytable (List of) sky and/or tsys tables
    interp     Interpolation type in time[,freq]. Valid options for time are "nearest", "linear", and "cubic", while valid options for frequency include "nearest", "linear", "cspline", or any numeric string that indicates an order of polynomial interpolation. You can specify interpolation type for time and frequency separately by joining two of the above options by comma (e.g., "linear,cspline").
    spwmap     A dictionary indicating spw combinations to apply Tsys calibration to target. The key should be spw for Tsys calibration and its associated value must be a list of science spws to be applied.
    outfile    name of output file (See a WARNING in help)
    overwrite  overwrite the output file if already exists
    field      select data by field IDs and names, e.g. "3C2*" ("" = all)
    spw        select data by spw IDs (spectral windows), e.g., "3,5,7" ("" = all)
    scan       select data by scan numbers, e.g. "21~23" (""=all)
    intent     select data by observation intent, e.g. "OBSERVE_TARGET#ON_SOURCE" (""=all)
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infile -- Name of input SD dataset
    calmode -- Calibration mode. If you want to generate calibration table
    or apply existing calibration tables, set calmode to a simple
    string. If you want to calibrate data on-the-fly, set calmode
    to a composite (comma-separated) string. So far, sky calibration has
    three types, 'ps', 'otfraster' and 'otf'. If observation is
    configured to observe reference position, calmode must be
    'ps'. Otherwise, 'otfraster' or 'otf' should be used.
    options: 'ps','otfraster','otf','tsys','apply'
    default: 'ps'
    example: Here is an example for composite calmode.
    'ps,apply' (do sky cal and apply)
    'ps,tsys,apply' (do sky and Tsys cal and apply)
    >>> calmode expandable parameter
    fraction -- Edge marker parameter of 'otfraster'.
    Specify a number of OFF integrations (at each
    side of the raster rows in 'otfraster' mode)
    as a fraction of total number of integrations.
    In 'otfraster' mode, number of integrations
    to be marked as OFF, n_off, is determined by
    the following formula,
    
    n_off = floor(fraction * n),
    
    where n is number of integrations per raster
    row. Note that n_off from both sides will be
    marked as OFF so that twice of specified
    fraction will be marked at most. For example,
    if you specify fraction='10%', resultant
    fraction of OFF integrations will be 20% at
    most.
    default: '10%'
    options: '20%' in string style or float value less
    than 1.0 (e.g. 0.15).
    'auto' is available only for 'otfraster'.
    noff -- Edge marking parameter for 'otfraster'.
    It is used to specify a number of OFF spectra near
    edge directly. Value of noff comes before setting
    by fraction. Note that n_off from both sides will
    be marked as OFF so that twice of specified noff
    will be marked at most.
    default: -1 (use fraction)
    options: any positive integer
    
    applytable -- List of sky/Tsys calibration tables you want to
    apply.
    default: ''
    interp -- Interpolation method in time and frequency axis.
    Set comma separated method strings if you want
    to use different interpolation in time and
    frequency.
    options: 'linear', 'nearest', 'cspline', 'cubic',
    any numeric string indicating an order
    of polynomial.
    Note that 'cubic' is available for time only,
    and that 'cspline' and numeric strings are
    available for frequency only.
    default: '' (linear in time and frequency)
    example: 'linear,cspline' (linear in time, cubic
    spline in frequency)
    'linear,3' (linear in time, third order
    polynomial in frequency)
    'nearest' (nearest in time and frequency)
    spwmap -- Dictionary defining transfer of Tsys calibration.
    Key must be spw for Tsys and its value must be
    a list of spws for science target.
    default: {}
    example: {1: [5,6], 3: [7,8]}
    Tsys in spw 1 is transferred to spws 5 and 6
    while Tsys in spw 3 is to spws 7 and 8.
    field -- select data by field IDs and names
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 0 or field named 3C273)
    this selection is in addition to the other selections to data
    spw -- select data by spw IDs (spectral windows)
    NOTE this task only supports spw ID selction and ignores channel
    selection.
    default: '' (use all spws and channels)
    example: spw='3,5,7' (spw IDs 3,5,7; all channels)
    spw='<2' (spw IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (spw IDs with the center frequencies in range 30-45GHz; all channels)
    this selection is in addition to the other selections to data
    NOTE spw input must be '' (''= all) in calmode='tsys'.
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    this selection is in addition to the other selections to data
    NOTE scan input must be '' (''= all) in calmode='tsys'.
    outfile -- Name of output file
    NOTE if you omit and calmode doesn't include 'apply', the task
    will use default outfile name based on infile and predefined
    suffix ('_sky' for sky, '_tsys' for Tsys).
    default: '' (<infile>_<suffix> for calibration)
    overwrite -- overwrite the output file if already exists
    options: (bool) True,False
    default: False
    NOTE this parameter is ignored when outform='ASCII'
    
    
    DESCRIPTION:
    
    Task sdcal is an implementation of a calibration scheme like as
    interferometry, i.e., generate caltables and apply them. Available
    calibration modes are 'ps', 'otfraster', 'otf', and 'tsys'.
    Those modes generates caltables for sky or Tsys calibration.
    The caltables can be applied to the data by using calmode 'apply'.
    
    First three calibration modes, 'ps', 'otfraster', and 'otf',
    generate sky calibration tables. The user should choose appropriate
    calibration mode depending on the data. Use case for each mode is
    as follows:
    
    'ps': position switch (including OTF) with explicit
    reference (OFF) spectra
    'otfraster': raster OTF scan without explicit OFFs
    'otf': fast-scan observation with Lissajous or
    double-circle trajectory
    
    So, if the data contains explicit reference spectra, 'ps' should
    be used. The 'otfraster' mode is appropriate for raster OTF.
    For non-raster OTF data, 'otf' mode is available to support fast-
    scanning observation. In 'otfraster' mode, the task first try to
    find several integrations near edge as OFF spectra, then the data
    are calibrated using those OFFs. If the observing pattern is raster,
    you should use the 'otfraster' mode to calibrate data.
    The 'otfraster' mode is designed for OTF observations without
    explicit OFF spectra. However, these modes should work even if
    explicit reference spectra exist. In this case, these spectra will be
    ignored and spectra near edges detected by edge marker will be used as
    reference. In 'otf' mode, the task detects integrations near edges of
    observed area, and detected integrations are regarded as OFFs.
    This mode is specifically designed for fast-scan mode, which takes
    the data contiguously by moving antenna along trajectory that
    imitates random spatial data sampling, which is implemented as
    either Lissajous or double-circle pattern.
    
    
    Except for how to choose OFFs, the procedure to derive calibrated
    spectra is common for the above three modes. Selected (or preset) OFF
    integrations are separated by its continuity in time domain, averaged in
    each segment, then interpolated to timestamps for ON integrations.
    Effectively, it means that OFF integrations are averaged by each
    OFF spectrum for 'ps' mode, averaged by either ends of each raster
    row for 'otfraster' mode. The formula for calibrated spectrum
    is
    
    Tsys * (ON - OFF) / OFF.
    
    You can calibrate data on-the-fly like sdcal task by setting
    calmode to a composite calmode string separated by comma.
    For example, calmode='ps,apply' means doing sky calibration and
    apply it on-the-fly. In this case, caltable is generated as a
    temporary plain table and will be deleted at the end.
    Allowed calibration modes in this task is as follows:
    
    ps
    generate sky caltable using 'ps' mode
    otfraster
    generate sky caltable using 'otfraster' mode
    otf
    generate sky caltable using 'otf' mode
    tsys
    generate tsys caltable
    apply
    apply caltables specified by applytable parameter
    ps,apply
    generate temporary sky caltable using 'ps' mode and
    apply it. also apply caltables specified by applytable
    ps,tsys,apply
    generate temporary sky caltable using 'ps' mode as well
    as temporary tsys caltable, and apply them.
    otfraster,apply
    generate temporary sky caltable using 'otfraster' mode
    and apply it. also apply caltables specified by applytable
    otfraster,tsys,apply
    generate temporary sky caltable using 'otfraster' mode
    as well as temporary tsys caltable, and apply them.
    otf,apply
    generate temporary sky caltable using 'otf' mode
    and apply it. also apply caltables specified by applytable
    otf,tsys,apply
    generate temporary sky caltable using 'otf' mode
    as well as temporary tsys caltable, and apply them.
    
    There are several control parameters for sky/Tsys calibration and
    application of caltables. See the above parameter description.
    
    In ALMA, Tsys measurement is usually done using different spectral
    setup from spectral windows for science target. In this case, sdcal
    transfers Tsys values to science spectral windows in the application
    stage. To do that, the user has to give a list of spectral windows for
    Tsys measurement as well as mapping between spectral windows for Tsys
    measurement and scicence target. These can be specified by parameters
    'tsysspw' and 'spwmap', which are defined as subparameters of 'calmode'.
    For example, suppose that Tsys measurements for science windows 17, 19,
    21, and 23 are done in spw 9, 11, 13, and 15, respectively.
    In this case, tsysspw and spwmap should be specified as follows:
    
    tsysspw = '9,11,13,15'
    spwmap = {9:[17],11:[19],13:[21],15:[23]}
    
    Below is an example of full specification of task parameters for calmode
    of 'ps,tsys,apply':
    
    default(sdcal)
    infile = 'foo.ms'
    calmode = 'ps,tsys,apply'
    spw = ''
    tsysspw = '9,11,13,15'
    spwmap = {9:[17],11:[19],13:[21],15:[23]}
    sdcal()
    
    Note that, in contrast to applycal task, spwmap must be a dictionary
    with Tsys spectral window as key and a list of corresponding science
    spectral window as value. Note also that the parameter 'spw' should
    not be used to specify a list of spectral windows for Tsys measurement.
    It is intended to select data to be calibrated so that the list should
    contain spectral windows for both science target and Tsys measurement.
    The task will fail if you use 'spw' instead of 'tsysspw'.
    
    
    For Tsys calibration, the user is able to choose whether Tsys is
    averaged in spectral axis or not. If tsysavg is False (default),
    resulting Tsys is spectral value. On the other hand, when tsysavg
    is True, Tsys is averaged in spectral axis before output. The channel
    range for averaging is whole channels by default. If channel range is
    specified by tsysspw string, it is used for averaging. The user can
    specify channel range with ms selection syntax. For example,
    
    tsysspw = '1:0~100'
    
    specifies spw 1 for Tsys calibration and channel range between channel
    0 and 100 for averaging. You can specify more than one ranges per spw.
    
    tsysspw = '1:0~100;200~400'
    
    In this case, selected ranges are between 0 and 100 plus 200 and 400.
    Note that even if multiple ranges are selected, the task average whole
    ranges together and output single averaged value. You can specify multiple
    spws by separating comma.
    
    tsysspw = '1:0~100,3:400~500'
    Note that specified channel range is ignored if tsysavg is False.
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """ MS SD calibration task"""

    __schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'calmode': {'type': 'cStr'}, 'fraction': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'noff': {'type': 'cInt'}, 'width': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'elongated': {'type': 'cBool'}, 'applytable': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'interp': {'type': 'cStr'}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'intent': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __calmode_dflt( self, glb ):
        return 'ps'

    def __calmode( self, glb ):
        if 'calmode' in glb: return glb['calmode']
        return 'ps'

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __width_dflt( self, glb ):
        return float(0.5)

    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        return float(0.5)

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __elongated_dflt( self, glb ):
        return False

    def __elongated( self, glb ):
        if 'elongated' in glb: return glb['elongated']
        return False

    def __infile_dflt( self, glb ):
        return ''

    def __infile( self, glb ):
        if 'infile' in glb: return glb['infile']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __outfile_dflt( self, glb ):
        if self.__calmode( glb ) == "ps": return ""
        if self.__calmode( glb ) == "otfraster": return ""
        if self.__calmode( glb ) == "otf": return ""
        if self.__calmode( glb ) == "tsys": return ""
        return None
    def __fraction_dflt( self, glb ):
        if self.__calmode( glb ) == "otfraster": return "10%"
        if self.__calmode( glb ) == "otf": return "10%"
        if self.__calmode( glb ) == "otfraster,apply": return "10%"
        if self.__calmode( glb ) == "otfraster,tsys,apply": return "10%"
        if self.__calmode( glb ) == "otf,apply": return "10%"
        if self.__calmode( glb ) == "otf,tsys,apply": return "10%"
        return None
    def __intent_dflt( self, glb ):
        if self.__calmode( glb ) == "otfraster": return "OBSERVE_TARGET#ON_SOURCE"
        if self.__calmode( glb ) == "otf": return "OBSERVE_TARGET#ON_SOURCE"
        if self.__calmode( glb ) == "otfraster,apply": return "OBSERVE_TARGET#ON_SOURCE"
        if self.__calmode( glb ) == "otf,apply": return "OBSERVE_TARGET#ON_SOURCE"
        return None
    def __spwmap_dflt( self, glb ):
        if self.__calmode( glb ) == "apply": return 
        if self.__calmode( glb ) == "ps,apply": return 
        if self.__calmode( glb ) == "tsys,apply": return 
        if self.__calmode( glb ) == "ps,tsys,apply": return 
        if self.__calmode( glb ) == "otfraster,apply": return 
        if self.__calmode( glb ) == "otfraster,tsys,apply": return 
        if self.__calmode( glb ) == "otf,apply": return 
        if self.__calmode( glb ) == "otf,tsys,apply": return 
        return None
    def __noff_dflt( self, glb ):
        if self.__calmode( glb ) == "otfraster": return int(-1)
        if self.__calmode( glb ) == "otfraster,apply": return int(-1)
        if self.__calmode( glb ) == "otfraster,tsys,apply": return int(-1)
        return None
    def __interp_dflt( self, glb ):
        if self.__calmode( glb ) == "apply": return ""
        if self.__calmode( glb ) == "ps,apply": return ""
        if self.__calmode( glb ) == "tsys,apply": return ""
        if self.__calmode( glb ) == "ps,tsys,apply": return ""
        if self.__calmode( glb ) == "otfraster,apply": return ""
        if self.__calmode( glb ) == "otfraster,tsys,apply": return ""
        if self.__calmode( glb ) == "otf,apply": return ""
        if self.__calmode( glb ) == "otf,tsys,apply": return ""
        return None
    def __applytable_dflt( self, glb ):
        if self.__calmode( glb ) == "apply": return ""
        if self.__calmode( glb ) == "ps,apply": return ""
        if self.__calmode( glb ) == "tsys,apply": return ""
        if self.__calmode( glb ) == "ps,tsys,apply": return ""
        if self.__calmode( glb ) == "otfraster,apply": return ""
        if self.__calmode( glb ) == "otfraster,tsys,apply": return ""
        if self.__calmode( glb ) == "otf,apply": return ""
        if self.__calmode( glb ) == "otf,tsys,apply": return ""
        return None
    def __overwrite_dflt( self, glb ):
        if self.__calmode( glb ) == "ps": return bool(False)
        if self.__calmode( glb ) == "otfraster": return bool(False)
        if self.__calmode( glb ) == "otf": return bool(False)
        if self.__calmode( glb ) == "tsys": return bool(False)
        return None

    #--------- return subparam values -------------------------------------------------
    def __fraction( self, glb ):
        if 'fraction' in glb: return glb['fraction']
        dflt = self.__fraction_dflt( glb )
        if dflt is not None: return dflt
        return '10%'
    def __noff( self, glb ):
        if 'noff' in glb: return glb['noff']
        dflt = self.__noff_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return float(0.5)
    def __elongated( self, glb ):
        if 'elongated' in glb: return glb['elongated']
        dflt = self.__elongated_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __applytable( self, glb ):
        if 'applytable' in glb: return glb['applytable']
        dflt = self.__applytable_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return { }
    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        dflt = self.__outfile_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        dflt = self.__overwrite_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __infile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__infile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'infile': value},{'infile': self.__schema['infile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('infile',pre,self.__to_string_(value),post,description))
    def __calmode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'SD calibration mode ["ps","otfraster","otf","tsys","apply", and allowed combinations]'
        value = self.__calmode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'calmode': value},{'calmode': self.__schema['calmode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('calmode',pre,self.__to_string_(value),post,description))
    def __fraction_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fraction_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fraction( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fraction': value},{'fraction': self.__schema['fraction']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fraction',pre,self.__to_string_(value),post,description))
    def __noff_inp(self):
        out = self.__stdout or sys.stdout
        if self.__noff_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__noff( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'noff': value},{'noff': self.__schema['noff']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('noff',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__width( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __elongated_inp(self):
        out = self.__stdout or sys.stdout
        if self.__elongated_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__elongated( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'elongated': value},{'elongated': self.__schema['elongated']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('elongated',pre,self.__to_string_(value),post,description))
    def __applytable_inp(self):
        out = self.__stdout or sys.stdout
        if self.__applytable_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__applytable( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'applytable': value},{'applytable': self.__schema['applytable']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('applytable',pre,self.__to_string_(value),post,description))
    def __interp_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interp( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interp',pre,self.__to_string_(value),post,description))
    def __spwmap_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwmap',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        if self.__outfile_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__outfile( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        if self.__overwrite_dflt( self.__globals_( ) ) is not None:
             description = 'overwrite the output file if already exists [True, False]'
             value = self.__overwrite( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__intent( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'infile' in glb: del glb['infile']
        if 'outfile' in glb: del glb['outfile']
        if 'fraction' in glb: del glb['fraction']
        if 'elongated' in glb: del glb['elongated']
        if 'field' in glb: del glb['field']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'scan' in glb: del glb['scan']
        if 'noff' in glb: del glb['noff']
        if 'interp' in glb: del glb['interp']
        if 'applytable' in glb: del glb['applytable']
        if 'calmode' in glb: del glb['calmode']
        if 'overwrite' in glb: del glb['overwrite']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__infile_inp( )
        self.__calmode_inp( )
        self.__fraction_inp( )
        self.__noff_inp( )
        self.__width_inp( )
        self.__elongated_inp( )
        self.__applytable_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__intent_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("sdcal.last"):
                filename = "sdcal.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, infile=None, calmode=None, fraction=None, noff=None, width=None, elongated=None, applytable=None, interp=None, spwmap=None, outfile=None, overwrite=None, field=None, spw=None, scan=None, intent=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdcal.pre')
        _postfile = os.path.realpath('sdcal.last')
        _return_result_ = None
        _arguments = [infile,calmode,fraction,noff,width,elongated,applytable,interp,spwmap,outfile,overwrite,field,spw,scan,intent]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infile is not None: local_global['infile'] = infile
            if calmode is not None: local_global['calmode'] = calmode
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infile'] = self.__infile( local_global )
            _invocation_parameters['calmode'] = self.__calmode( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['fraction'] = self.__fraction( _invocation_parameters ) if fraction is None else fraction
            _invocation_parameters['noff'] = self.__noff( _invocation_parameters ) if noff is None else noff
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['elongated'] = self.__elongated( _invocation_parameters ) if elongated is None else elongated
            _invocation_parameters['applytable'] = self.__applytable( _invocation_parameters ) if applytable is None else applytable
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap
            _invocation_parameters['outfile'] = self.__outfile( _invocation_parameters ) if outfile is None else outfile
            _invocation_parameters['overwrite'] = self.__overwrite( _invocation_parameters ) if overwrite is None else overwrite
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
            _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
            _invocation_parameters['fraction'] = self.__fraction( self.__globals_( ) )
            _invocation_parameters['noff'] = self.__noff( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['elongated'] = self.__elongated( self.__globals_( ) )
            _invocation_parameters['applytable'] = self.__applytable( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _sdcal_t( _invocation_parameters['infile'],_invocation_parameters['calmode'],_invocation_parameters['fraction'],_invocation_parameters['noff'],_invocation_parameters['width'],_invocation_parameters['elongated'],_invocation_parameters['applytable'],_invocation_parameters['interp'],_invocation_parameters['spwmap'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['scan'],_invocation_parameters['intent'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

sdcal = _sdcal( )

