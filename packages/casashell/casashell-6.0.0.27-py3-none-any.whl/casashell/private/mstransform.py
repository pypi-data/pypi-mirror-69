##################### generated by xml-casa (v2) from mstransform.xml ###############
##################### 4805c4cf82aa36f3a1386405e2501314 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import mstransform as _mstransform_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _mstransform:
    """
    mstransform ---- Split the MS, combine/separate/regrid spws and do channel and time averaging

    
    
    The task mstransform can do the same functionalities available
    in cvel, partition, hanningsmooth and split without the need to read and write
    the output to disk multiple times. The main features of this task
    are:
    
    * take an input MS or Multi-MS (MMS)
    * ability to create an output MS or MMS
    * spw combination and separation
    * channel averaging taking flags and weights into account
    * time averaging taking flags and weights into account
    * reference frame transformation
    * Hanning smoothing
    
    All these transformations will be applied on the fly without any writing to
    disk to optimize I/O. The user can ask to create a Multi-MS in parallel using CASA's
    cluster infrastructure using the parameter createmms. See MPIInterface
    for more information on the cluster infrastructure.
    
    This task is implemented in a modular way to preserve the functionalities
    available in the replaced tasks. One can choose which functionality to apply
    or apply all of them by setting the corresponding parameters to True. Note
    that there is an order in which the transformations are applied to the data that
    makes logical sense on the point of view of the data analysis.
    
    This task can create a multi-MS as the output. General selection
    parameters are included, and one or all of the various data columns
    (DATA, LAG_DATA and/or FLOAT_DATA, and possibly MODEL_DATA and/or
    CORRECTED_DATA) can be selected. It can also be used to create a normal
    MS, split-based on the given data selection parameters.
    
    The mstransform task creates a Multi-MS in parallel, using the CASA MPI framework.
    The user should start CASA as follows in order to run it in parallel.
    
    1) Start CASA on a single node with 8 engines. The first engine will be used as the
    MPIClient, where the user will see the CASA prompt. All other engines will be used
    as MPIServers and will process the data in parallel.
    mpicasa -n 8 casa --nogui --log2term
    mstransform(.....)
    
    2) Running on a group of nodes in a cluster.
    mpicasa -hostfile user_hostfile casa ....
    mstransform(.....)
    
    where user_hostfile contains the names of the nodes and the number of engines to use
    in each one of them. Example:
    pc001234a, slots=5
    pc001234b, slots=4
    
    If CASA is started without mpicasa, it is still possible to create an MMS, but
    the processing will be done in sequential.
    
    The resulting WEIGHT_SPECTRUM produced by mstransform is in the statistical
    sense correct for the simple cases of channel average and time average, but not for
    the general re-gridding case, in which the error propagation formulas applicable for
    WEIGHT_SPECTRUM are yet to be defined. Currently, as in cvel and in the imager,
    WEIGHT_SPECTRUM is transformed in the same way as the other data columns.
    Notice that this is not formally correct from the statistical point of view,
    but is a good approximation at this stage.
    
    NOTE: the input/output in mstransform have a one-to-one relation.
    input MS  --  output MS
    input MMS --  output MMS
    
    unless the user sets the parameter createmms to True to create the following:
    input MS  --  output MMS

    --------- parameter descriptions ---------------------------------------------

    vis                   Name of input Measurement set or Multi-MS.
    outputvis             Name of output Measurement Set or Multi-MS.
    createmms             Create a multi-MS output from an input MS.
    separationaxis        Axis to do parallelization across(scan,spw,auto,baseline).
    numsubms              The number of Sub-MSs to create (auto or any number)
    tileshape             List with 1 or 3 elements giving the tile shape of the disk data columns.
    field                 Select field using ID(s) or name(s).
    spw                   Select spectral window/channels.
    scan                  Select data by scan numbers.
    antenna               Select data based on antenna/baseline.
    correlation           Correlation: '' ==> all, correlation="XX,YY".
    timerange             Select data by time range.
    intent                Select data by scan intent.
    array                 Select (sub)array(s) by array ID number.
    uvrange               Select data by baseline length.
    observation           Select by observation ID(s).
    feed                  Multi-feed numbers: Not yet implemented.
    datacolumn            Which data column(s) to process.
    realmodelcol          Make real a virtual MODEL column.
    keepflags             Keep *completely flagged rows* or drop them from the output.
    usewtspectrum         Force creation of the columns WEIGHT_SPECTRUM and SIGMA_SPECTRUM in the output MS, even if not present in the input MS.
    combinespws           Combine the input spws into a new output spw. Only supported when the number of channels is the same for all the spws.
    chanaverage           Average data in channels.
    chanbin               Width (bin) of input channels to average to form an output channel.
    hanning               Hanning smooth data to remove Gibbs ringing.
    regridms              Transform channel labels and visibilities to a different spectral reference frame. Notice that u,v,w data is not transformed.
    mode                  Regridding mode (channel/velocity/frequency/channel_b).
    nchan                 Number of channels in the output spw (-1=all). Used for regridding, together with \'start\' and \'width\'.
    start                 Start of the output visibilities. Used for regridding, together with \'width\' and \'nchan\'. It can be in different units, depending on the regridding mode: first input channel (mode=\'channel\'), first velocity (mode=\'velocity\'), or first frequency (mode=\'frequency\'). Example values: \'5\', \'0.0km/s\', \'1.4GHz\', for channel, velocity, and frequency modes, respectively.
    width                 Channel width of the output visibilities. Used for regridding, together with \'start\', and \'nchan\'. It can be in different units, depending on the regridding mode: number of input channels (mode=\'channel\'), velocity (mode=\'velocity\'), or frequency (mode=\'frequency\'. Example values: \'2\', \'1.0km/s\', \'1.0kHz\', for channel, velocity, and frequency modes, respectively.
    nspw                  Number of output spws to create in output MS.
    interpolation         Spectral interpolation method.
    phasecenter           Phase center direction to be used for the spectral coordinate transformation: direction measure or field index
    restfreq              Rest frequency to use for output.
    outframe              Output reference frame (''=keep input frame).
    veltype               Velocity definition.
    preaverage            Pre-average channels before regridding, when the ratio between the output and and input widths is greater than 2.
    timeaverage           Average data in time.
    timebin               Bin width for time averaging.
    timespan              Span the timebin across scan, state or both.
    maxuvwdistance        Maximum separation of start-to-end baselines that can be included in an average. (meters)
    docallib              Enable on-the-fly (OTF) calibration as in task applycal
    callib                Path to calibration library file
    douvcontsub           Enable continuum subtraction as in task uvcontsub
    fitspw                Spectral window:channel selection for fitting the continuum
    fitorder              Polynomial order for the fits
    want_cont             Produce continuum estimate instead of continuum subtracted data
    denoising_lib         Use new denoising library (based on GSL) instead of casacore fitting routines
    nthreads              Number of OMP threads to use (currently maximum limited by number of polarizations)
    niter                 Number of iterations for re-weighted linear fit
    disableparallel       Hidden parameter for internal use only. Do not change it!
    ddistart              Hidden parameter for internal use only. Do not change it!
    taql                  Table query for nested selections
    monolithic_processing Hidden parameter for internal use only. Do not change it!
    reindex               Hidden parameter for use in the pipeline context only

    --------- examples -----------------------------------------------------------

    
    
    Detailed description of keyword arguments:
    
    --- Input/Output parameters ---
    vis -- Name of input visibility file
    default: ''; example: vis='ngc5921.ms'
    
    outputvis -- Name of output visibility file or Multi-MS
    default: ''; example: outputvis='ngc5921.mms'
    
    createmms -- Create an output Multi-MS from an input MS.
    default: False
    
    This parameter only has effect if set to True, when it will try
    to create an output Multi-MS from an input MS. The one-to-one
    relation of input/output in mstransform is:
    input MS  --  output MS
    input MMS --  output MMS
    
    by setting createmms=True, the following is possible:
    input MS  --  output MMS
    
    NOTE: See information on processing input Multi-MS at the end of this help section.
    
    separationaxis -- Axis to do parallelization across.
    default: 'auto'
    options: 'scan', 'spw', 'auto', 'baseline'
    
    * The 'auto' option will partition per scan/spw to obtain optimal load balancing with the
    following criteria:
    
    1 - Maximize the scan/spw/field distribution across sub-MSs
    2 - Generate sub-MSs with similar size
    
    * The 'scan' or 'spw' axes will partition the MS into scan or spw. The individual sub-MSs may
    not be balanced with respect to the number of rows.
    
    * The 'baseline' axis is mostly useful for Single-Dish data. This axis will partition the MS
    based on the available baselines. If the user wants only auto-correlations, use the
    antenna selection such as antenna='*&&&' together with this separation axis. Note that in
    if numsubms='auto', partition will try to create as many subMSs as the number of available
    servers in the cluster. If the user wants to have one subMS for each baseline, set the numsubms
    parameter to a number higher than the number of baselines to achieve this.
    
    numsubms -- The number of sub-MSs to create.
    default: 'auto'
    Options: any integer number (example: numsubms=4)
    
    The default 'auto' is to partition using the number of available servers in the cluster.
    If the task is unable to determine the number of running servers, or the user did not start CASA
    using mpicasa, numsubms will use 8 as the default.
    
    tileshape -- List with 1 or 3 elements describing the tile shape that will be used
    to save the columns to disk. (list)
    default: [0]
    options: [0] or [1] or [int,int,int]. When list has only one element, it should
    be either 0 or 1. When the list has three elements, they should be the
    number of correlations, channels, rows.
    
    
    --- Data selection parameters ---
    field -- Select field using field id(s) or field name(s).
    [run listobs to obtain the list iof d's or names]
    default: ''=all fields If field string is a non-negative
    integer, it is assumed to be a field index
    otherwise, it is assumed to be a field name
    field='0~2'; field ids 0,1,2
    field='0,4,5~7'; field ids 0,4,5,6,7
    field='3C286,3C295'; fields named 3C286 and 3C295
    field = '3,4C*'; field id 3, all names starting with 4C
    
    spw -- Select spectral window/channels
    default: ''=all spectral windows and channels
    spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
    spw='<2';  spectral windows less than 2 (i.e. 0,1)
    spw='0:5~61'; spw 0, channels 5 to 61
    spw='0,10,3:3~45'; spw 0,10 all channels, spw 3 - chans 3 to 45.
    spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
    spw = '*:3~64'  channels 3 through 64 for all sp id's
    spw = ' :3~64' will NOT work.
    
    NOTE: mstransform does not support multiple channel ranges per
    spectral window (';').
    
    scan -- Scan number range
    default: ''=all
    
    antenna -- Select data based on antenna/baseline
    default: '' (all)
    Non-negative integers are assumed to be antenna indices, and
    anything else is taken as an antenna name.
    
    examples:
    antenna='5&6': baseline between antenna index 5 and index 6.
    antenna='VA05&VA06': baseline between VLA antenna 5 and 6.
    antenna='5&6;7&8': baselines 5-6 and 7-8
    antenna='5': all baselines with antenna 5
    antenna='5,6,10': all baselines including antennas 5, 6, or 10
    antenna='5,6,10&': all baselines with *only* antennas 5, 6, or
    10.  (cross-correlations only.  Use &&
    to include autocorrelations, and &&&
    to get only autocorrelations.)
    antenna='!ea03,ea12,ea17': all baselines except those that
    include EVLA antennas ea03, ea12, or
    ea17.
    
    correlation -- Correlation types or expression.
    default: '' (all correlations)
    example: correlation='XX,YY'
    
    timerange -- Select data based on time range:
    default: '' (all); examples,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: if YYYY/MM/DD is missing date, timerange defaults to the
    first day in the dataset
    timerange='09:14:0~09:54:0' picks 40 min on first day
    timerange='25:00:00~27:30:00' picks 1 hr to 3 hr 30min
    on next day
    timerange='09:44:00' data within one integration of time
    timerange='>10:24:00' data after this time
    
    array -- (Sub)array number range
    default: ''=all
    
    uvrange -- Select data within uvrange (default units meters)
    default: ''=all; example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
    uvrange='>4klambda';uvranges greater than 4 kilo-lambda
    uvrange='0~1000km'; uvrange in kilometers
    
    observation -- Select by observation ID(s)
    default: ''=all
    
    feed -- Selection based on the feed - NOT IMPLEMENTED YET
    default: ''=all
    
    
    datacolumn -- Which data column to use for processing (case-insensitive).
    default: 'corrected'; example: datacolumn='data'
    options: 'data', 'model', 'corrected', 'all','float_data', 'lag_data',
    'float_data,data', 'lag_data,data'.
    
    NOTE: 'all' = whichever of the above that are present. If the requested
    column does not exist, the task will exit with an error.
    
    When datacolumn is set to either one of the values 'model','all',
    'data,model,corrected', a sub-parameter realmodelcol will be enabled.
    See description below.
    
    realmodelcol -- Make real a virtual MODEL column. If set to True, a real MODEL_DATA
    column will be added to the output MS based on the existing SOURCE_MODEL
    column.
    default: False
    
    
    keepflags -- Keep completely flagged rows in the output or drop them. This has no
    effect on partially flagged rows. All of the channels and correlations
    of a row must be flagged for it to be droppable, and a row must be
    well defined to be keepable.
    
    IMPORTANT: Regardless of this parameter, flagged data is never included in
    channel averaging. On the other hand, partially flagged rows will
    always be included in time averaging. The average value of the
    flagged data for averages containing ONLY flagged data in the relevant
    output channel will be written to the output with the corresponding
    flag set to True, while only unflagged data is used on averages where
    there is some unflagged data with the flag set to False.
    
    default: True (keep completely flagged rows in the output)
    
    
    usewtspectrum -- Force creation of the columns WEIGHT_SPECTRUM and SIGMA_SPECTRUM in the
    output MS. This flag can be used to force the creation of
    WEIGHT_SPECTRUM and SIGMA_SPECTRUM when they are not present in the
    input MS. When set to true, the output WEIGHT_SPECTRUM column will be
    populated using the input WEIGHT column, such that each channel in the
    WEIGHT_SPECTRUM column will get WEIGHT/nChannels. Note that if the
    WEIGHT_SPECTRUM column is present in the input MS the columns will
    always be created in the output MS, regardless of the value of this
    parameter.
    
    default: False
    
    
    --- SPW combination parameters ---
    combinespws -- Combine the input spws into a new output spw.
    default: False
    
    NOTE: This option is only supported when the number of channels is the same for
    all the spws. Using this option with different numbers of channels for
    different spws will result in an error.
    
    NOTE: If the SPWs have different polarization settings only the common
    polarizations will be output. For instance, if SPW 1 has XX XY YX YY and
    SPW 2 has XX YY, the output MS will have a single SPW with XX YY polarizations
    
    NOTE: Whenever the data to be combined has different EXPOSURE values
    in the spectral windows, mstransform will use the WEIGHT_SPECTRUM
    for the combination. If WEIGHT_SPECTRUM is not available, it will
    use the values from the WEIGHT column. Each output channel is calculated
    using the following equation:
    
    outputChannel_j = SUM(inputChannel_i*contributionFraction_i*inputWeightSpectrum_i)
    ------------------------------------------------------------------
    SUM(contributionFraction_i*inputWeightSpectrum_i)
    
    
    --- Channel averaging parameters ---
    chanaverage -- Average data across channels. Partially flagged data is not be included in the average
    unless all data contributing to a given output channel is flagged. In this case,
    mstransform calculates the average of all flagged data, and writes it to the output MS
    with the corresponding flag set to true. If present, WEIGHT_SPECTRUM/SIGMA_SPECTRUM
    are used together with the channelized flags (FLAG), to compute a weighted average
    (using WEIGHT_SPECTRUM for CORRECTED_DATA and SIGMA_SPECTRUM for DATA).
    default: False
    
    chanbin -- Bin width for channel average in number of input channels.
    If a list is given, each bin applies to one of the selected SPWs.
    
    default: 1 => no channel averaging.
    options: (int) or [int]
    example: chanbin=[2,3] => average 2 channels of 1st selected
    spectral window and 3 in the second one.
    
    NOTE: WEIGHT_SPECTRUM/SIGMA_SPECTRUM will be used (if present) in
    addition to the flags to compute a weighted average. The calculations
    is done as follows:
    
    1) When WEIGHT_SPECTRUM/SIGMA_SPECTRUM are not present:
    Avg = SUM(Chan_i*Flag_i)/SUM(Flag_i)
    
    2) When WEIGHT_SPECTRUM/SIGMA_SPECTRUM are present:
    Avg = SUM(Chan_i*Flag_i*WeightSpectrum_i)/SUM(Flag_i*WeightSpectrum_i)
    
    If combinespws=True, then chanbin can only be a (int). This is because the
    channel average then refers to the already combined MS after spw combination,
    which has a single spw.
    
    
    --- Hanning smoothing parameters ---
    hanning -- Hanning smooth frequency channel data to remove Gibbs ringing.
    default: False
    
    --- Regrid parameters ---
    regridms -- Transform channel labels and visibilities to a different spectral reference frame.
    Notice that u,v,w data is not transformed.
    default: False
    
    mode -- Regridding mode.
    default: 'channel'; produces equidistant grid based on first selected channel.
    options: 'velocity', 'frequency', 'channel_b'.
    
    When set to velocity or frequency, it means that the channels must be specified
    in the respective units. When set to channel_b it means an alternative 'channel'
    mode that does not force an equidistant grid. It is faster.
    
    nchan -- Number of channels in the output spw (int).
    default: -1
    
    start -- First channel to use in the output spw (depends on the mode)
    default: 0 --> when mode='channel'
    
    When mode='channel', 'start' means the first channel in the input spw
    to use when creating the output spw. When mode='frequency' or mode='velocity',
    'start' means the frequency or velocity, respectively, of the first output
    channel. If this information is not available, leave it blank and mstransform
    will calculate it.
    
    width -- Width of input channels that are used to create an output channel.
    default: 1
    
    Note that mstransform will only shift spws with channel widths of the same
    sign in a single operation. If you are regridding spws with mixed positive
    and negative channel widths, you should run this task separated for each
    group of spws. You can verify the channel widths for your MS using
    listobs for example, and looking at the SPW table, column ChanWid.
    
    nspw -- Number of output spws to create in the output MS/MMS (int).
    default: 1  --> it means, do not separate the spws.
    
    One can regrid the MS or not and further separate the
    output into a given number of spws. Internally, the framework
    will combine the selected spws before separating them so that
    channel gaps and overlaps are taken into account. This parameter
    will create a regular grid of spws in the output MS. If nchan
    is set, it will refer to the number of output channels in each
    of the separated spws.
    
    interpolation -- Spectral interpolation method.
    default: 'linear'
    options: 'nearest', 'cubic', 'spline', 'fftshift'
    
    phasecenter -- Direction measure  or fieldid. To be used in mosaics to indicate
    the center direction to be used in the spectral coordinate transformation.
    default: '' (first selected field)
    options: FIELD_ID (int) or center coordinate measure (str).
    example: phasecenter=6 or phasecenter='J2000 19h30m00 -40d00m00'
    
    restfreq -- Specify rest frequency to use for output.
    default: ''; occasionally it is necessary to set this.
    example1 for some VLA spectral line data.
    example2 for NH_3 (1,1) put restfreq='23.694496GHz'.
    
    outframe -- Output reference frame (case-insensitive).
    default: ''; it will keep the input reference frame.
    options: 'LSRK', 'LSRD', 'BARY', 'GALACTO', 'LGROUP', 'CMB', 'GEO', 'TOPO'.
    
    veltype -- Definition of velocity (as used in mode).
    default: 'radio'
    
    preaverage -- Pre-average channels before regridding. This is done when the ratio
    between the output and and input widths is greater than 2. This has
    been disabled since CASA 5.0
    default: False
    
    
    --- Time averaging parameters ---
    timeaverage -- Average data across time. Partially flagged data is not be included in the average
    unless all data contributing to a given output channel is flagged. In this case,
    mstransform calculates the average of all flagged data, and writes it to the output MS
    with the corresponding flag set to true. If keepflags=False, the fully flagged data
    is not be written to the output MS. If present, WEIGHT_SPECTRUM/SIGMA_SPECTRUM
    are used together with the channelized flags (FLAG), to compute a weighted average
    (using WEIGHT_SPECTRUM for CORRECTED_DATA and SIGMA_SPECTRUM for DATA). Otherwise
    WEIGHT/SIGMA are used instead to average together data from different integrations.
    
    default: False
    
    timebin -- Bin width for time average in seconds.
    default: '0s'
    
    timespan -- Let the timebin span across scan, state or both.
    State is equivalent to sub-scans. One scan may have several
    state ids. For ALMA MSs, the sub-scans are limited to about
    30s duration each. In these cases, the task will automatically
    add state to the timespan parameter. To see the number of states
    in an MS, use the msmd tool. See help msmd.
    
    default: '' (separate time bins by both of the above)
    options: 'scan', 'state', 'state,scan'
    
    examples:
    timespan = 'scan'; can be useful when the scan number
    goes up with each integration as in many WSRT MSs.
    timespan = ['scan', 'state']: disregard scan and state
    numbers when time averaging.
    timespan = 'state,scan'; same as above.
    
    maxuvwdistance -- Provide a maximum separation of start-to-end baselines
    that can be included in an average. (int)
    default: 0.0 (given in meters)
    
    --- On-the-fly calibration parameters ---
    docallib -- Enable on-the-fly (OTF) calibration as in task applycal
    default: False
    
    callib -- Path to calibration library file, which is a ascii file containing
    the parameters to correct the data as task in task applycal, namely
    gaintable/gainfield/interp/spwmap/calwt. In a Cal Library file, each
    row expresses the calibration apply instructions for a particular
    caltable and (optionally) a specific selection of data in the MS to
    which it is to be applied.
    
    default: '' (there is no default callib file)
    
    examples:
    
    caltable='cal.G' tinterp='linear' calwt=True
    
    -> Arrange a caltable called cal.G to be applied (with no detailed selection)
    to all MS data with linear interpolation in time, and with the weights also
    calibrated.
    
    caltable='cal.G' tinterp='linear' fldmap='nearest' spwmap=[0,1,1,3] calwt=True
    caltable='cal.B' finterp='linear' fldmap='3' spwmap=[0,0,0,0] calwt=False
    
    -> In this case, solutions from cal.G will be selected based on directional
    proximity ('nearest') for each MS field via the fldmap parameter, and spw 2
    will be calibrated by spw 1 solutions. For cal.B, solutions from field id 3
    will be used exclusively, with spw 0 calibrating all MS spws.
    
    
    
    
    ------ Multi-MS Processing and Heuristics ---------
    
    ** Input Multi-MS (MMS) **
    
    Task mstransform will process an input MMS in parallel whenever possible. Each sub-MS of
    the MMS will be processed in a separate engine and the results will be post-processed at the
    end to create an output MMS. The output MMS will have the same separationaxis of the input
    MMS, which will be written to the table.info file inside the MMS directory.
    
    Naturally, some transformations available in mstransform require more care when the user
    first partition the MS. If one wants to do a combination of spws by setting the parameter
    combinespws = True in mstransform, the input MMS needs to contain all the
    selected spws in each of the sub-MSs or the processing will fail. For this, one may set the initial
    separationaxis to scan or use the default auto with a proper numsubms set so that each sub- MS in
    the MMS is self-contained with all the necessary spws for the combination.
    
    The task will check if the sub-MSs contain all the selected spws when combinespws=True
    and if not, it will issue a warning and process the input MMS as a monolithic MS. In this
    case, the separation axis of the output MMS will be set to scan, regardless of what the input
    axis was.
    
    A similar case happens when the separation axis of the input MMS is per scan and the user
    asks to do time averaging with time spanning across scans. If the individual sub-MSs are not
    self-contained of the necessary scans and the duration of the scans is shorter than the given
    timebin, the spanning will not be possible. In this case, the task will process the input MMS as
    a monolithic MS and will set the axis of the output MMS to spw.
    
    It is important that the user sets the separation axis correctly when first partitioning the MS.
    See the table below for when it is possible to process the input MMS in parallel or not, using
    mstransform.
    
    input MMS axis   combinespws=True   nspw > 1   timeaverage=True, timespan='scan'
    -------------------------------------------------------------------------------
    scan                  YES            YES             NO
    spw                   NO             NO              YES
    auto                  MAYBE          MAYBE           MAYBE
    
    
    ------ EXAMPLES ------
    
    More documentation on mstransform can be found here:
    http://www.eso.org/~scastro/ALMA/casa/MST/MSTransformDocs/MSTransformDocs.html
    
    1) Split out a single channel.
    mstransform(vis='ctb80-vsm.ms', outputvis='mychn.ms', datacolumn='data', spw='0:25')
    
    2) Only combine the selected spws into a single output spw.
    mstransform(vis='Four_ants.ms', outputvis='myspw.ms', combinespws=True, spw='0~3')
    
    3) Combine two spws and regrid one field, using two input channels to make one output.
    mstransform(vis='jupiter6cm.demo.ms',outputvis='test1.ms',datacolumn='DATA',field='11',
    spw='0,1', combinespws=True, regridms=True, nchan=1, width=2)
    
    4) Combine 24 spws and regrid in frequency mode to create 21 output channels. Change the
    phase center.
    mstransform(vis='g19_d2usb_targets_line.ms', outputvis='test2.ms', datacolumn='DATA',
    combinespws=True, regridms=True, mode='frequency', nchan=21, start='229587.0MHz',
    width='1600kHz', phasecenter="J2000 18h25m56.09 -12d04m28.20")
    
    5) Only apply Hanning smoothing to MS.
    mstransform(vis='g19_d2usb_targets_line.ms', outputvis='test3.ms', datacolumn='DATA',
    hanning=True)
    
    6) Change the reference frame and apply Hanning smoothing after combining all spws.
    mstransform(vis='g19_d2usb_targets_line.ms', outputvis='test4.ms', datacolumn='DATA',
    combinespws=True, regridms=True, mode="channel", outframe="BARY",
    phasecenter="J2000 18h25m56.09 -12d04m28.20", hanning = True)
    
    7) Apply time averaging using a bin of 30 seconds on the default CORRECTED column.
    mstransform(vis='g19_d2usb_targets_line.ms', outputvis='test5.ms', timeaverage=True,
    timebin='30s')
    
    8) Apply OTF calibration to ng5921 using a calibration library
    mstransform(vis='ngc5921.ms', outputvis='ngc5921_calibrated.ms',docallib=True,
    callib='unittest/mstransform/ngc5921_regression/ngc5921_callib.txt')


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Split the MS, combine/separate/regrid spws and do channel and time averaging"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cStr'}, 'createmms': {'type': 'cBool'}, 'separationaxis': {'type': 'cStr'}, 'numsubms': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'tileshape': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'correlation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'array': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'feed': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'datacolumn': {'type': 'cStr'}, 'realmodelcol': {'type': 'cBool'}, 'keepflags': {'type': 'cBool'}, 'usewtspectrum': {'type': 'cBool'}, 'combinespws': {'type': 'cBool'}, 'chanaverage': {'type': 'cBool'}, 'chanbin': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'hanning': {'type': 'cBool'}, 'regridms': {'type': 'cBool'}, 'mode': {'type': 'cStr'}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'width': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'nspw': {'type': 'cInt'}, 'interpolation': {'type': 'cStr'}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'restfreq': {'type': 'cStr'}, 'outframe': {'type': 'cStr'}, 'veltype': {'type': 'cStr'}, 'preaverage': {'type': 'cBool'}, 'timeaverage': {'type': 'cBool'}, 'timebin': {'type': 'cStr'}, 'timespan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'maxuvwdistance': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'docallib': {'type': 'cBool'}, 'callib': {'type': 'cStr'}, 'douvcontsub': {'type': 'cBool'}, 'fitspw': {'type': 'cStr'}, 'fitorder': {'type': 'cInt'}, 'want_cont': {'type': 'cBool'}, 'denoising_lib': {'type': 'cBool'}, 'nthreads': {'type': 'cInt'}, 'niter': {'type': 'cInt'}, 'disableparallel': {'type': 'cBool'}, 'ddistart': {'type': 'cInt'}, 'taql': {'type': 'cStr'}, 'monolithic_processing': {'type': 'cBool'}, 'reindex': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __douvcontsub_dflt( self, glb ):
        return False

    def __douvcontsub( self, glb ):
        if 'douvcontsub' in glb: return glb['douvcontsub']
        return False

    def __feed_dflt( self, glb ):
        return ''

    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __correlation_dflt( self, glb ):
        return ''

    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        return ''

    def __combinespws_dflt( self, glb ):
        return False

    def __combinespws( self, glb ):
        if 'combinespws' in glb: return glb['combinespws']
        return False

    def __timeaverage_dflt( self, glb ):
        return False

    def __timeaverage( self, glb ):
        if 'timeaverage' in glb: return glb['timeaverage']
        return False

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __array_dflt( self, glb ):
        return ''

    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        return ''

    def __monolithic_processing_dflt( self, glb ):
        return False

    def __monolithic_processing( self, glb ):
        if 'monolithic_processing' in glb: return glb['monolithic_processing']
        return False

    def __datacolumn_dflt( self, glb ):
        return 'corrected'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'corrected'

    def __observation_dflt( self, glb ):
        return ''

    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        return ''

    def __hanning_dflt( self, glb ):
        return False

    def __hanning( self, glb ):
        if 'hanning' in glb: return glb['hanning']
        return False

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __uvrange_dflt( self, glb ):
        return ''

    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __usewtspectrum_dflt( self, glb ):
        return False

    def __usewtspectrum( self, glb ):
        if 'usewtspectrum' in glb: return glb['usewtspectrum']
        return False

    def __createmms_dflt( self, glb ):
        return False

    def __createmms( self, glb ):
        if 'createmms' in glb: return glb['createmms']
        return False

    def __keepflags_dflt( self, glb ):
        return True

    def __keepflags( self, glb ):
        if 'keepflags' in glb: return glb['keepflags']
        return True

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __tileshape_dflt( self, glb ):
        return [ int(0) ]

    def __tileshape( self, glb ):
        if 'tileshape' in glb: return glb['tileshape']
        return [ int(0) ]

    def __docallib_dflt( self, glb ):
        return False

    def __docallib( self, glb ):
        if 'docallib' in glb: return glb['docallib']
        return False

    def __regridms_dflt( self, glb ):
        return False

    def __regridms( self, glb ):
        if 'regridms' in glb: return glb['regridms']
        return False

    def __chanaverage_dflt( self, glb ):
        return False

    def __chanaverage( self, glb ):
        if 'chanaverage' in glb: return glb['chanaverage']
        return False

    #--------- return non subparam/when values ---------------------------------------------
    def __preaverage( self, glb ):
        if 'preaverage' in glb: return glb['preaverage']
        return False

    #--------- return inp/go default --------------------------------------------------
    def __callib_dflt( self, glb ):
        if self.__docallib( glb ) == bool(True): return ""
        return None
    def __fitspw_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return ""
        return None
    def __want_cont_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return bool(False)
        return None
    def __nspw_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return int(1)
        return None
    def __nthreads_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return int(1)
        return None
    def __numsubms_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return "auto"
        if self.__createmms( glb ) == bool(True): return "auto"
        return None
    def __interpolation_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return "linear"
        if self.__mode( glb ) == "channel_b": return "linear"
        if self.__mode( glb ) == "velocity": return "linear"
        if self.__mode( glb ) == "frequency": return "linear"
        if self.__regridms( glb ) == bool(True): return "linear"
        return None
    def __realmodelcol_dflt( self, glb ):
        if self.__datacolumn( glb ) == "model": return bool(False)
        if self.__datacolumn( glb ) == "all": return bool(False)
        if self.__datacolumn( glb ) == "data,model,corrected": return bool(False)
        return None
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "channel_b": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        if self.__regridms( glb ) == bool(True): return int(-1)
        return None
    def __denoising_lib_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return bool(True)
        return None
    def __disableparallel_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return bool(False)
        if self.__createmms( glb ) == bool(True): return bool(False)
        return None
    def __timebin_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return "0s"
        return None
    def __reindex_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return bool(True)
        if self.__createmms( glb ) == bool(True): return bool(True)
        return None
    def __fitorder_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return int(0)
        return None
    def __ddistart_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return int(-1)
        if self.__createmms( glb ) == bool(True): return int(-1)
        return None
    def __restfreq_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return ""
        return None
    def __chanbin_dflt( self, glb ):
        if self.__chanaverage( glb ) == bool(True): return 1
        return None
    def __preaverage_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return bool(False)
        return None
    def __maxuvwdistance_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return float(0.0)
        return None
    def __veltype_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return "radio"
        return None
    def __niter_dflt( self, glb ):
        if self.__douvcontsub( glb ) == bool(True): return int(1)
        return None
    def __outframe_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return ""
        return None
    def __mode_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return "channel"
        return None
    def __timespan_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return ""
        return None
    def __phasecenter_dflt( self, glb ):
        if self.__regridms( glb ) == bool(True): return ""
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 0
        if self.__mode( glb ) == "channel_b": return 0
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__regridms( glb ) == bool(True): return 0
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 1
        if self.__mode( glb ) == "channel_b": return 1
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__regridms( glb ) == bool(True): return 1
        return None
    def __taql_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return ""
        if self.__createmms( glb ) == bool(True): return ""
        return None
    def __separationaxis_dflt( self, glb ):
        if self.__createmms( glb ) == bool(False): return "auto"
        if self.__createmms( glb ) == bool(True): return "auto"
        return None

    #--------- return subparam values -------------------------------------------------
    def __separationaxis( self, glb ):
        if 'separationaxis' in glb: return glb['separationaxis']
        dflt = self.__separationaxis_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __numsubms( self, glb ):
        if 'numsubms' in glb: return glb['numsubms']
        dflt = self.__numsubms_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __realmodelcol( self, glb ):
        if 'realmodelcol' in glb: return glb['realmodelcol']
        dflt = self.__realmodelcol_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __chanbin( self, glb ):
        if 'chanbin' in glb: return glb['chanbin']
        dflt = self.__chanbin_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        dflt = self.__mode_dflt( glb )
        if dflt is not None: return dflt
        return 'channel'
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __nspw( self, glb ):
        if 'nspw' in glb: return glb['nspw']
        dflt = self.__nspw_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        dflt = self.__interpolation_dflt( glb )
        if dflt is not None: return dflt
        return 'linear'
    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        dflt = self.__phasecenter_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        dflt = self.__restfreq_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        dflt = self.__outframe_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        dflt = self.__veltype_dflt( glb )
        if dflt is not None: return dflt
        return 'radio'
    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        dflt = self.__timebin_dflt( glb )
        if dflt is not None: return dflt
        return '0s'
    def __timespan( self, glb ):
        if 'timespan' in glb: return glb['timespan']
        dflt = self.__timespan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __maxuvwdistance( self, glb ):
        if 'maxuvwdistance' in glb: return glb['maxuvwdistance']
        dflt = self.__maxuvwdistance_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __callib( self, glb ):
        if 'callib' in glb: return glb['callib']
        dflt = self.__callib_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __fitspw( self, glb ):
        if 'fitspw' in glb: return glb['fitspw']
        dflt = self.__fitspw_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __fitorder( self, glb ):
        if 'fitorder' in glb: return glb['fitorder']
        dflt = self.__fitorder_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __want_cont( self, glb ):
        if 'want_cont' in glb: return glb['want_cont']
        dflt = self.__want_cont_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __denoising_lib( self, glb ):
        if 'denoising_lib' in glb: return glb['denoising_lib']
        dflt = self.__denoising_lib_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __nthreads( self, glb ):
        if 'nthreads' in glb: return glb['nthreads']
        dflt = self.__nthreads_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __niter( self, glb ):
        if 'niter' in glb: return glb['niter']
        dflt = self.__niter_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __disableparallel( self, glb ):
        if 'disableparallel' in glb: return glb['disableparallel']
        dflt = self.__disableparallel_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __ddistart( self, glb ):
        if 'ddistart' in glb: return glb['ddistart']
        dflt = self.__ddistart_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __taql( self, glb ):
        if 'taql' in glb: return glb['taql']
        dflt = self.__taql_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __monolithic_processing( self, glb ):
        if 'monolithic_processing' in glb: return glb['monolithic_processing']
        dflt = self.__monolithic_processing_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __reindex( self, glb ):
        if 'reindex' in glb: return glb['reindex']
        dflt = self.__reindex_dflt( glb )
        if dflt is not None: return dflt
        return True

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __outputvis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('outputvis',pre,self.__to_string_(value),post,description))
    def __createmms_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__createmms( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'createmms': value},{'createmms': self.__schema['createmms']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('createmms',pre,self.__to_string_(value),post,description))
    def __separationaxis_inp(self):
        out = self.__stdout or sys.stdout
        if self.__separationaxis_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__separationaxis( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'separationaxis': value},{'separationaxis': self.__schema['separationaxis']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('separationaxis',pre,self.__to_string_(value),post,description))
    def __numsubms_inp(self):
        out = self.__stdout or sys.stdout
        if self.__numsubms_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__numsubms( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'numsubms': value},{'numsubms': self.__schema['numsubms']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('numsubms',pre,self.__to_string_(value),post,description))
    def __tileshape_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__tileshape( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'tileshape': value},{'tileshape': self.__schema['tileshape']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('tileshape',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __correlation_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__correlation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('correlation',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__array( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __uvrange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__uvrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('uvrange',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__observation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __feed_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__feed( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('feed',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))
    def __realmodelcol_inp(self):
        out = self.__stdout or sys.stdout
        if self.__realmodelcol_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__realmodelcol( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'realmodelcol': value},{'realmodelcol': self.__schema['realmodelcol']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('realmodelcol',pre,self.__to_string_(value),post,description))
    def __keepflags_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__keepflags( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'keepflags': value},{'keepflags': self.__schema['keepflags']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('keepflags',pre,self.__to_string_(value),post,description))
    def __usewtspectrum_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__usewtspectrum( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'usewtspectrum': value},{'usewtspectrum': self.__schema['usewtspectrum']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('usewtspectrum',pre,self.__to_string_(value),post,description))
    def __combinespws_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__combinespws( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'combinespws': value},{'combinespws': self.__schema['combinespws']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('combinespws',pre,self.__to_string_(value),post,description))
    def __chanaverage_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chanaverage( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chanaverage': value},{'chanaverage': self.__schema['chanaverage']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('chanaverage',pre,self.__to_string_(value),post,description))
    def __chanbin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__chanbin_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__chanbin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'chanbin': value},{'chanbin': self.__schema['chanbin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('chanbin',pre,self.__to_string_(value),post,description))
    def __hanning_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__hanning( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'hanning': value},{'hanning': self.__schema['hanning']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('hanning',pre,self.__to_string_(value),post,description))
    def __regridms_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__regridms( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'regridms': value},{'regridms': self.__schema['regridms']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('regridms',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        if self.__mode_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__mode( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __nchan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nchan',pre,self.__to_string_(value),post,description))
    def __start_inp(self):
        out = self.__stdout or sys.stdout
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__start( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('start',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__width( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __nspw_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nspw_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nspw( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nspw': value},{'nspw': self.__schema['nspw']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nspw',pre,self.__to_string_(value),post,description))
    def __interpolation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interpolation_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interpolation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interpolation',pre,self.__to_string_(value),post,description))
    def __phasecenter_inp(self):
        out = self.__stdout or sys.stdout
        if self.__phasecenter_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__phasecenter( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('phasecenter',pre,self.__to_string_(value),post,description))
    def __restfreq_inp(self):
        out = self.__stdout or sys.stdout
        if self.__restfreq_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__restfreq( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('restfreq',pre,self.__to_string_(value),post,description))
    def __outframe_inp(self):
        out = self.__stdout or sys.stdout
        if self.__outframe_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__outframe( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outframe',pre,self.__to_string_(value),post,description))
    def __veltype_inp(self):
        out = self.__stdout or sys.stdout
        if self.__veltype_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__veltype( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('veltype',pre,self.__to_string_(value),post,description))
    def __preaverage_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__preaverage( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'preaverage': value},{'preaverage': self.__schema['preaverage']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-24.24s = %s%-23.22s%s # %-.60s\n' % ('preaverage',pre,self.__to_string_(value),post,description))
    def __timeaverage_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timeaverage( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timeaverage': value},{'timeaverage': self.__schema['timeaverage']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timeaverage',pre,self.__to_string_(value),post,description))
    def __timebin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timebin_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__timebin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timebin',pre,self.__to_string_(value),post,description))
    def __timespan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timespan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__timespan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timespan': value},{'timespan': self.__schema['timespan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timespan',pre,self.__to_string_(value),post,description))
    def __maxuvwdistance_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maxuvwdistance_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__maxuvwdistance( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maxuvwdistance': value},{'maxuvwdistance': self.__schema['maxuvwdistance']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maxuvwdistance',pre,self.__to_string_(value),post,description))
    def __docallib_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__docallib( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'docallib': value},{'docallib': self.__schema['docallib']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('docallib',pre,self.__to_string_(value),post,description))
    def __callib_inp(self):
        out = self.__stdout or sys.stdout
        if self.__callib_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__callib( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'callib': value},{'callib': self.__schema['callib']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('callib',pre,self.__to_string_(value),post,description))
    def __douvcontsub_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__douvcontsub( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'douvcontsub': value},{'douvcontsub': self.__schema['douvcontsub']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('douvcontsub',pre,self.__to_string_(value),post,description))
    def __fitspw_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fitspw_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fitspw( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fitspw': value},{'fitspw': self.__schema['fitspw']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fitspw',pre,self.__to_string_(value),post,description))
    def __fitorder_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fitorder_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fitorder( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fitorder': value},{'fitorder': self.__schema['fitorder']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fitorder',pre,self.__to_string_(value),post,description))
    def __want_cont_inp(self):
        out = self.__stdout or sys.stdout
        if self.__want_cont_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__want_cont( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'want_cont': value},{'want_cont': self.__schema['want_cont']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('want_cont',pre,self.__to_string_(value),post,description))
    def __denoising_lib_inp(self):
        out = self.__stdout or sys.stdout
        if self.__denoising_lib_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__denoising_lib( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'denoising_lib': value},{'denoising_lib': self.__schema['denoising_lib']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('denoising_lib',pre,self.__to_string_(value),post,description))
    def __nthreads_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nthreads_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nthreads( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nthreads': value},{'nthreads': self.__schema['nthreads']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nthreads',pre,self.__to_string_(value),post,description))
    def __niter_inp(self):
        out = self.__stdout or sys.stdout
        if self.__niter_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__niter( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'niter': value},{'niter': self.__schema['niter']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('niter',pre,self.__to_string_(value),post,description))
    def __disableparallel_inp(self):
        out = self.__stdout or sys.stdout
        if self.__disableparallel_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__disableparallel( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'disableparallel': value},{'disableparallel': self.__schema['disableparallel']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('disableparallel',pre,self.__to_string_(value),post,description))
    def __ddistart_inp(self):
        out = self.__stdout or sys.stdout
        if self.__ddistart_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__ddistart( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'ddistart': value},{'ddistart': self.__schema['ddistart']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('ddistart',pre,self.__to_string_(value),post,description))
    def __taql_inp(self):
        out = self.__stdout or sys.stdout
        if self.__taql_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__taql( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'taql': value},{'taql': self.__schema['taql']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('taql',pre,self.__to_string_(value),post,description))
    def __monolithic_processing_inp(self):
        out = self.__stdout or sys.stdout
        if self.__monolithic_processing_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__monolithic_processing( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'monolithic_processing': value},{'monolithic_processing': self.__schema['monolithic_processing']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('monolithic_processing',pre,self.__to_string_(value),post,description))
    def __reindex_inp(self):
        out = self.__stdout or sys.stdout
        if self.__reindex_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__reindex( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'reindex': value},{'reindex': self.__schema['reindex']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-21.21s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('reindex',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'callib' in glb: del glb['callib']
        if 'fitspw' in glb: del glb['fitspw']
        if 'want_cont' in glb: del glb['want_cont']
        if 'nspw' in glb: del glb['nspw']
        if 'field' in glb: del glb['field']
        if 'nthreads' in glb: del glb['nthreads']
        if 'monolithic_processing' in glb: del glb['monolithic_processing']
        if 'outputvis' in glb: del glb['outputvis']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'numsubms' in glb: del glb['numsubms']
        if 'intent' in glb: del glb['intent']
        if 'interpolation' in glb: del glb['interpolation']
        if 'chanaverage' in glb: del glb['chanaverage']
        if 'realmodelcol' in glb: del glb['realmodelcol']
        if 'nchan' in glb: del glb['nchan']
        if 'createmms' in glb: del glb['createmms']
        if 'denoising_lib' in glb: del glb['denoising_lib']
        if 'usewtspectrum' in glb: del glb['usewtspectrum']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'disableparallel' in glb: del glb['disableparallel']
        if 'timeaverage' in glb: del glb['timeaverage']
        if 'timebin' in glb: del glb['timebin']
        if 'reindex' in glb: del glb['reindex']
        if 'keepflags' in glb: del glb['keepflags']
        if 'fitorder' in glb: del glb['fitorder']
        if 'array' in glb: del glb['array']
        if 'ddistart' in glb: del glb['ddistart']
        if 'restfreq' in glb: del glb['restfreq']
        if 'chanbin' in glb: del glb['chanbin']
        if 'docallib' in glb: del glb['docallib']
        if 'preaverage' in glb: del glb['preaverage']
        if 'maxuvwdistance' in glb: del glb['maxuvwdistance']
        if 'correlation' in glb: del glb['correlation']
        if 'feed' in glb: del glb['feed']
        if 'tileshape' in glb: del glb['tileshape']
        if 'veltype' in glb: del glb['veltype']
        if 'niter' in glb: del glb['niter']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'timespan' in glb: del glb['timespan']
        if 'uvrange' in glb: del glb['uvrange']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'start' in glb: del glb['start']
        if 'observation' in glb: del glb['observation']
        if 'hanning' in glb: del glb['hanning']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'combinespws' in glb: del glb['combinespws']
        if 'taql' in glb: del glb['taql']
        if 'regridms' in glb: del glb['regridms']
        if 'timerange' in glb: del glb['timerange']
        if 'separationaxis' in glb: del glb['separationaxis']
        if 'douvcontsub' in glb: del glb['douvcontsub']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__createmms_inp( )
        self.__separationaxis_inp( )
        self.__numsubms_inp( )
        self.__tileshape_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__antenna_inp( )
        self.__correlation_inp( )
        self.__timerange_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__uvrange_inp( )
        self.__observation_inp( )
        self.__feed_inp( )
        self.__datacolumn_inp( )
        self.__realmodelcol_inp( )
        self.__keepflags_inp( )
        self.__usewtspectrum_inp( )
        self.__combinespws_inp( )
        self.__chanaverage_inp( )
        self.__chanbin_inp( )
        self.__hanning_inp( )
        self.__regridms_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__nspw_inp( )
        self.__interpolation_inp( )
        self.__phasecenter_inp( )
        self.__restfreq_inp( )
        self.__outframe_inp( )
        self.__veltype_inp( )
        self.__preaverage_inp( )
        self.__timeaverage_inp( )
        self.__timebin_inp( )
        self.__timespan_inp( )
        self.__maxuvwdistance_inp( )
        self.__docallib_inp( )
        self.__callib_inp( )
        self.__douvcontsub_inp( )
        self.__fitspw_inp( )
        self.__fitorder_inp( )
        self.__want_cont_inp( )
        self.__denoising_lib_inp( )
        self.__nthreads_inp( )
        self.__niter_inp( )
        self.__disableparallel_inp( )
        self.__ddistart_inp( )
        self.__taql_inp( )
        self.__monolithic_processing_inp( )
        self.__reindex_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("mstransform.last"):
                filename = "mstransform.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, outputvis=None, createmms=None, separationaxis=None, numsubms=None, tileshape=None, field=None, spw=None, scan=None, antenna=None, correlation=None, timerange=None, intent=None, array=None, uvrange=None, observation=None, feed=None, datacolumn=None, realmodelcol=None, keepflags=None, usewtspectrum=None, combinespws=None, chanaverage=None, chanbin=None, hanning=None, regridms=None, mode=None, nchan=None, start=None, width=None, nspw=None, interpolation=None, phasecenter=None, restfreq=None, outframe=None, veltype=None, preaverage=None, timeaverage=None, timebin=None, timespan=None, maxuvwdistance=None, docallib=None, callib=None, douvcontsub=None, fitspw=None, fitorder=None, want_cont=None, denoising_lib=None, nthreads=None, niter=None, disableparallel=None, ddistart=None, taql=None, monolithic_processing=None, reindex=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('mstransform.pre')
        _postfile = os.path.realpath('mstransform.last')
        _return_result_ = None
        _arguments = [vis,outputvis,createmms,separationaxis,numsubms,tileshape,field,spw,scan,antenna,correlation,timerange,intent,array,uvrange,observation,feed,datacolumn,realmodelcol,keepflags,usewtspectrum,combinespws,chanaverage,chanbin,hanning,regridms,mode,nchan,start,width,nspw,interpolation,phasecenter,restfreq,outframe,veltype,preaverage,timeaverage,timebin,timespan,maxuvwdistance,docallib,callib,douvcontsub,fitspw,fitorder,want_cont,denoising_lib,nthreads,niter,disableparallel,ddistart,taql,monolithic_processing,reindex]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if createmms is not None: local_global['createmms'] = createmms
            if tileshape is not None: local_global['tileshape'] = tileshape
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if antenna is not None: local_global['antenna'] = antenna
            if correlation is not None: local_global['correlation'] = correlation
            if timerange is not None: local_global['timerange'] = timerange
            if intent is not None: local_global['intent'] = intent
            if array is not None: local_global['array'] = array
            if uvrange is not None: local_global['uvrange'] = uvrange
            if observation is not None: local_global['observation'] = observation
            if feed is not None: local_global['feed'] = feed
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if keepflags is not None: local_global['keepflags'] = keepflags
            if usewtspectrum is not None: local_global['usewtspectrum'] = usewtspectrum
            if combinespws is not None: local_global['combinespws'] = combinespws
            if chanaverage is not None: local_global['chanaverage'] = chanaverage
            if hanning is not None: local_global['hanning'] = hanning
            if regridms is not None: local_global['regridms'] = regridms
            if preaverage is not None: local_global['preaverage'] = preaverage
            if timeaverage is not None: local_global['timeaverage'] = timeaverage
            if docallib is not None: local_global['docallib'] = docallib
            if douvcontsub is not None: local_global['douvcontsub'] = douvcontsub

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['createmms'] = self.__createmms( local_global )
            _invocation_parameters['tileshape'] = self.__tileshape( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['correlation'] = self.__correlation( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['array'] = self.__array( local_global )
            _invocation_parameters['uvrange'] = self.__uvrange( local_global )
            _invocation_parameters['observation'] = self.__observation( local_global )
            _invocation_parameters['feed'] = self.__feed( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['keepflags'] = self.__keepflags( local_global )
            _invocation_parameters['usewtspectrum'] = self.__usewtspectrum( local_global )
            _invocation_parameters['combinespws'] = self.__combinespws( local_global )
            _invocation_parameters['chanaverage'] = self.__chanaverage( local_global )
            _invocation_parameters['hanning'] = self.__hanning( local_global )
            _invocation_parameters['regridms'] = self.__regridms( local_global )
            _invocation_parameters['preaverage'] = self.__preaverage( local_global )
            _invocation_parameters['timeaverage'] = self.__timeaverage( local_global )
            _invocation_parameters['docallib'] = self.__docallib( local_global )
            _invocation_parameters['douvcontsub'] = self.__douvcontsub( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['separationaxis'] = self.__separationaxis( _invocation_parameters ) if separationaxis is None else separationaxis
            _invocation_parameters['numsubms'] = self.__numsubms( _invocation_parameters ) if numsubms is None else numsubms
            _invocation_parameters['realmodelcol'] = self.__realmodelcol( _invocation_parameters ) if realmodelcol is None else realmodelcol
            _invocation_parameters['chanbin'] = self.__chanbin( _invocation_parameters ) if chanbin is None else chanbin
            _invocation_parameters['mode'] = self.__mode( _invocation_parameters ) if mode is None else mode
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['nspw'] = self.__nspw( _invocation_parameters ) if nspw is None else nspw
            _invocation_parameters['interpolation'] = self.__interpolation( _invocation_parameters ) if interpolation is None else interpolation
            _invocation_parameters['phasecenter'] = self.__phasecenter( _invocation_parameters ) if phasecenter is None else phasecenter
            _invocation_parameters['restfreq'] = self.__restfreq( _invocation_parameters ) if restfreq is None else restfreq
            _invocation_parameters['outframe'] = self.__outframe( _invocation_parameters ) if outframe is None else outframe
            _invocation_parameters['veltype'] = self.__veltype( _invocation_parameters ) if veltype is None else veltype
            _invocation_parameters['timebin'] = self.__timebin( _invocation_parameters ) if timebin is None else timebin
            _invocation_parameters['timespan'] = self.__timespan( _invocation_parameters ) if timespan is None else timespan
            _invocation_parameters['maxuvwdistance'] = self.__maxuvwdistance( _invocation_parameters ) if maxuvwdistance is None else maxuvwdistance
            _invocation_parameters['callib'] = self.__callib( _invocation_parameters ) if callib is None else callib
            _invocation_parameters['fitspw'] = self.__fitspw( _invocation_parameters ) if fitspw is None else fitspw
            _invocation_parameters['fitorder'] = self.__fitorder( _invocation_parameters ) if fitorder is None else fitorder
            _invocation_parameters['want_cont'] = self.__want_cont( _invocation_parameters ) if want_cont is None else want_cont
            _invocation_parameters['denoising_lib'] = self.__denoising_lib( _invocation_parameters ) if denoising_lib is None else denoising_lib
            _invocation_parameters['nthreads'] = self.__nthreads( _invocation_parameters ) if nthreads is None else nthreads
            _invocation_parameters['niter'] = self.__niter( _invocation_parameters ) if niter is None else niter
            _invocation_parameters['disableparallel'] = self.__disableparallel( _invocation_parameters ) if disableparallel is None else disableparallel
            _invocation_parameters['ddistart'] = self.__ddistart( _invocation_parameters ) if ddistart is None else ddistart
            _invocation_parameters['taql'] = self.__taql( _invocation_parameters ) if taql is None else taql
            _invocation_parameters['monolithic_processing'] = self.__monolithic_processing( _invocation_parameters ) if monolithic_processing is None else monolithic_processing
            _invocation_parameters['reindex'] = self.__reindex( _invocation_parameters ) if reindex is None else reindex

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['createmms'] = self.__createmms( self.__globals_( ) )
            _invocation_parameters['separationaxis'] = self.__separationaxis( self.__globals_( ) )
            _invocation_parameters['numsubms'] = self.__numsubms( self.__globals_( ) )
            _invocation_parameters['tileshape'] = self.__tileshape( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['realmodelcol'] = self.__realmodelcol( self.__globals_( ) )
            _invocation_parameters['keepflags'] = self.__keepflags( self.__globals_( ) )
            _invocation_parameters['usewtspectrum'] = self.__usewtspectrum( self.__globals_( ) )
            _invocation_parameters['combinespws'] = self.__combinespws( self.__globals_( ) )
            _invocation_parameters['chanaverage'] = self.__chanaverage( self.__globals_( ) )
            _invocation_parameters['chanbin'] = self.__chanbin( self.__globals_( ) )
            _invocation_parameters['hanning'] = self.__hanning( self.__globals_( ) )
            _invocation_parameters['regridms'] = self.__regridms( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['nspw'] = self.__nspw( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['preaverage'] = self.__preaverage( self.__globals_( ) )
            _invocation_parameters['timeaverage'] = self.__timeaverage( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['timespan'] = self.__timespan( self.__globals_( ) )
            _invocation_parameters['maxuvwdistance'] = self.__maxuvwdistance( self.__globals_( ) )
            _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
            _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
            _invocation_parameters['douvcontsub'] = self.__douvcontsub( self.__globals_( ) )
            _invocation_parameters['fitspw'] = self.__fitspw( self.__globals_( ) )
            _invocation_parameters['fitorder'] = self.__fitorder( self.__globals_( ) )
            _invocation_parameters['want_cont'] = self.__want_cont( self.__globals_( ) )
            _invocation_parameters['denoising_lib'] = self.__denoising_lib( self.__globals_( ) )
            _invocation_parameters['nthreads'] = self.__nthreads( self.__globals_( ) )
            _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
            _invocation_parameters['disableparallel'] = self.__disableparallel( self.__globals_( ) )
            _invocation_parameters['ddistart'] = self.__ddistart( self.__globals_( ) )
            _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
            _invocation_parameters['monolithic_processing'] = self.__monolithic_processing( self.__globals_( ) )
            _invocation_parameters['reindex'] = self.__reindex( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-21s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#mstransform( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _mstransform_t( _invocation_parameters['vis'],_invocation_parameters['outputvis'],_invocation_parameters['createmms'],_invocation_parameters['separationaxis'],_invocation_parameters['numsubms'],_invocation_parameters['tileshape'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['scan'],_invocation_parameters['antenna'],_invocation_parameters['correlation'],_invocation_parameters['timerange'],_invocation_parameters['intent'],_invocation_parameters['array'],_invocation_parameters['uvrange'],_invocation_parameters['observation'],_invocation_parameters['feed'],_invocation_parameters['datacolumn'],_invocation_parameters['realmodelcol'],_invocation_parameters['keepflags'],_invocation_parameters['usewtspectrum'],_invocation_parameters['combinespws'],_invocation_parameters['chanaverage'],_invocation_parameters['chanbin'],_invocation_parameters['hanning'],_invocation_parameters['regridms'],_invocation_parameters['mode'],_invocation_parameters['nchan'],_invocation_parameters['start'],_invocation_parameters['width'],_invocation_parameters['nspw'],_invocation_parameters['interpolation'],_invocation_parameters['phasecenter'],_invocation_parameters['restfreq'],_invocation_parameters['outframe'],_invocation_parameters['veltype'],_invocation_parameters['preaverage'],_invocation_parameters['timeaverage'],_invocation_parameters['timebin'],_invocation_parameters['timespan'],_invocation_parameters['maxuvwdistance'],_invocation_parameters['docallib'],_invocation_parameters['callib'],_invocation_parameters['douvcontsub'],_invocation_parameters['fitspw'],_invocation_parameters['fitorder'],_invocation_parameters['want_cont'],_invocation_parameters['denoising_lib'],_invocation_parameters['nthreads'],_invocation_parameters['niter'],_invocation_parameters['disableparallel'],_invocation_parameters['ddistart'],_invocation_parameters['taql'],_invocation_parameters['monolithic_processing'],_invocation_parameters['reindex'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

mstransform = _mstransform( )

