##################### generated by xml-casa (v2) from statwt.xml ####################
##################### 8152eb441f00517aaa639c8bf3d15976 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import statwt as _statwt_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _statwt:
    """
    statwt ---- Compute and set weights based on variance of data.

    --------- parameter descriptions ---------------------------------------------

    vis          Name of measurement set
    selectdata   Enable data selection parameters
    field        Selection based on field names or field index numbers. Default is all.
    spw          Selection based on spectral windows:channels. Default is all.
    intent       Selection based on intents. Default is all.
    array        Selection based on array IDs. Default is all.
    observation  Selection based on observation IDs. Default is all.
    scan         Select data by scan numbers.
    combine      Ignore changes in these columns (scan, field, and/or state) when aggregating samples to compute weights. The value "corr" is also supported to aggregate samples across correlations.
    timebin      Length for binning in time to determine statistics. Can either be integer to be multiplied by the representative integration time, a quantity (string) in time units
    slidetimebin Use a sliding window for time binning, as opposed to time block processing?
    chanbin      Channel bin width for computing weights. Can either be integer, in which case it is interpreted as number of channels to include in each bin, or a string "spw" or quantity with frequency units.
    minsamp      Minimum number of unflagged visibilities required for computing weights in a sample. Must be >= 2.
    statalg      Statistics algorithm to use for computing variances. Supported values are "chauvenet", "classic", "fit-half", and "hinges-fences". Minimum match is supported, although the full string must be specified for the subparameters to appear in the inputs list.
    fence        Fence value for statalg="hinges-fences". A negative value means use the entire data set (ie default to the "classic" algorithm). Ignored if statalg is not "hinges-fences".
    center       Center to use for statalg="fit-half". Valid choices are "mean", "median", and "zero". Ignored if statalg is not "fit-half".
    lside        For statalg="fit-half", real data are <=; center? If false, real data are >= center. Ignored if statalg is not "fit-half".
    zscore       For statalg="chauvenet", this is the target maximum number of standard deviations data may have to be included. If negative, use Chauvenet\'s criterion. Ignored if statalg is not "chauvenet".
    maxiter      For statalg="chauvenet", this is the maximum number of iterations to attempt. Iterating will stop when either this limit is reached, or the zscore criterion is met. If negative, iterate until the zscore criterion is met. Ignored if statalg is not "chauvenet".
    fitspw       Channels to include in the computation of weights. Specified as an MS select channel selection string.
    excludechans If True: invert the channel selection in fitspw and exclude the fitspw selection from the computation of the weights.
    wtrange      Range of acceptable weights. Data with weights outside this range will be flagged. Empty array (default) means all weights are good.
    flagbackup   Back up the state of flags before the run?
    preview      Preview mode. If True, no data is changed, although the amount of data that would have been flagged is reported.
    datacolumn   Data column to use to compute weights. Supported values are "data", "corrected", "residual", and "residual_data" (case insensitive, minimum match supported).

    --------- examples -----------------------------------------------------------

    
    IF NOT RUN IN PREVIEW MODE, THIS APPLICATION WILL MODIFY THE WEIGHT, WEIGHT SPECTRUM, FLAG,
    AND FLAG_ROW COLUMNS OF THE INPUT MS. IF YOU WANT A PRISTINE COPY OF THE INPUT MS TO BE
    PRESERVED, YOU SHOULD MAKE A COPY OF IT BEFORE RUNNING THIS APPLICATION.
    
    This application computes weights for the WEIGHT and WEIGHT_SPECTRUM (if present) columns
    based on the variance of values in the CORRECTED_DATA or DATA column. If the MS does not
    have the specified data column, the application will fail. The following algorithm is used:
    
    1. For unflagged data in each sample, create two sets of values, one set is composed solely
    of the real part of the data values, the other set is composed solely of the imaginary
    part of the data values.
    2. Compute the variance of each of these sets, vr and vi.
    3. Compute veq = (vr + vi)/2.
    4. The associated weight is just the reciprocal of veq. The weight will have unit
    of (data unit)^(-2), eg Jy^(-2).
    
    Data are aggregated on a per-baseline, per-data description ID basis. Data are aggregated
    in bins determined by the specified values of the timebin and chanbin parameters. By default,
    data for separate correlations are aggregated separately. This behavior can be overriden
    by specifying combine="corr" (see below).
    
    RULES REGARDING CREATING/INITIALIZING WEIGHT_SPECTRUM COLUMN
    
    1. If run in preview mode (preview=True), no data are modified and no columns are added.
    2. Else if the MS already has a WEIGHT_SPECTRUM and this column has been initialized (has values),
    it will always be populated with the new weights.  The WEIGHT column will be populated with
    the corresponding median values of the associated WEIGHT_SPECTRUM array.
    3. Else if the frequency range specified for the sample is not the default ("spw"), the
    WEIGHT_SPECTRUM column will be created (if it doesn't already exist) and the new weights
    will be written to it.  The WEIGHT column should be populated with the corresponding median
    values of the WEIGHT_SPECTRUM array.
    4. Otherwise the single value for each spectral window will be written to the WEIGHT column;
    the WEIGHT_SPECTRUM column will not be added if it doesn't already exist, and if it does,
    it will remain uninitialized (no values will be written to it).
    
    TIME BINNING
    
    One of two algorithms can be used for time binning. If slidetimebin=True, then
    a sliding time bin of the specified width is used. If slidetimebin=False, then
    block time processing is used. The sliding time bin algorithm will generally be
    both more memory intensive and take longer than the block processing algorithm.
    Each algorithm is discussed in detail below.
    
    If the value of timebin is an integer, it means that the specified value should be
    multiplied by the representative integration time in the MS. This integration is the
    median value of all the values in the INTERVAL column. Flags are not considered in
    the integration time computation. If either extrema in the INTERVAL column differs from
    the median by more than 25%, the application will fail because the values vary too much
    for there to be a single, representative, integration time. The timebin parameter can
    also be specified as a quantity (string) that must have time conformant units.
    
    Block Time Processing
    
    The data are processed in blocks. This means that all weight spectrum values will be set to
    the same value for all points within the same time bin/channel bin/correlation bin (
    see the section on channel binning and description of combine="corr" for more details on
    channel binning and correlation binning).
    The time bins are not necessarily contiguous and are not necessarily the same width. The start
    of a bin is always coincident with a value from the TIME column, So for example, if values
    from the time column are [20, 60, 100, 140, 180, 230], and the width of the bins is chosen
    to be 110s, the first bin would start at 20s and run to 130s, so that data from timestamps
    20, 60, and 100 will be included in the first bin. The second bin would start at 140s, so that
    data for timestamps 140, 180, and 230 would be included in the second bin. Also, time binning
    does not span scan boundaries, so that data associated with different scan numbers will
    always be binned separately; changes in SCAN_NUMBER will cause a new time bin to be created,
    with its starting value coincident with the time of the new SCAN_NUMBER. Similar behavior can
    be expected for changes in FIELD_ID and ARRAY_ID. One can override this behavior for some
    columns by specifying the combine parameter (see below).
    
    Sliding Time Window Processing
    
    In this case, the time window is always centered on the timestamp of the row in question
    and extends +/-timebin/2 around that timestamp, subject the the time block boundaries.
    Rows with the same baselines and data description IDs which are included in that window
    are used for determining the weight of that row. The boundaries of the time block to which
    the window is restricted are determined by changes in FIELD_ID, ARRAY_ID, and SCAN_NUMBER.
    One can override this behavior for FIELD_ID and/or SCAN_NUMBER by specifying the combine
    parameter (see below). Unlike the time block processing algorithm, this sliding time window
    algorithm requires that details all rows for the time block in question are kept in memory,
    and thus the sliding window algorithm in general requires more memory than the  blcok
    processing method. Also, unlike the block processing method which computes a single value
    for all weights within a single bin, the sliding window method requires that each row
    (along with each channel and correlation bin) be processed individually, so in general
    the sliding window method will take longer than the block processing method.
    
    CHANNEL BINNING
    
    The width of channel bins is specified via the chanbin parameter. Channel binning occurs within
    individual spectral windows; bins never span multiple spectral windows. Each channel will
    be included in exactly one bin.
    
    The default value "spw" indicates that all channels in each spectral window are to be
    included in a single bin.
    
    Any other string value is interpreted as a quantity, and so should have frequency units, eg
    "1MHz". In this case, the channel frequencies from the CHAN_FREQ column of the SPECTRAL_WINDOW
    subtable of the MS are used to determine the bins. The first bin starts at the channel frequency
    of the 0th channel in the spectral window. Channels with frequencies that differ by less than
    the value specified by the chanbin parameter are included in this bin. The next bin starts at
    the frequency of the first channel outside the first bin, and the process is repeated until all
    channels have been binned.
    
    If specified as an integer, the value is interpreted as the number of channels to include in
    each bin. The final bin in the spectral window may not necessarily contain this number of
    channels. For example, if a spectral window has 15 channels, and chanbin is specified to be 6,
    then channels 0-5 will comprise the first bin, channels 6-11 the second, and channels 12-14 the
    third, so that only three channels will comprise the final bin.
    
    MINIMUM REQUIRED NUMBER OF VISIBILITIES
    
    The minsamp parameter allows the user to specify the minimum number of unflagged visibilities that
    must be present in a sample for that sample's weight to be computed. If a sample has less than
    this number of unflagged points, the associated weights of all the points in the sample are
    set to zero, and all the points in the sample are flagged.
    
    AGGREGATING DATA ACROSS BOUNDARIES
    
    By default, data are not aggregated across changes in values in the columns ARRAY_ID,
    SCAN_NUMBER, STATE_ID, FIELD_ID, and DATA_DESC_ID. One can override this behavior for
    SCAN_NUMBER, STATE_ID, and FIELD_ID by specifying the combine parameter. For example,
    specifying combine="scan" will ignore scan boundaries when aggregating data. Specifying
    combine="field, scan" will ignore both scan and field boundaries when aggregating data.
    
    Also by default, data for separate correlations are aggregated separately. Data for all
    correlations within each spectral window can be aggregated together by specifying
    "corr" in the combine parameter.
    
    Any combination and permutation of "scan", "field", "state", and "corr" are supported
    by the combine parameter. Other values will be silently ignored.
    
    STATISTICS ALGORITHMS
    
    The supported statistics algorithms are described in detail in the imstat and ia.statistics()
    help. For the current application, these algorithms are used to compute vr and vi (see above),
    such that the set of the real parts of the visibilities and the set of the imaginary parts of
    the visibilities are treated as independent data sets.
    
    RANGE OF ACCEPTABLE WEIGHTS
    
    The wtrange parameter allows one to specify the acceptable range (inclusive, except for zero)
    for weights. Data with weights computed to be outside this range will be flagged. If not
    specified (empty array), all weights are considered to be acceptable. If specified, the array
    must contain exactly two nonnegative numeric values. Note that data with weights of zero are
    always flagged.
    
    EXCLUDING CHANNELS
    
    Channels can be excluded from the computation of the weights by specifying the excludechans
    parameter. This parameter accepts a valid MS channel selection string. Data associated with
    the selected channels will not be used in computing the weights.
    
    PREVIEW MODE
    
    By setting preview=True, the application is run in "preview" mode. In this mode, no data
    in the input MS are changed, although the amount of data that the application would have
    flagged is reported.
    
    DATA COLUMN
    
    The datacolumn parameter can be specified to indicate which data column should be used
    for computing the weights. The values "corrected" for the CORRECTED_DATA column and "data"
    for the DATA column are supported (minimum match, case insensitive).
    
    OTHER CONSIDERATIONS
    
    Flagged values are not used in computing the weights, although the associated weights of
    these values are updated.
    
    If the variance for a set of data is 0, all associated flags for that data are set to True,
    and the corresponding weights are set to 0.
    
    EXAMPLE
    
    # update the weights of an MS using time binning of 300s
    statwt("my.ms", timebin="300s")
    


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Compute and set weights based on variance of data."""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'selectdata': {'type': 'cBool'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'combine': {'type': 'cStr'}, 'timebin': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'slidetimebin': {'type': 'cBool'}, 'chanbin': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'minsamp': {'type': 'cInt'}, 'statalg': {'type': 'cStr'}, 'fence': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'center': {'type': 'cStr'}, 'lside': {'type': 'cBool'}, 'zscore': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'maxiter': {'type': 'cInt'}, 'fitspw': {'type': 'cStr'}, 'excludechans': {'type': 'cBool'}, 'wtrange': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'flagbackup': {'type': 'cBool'}, 'preview': {'type': 'cBool'}, 'datacolumn': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __slidetimebin_dflt( self, glb ):
        return False

    def __slidetimebin( self, glb ):
        if 'slidetimebin' in glb: return glb['slidetimebin']
        return False

    def __combine_dflt( self, glb ):
        return ''

    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        return ''

    def __fitspw_dflt( self, glb ):
        return ''

    def __fitspw( self, glb ):
        if 'fitspw' in glb: return glb['fitspw']
        return ''

    def __excludechans_dflt( self, glb ):
        return False

    def __excludechans( self, glb ):
        if 'excludechans' in glb: return glb['excludechans']
        return False

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __timebin_dflt( self, glb ):
        return '0.001s'

    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        return '0.001s'

    def __minsamp_dflt( self, glb ):
        return int(2)

    def __minsamp( self, glb ):
        if 'minsamp' in glb: return glb['minsamp']
        return int(2)

    def __flagbackup_dflt( self, glb ):
        return True

    def __flagbackup( self, glb ):
        if 'flagbackup' in glb: return glb['flagbackup']
        return True

    def __preview_dflt( self, glb ):
        return False

    def __preview( self, glb ):
        if 'preview' in glb: return glb['preview']
        return False

    def __datacolumn_dflt( self, glb ):
        return 'corrected'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'corrected'

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __chanbin_dflt( self, glb ):
        return 'spw'

    def __chanbin( self, glb ):
        if 'chanbin' in glb: return glb['chanbin']
        return 'spw'

    def __wtrange_dflt( self, glb ):
        return [  ]

    def __wtrange( self, glb ):
        if 'wtrange' in glb: return glb['wtrange']
        return [  ]

    def __statalg_dflt( self, glb ):
        return 'classic'

    def __statalg( self, glb ):
        if 'statalg' in glb: return glb['statalg']
        return 'classic'



    #--------- return inp/go default --------------------------------------------------
    def __field_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __lside_dflt( self, glb ):
        if self.__statalg( glb ) == "fit-half": return bool(True)
        return None
    def __intent_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __center_dflt( self, glb ):
        if self.__statalg( glb ) == "fit-half": return "mean"
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __fence_dflt( self, glb ):
        if self.__statalg( glb ) == "hinges-fences": return float(-1)
        return None
    def __array_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __zscore_dflt( self, glb ):
        if self.__statalg( glb ) == "chauvenet": return float(-1)
        return None
    def __maxiter_dflt( self, glb ):
        if self.__statalg( glb ) == "chauvenet": return int(-1)
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spw_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        dflt = self.__field_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        dflt = self.__spw_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        dflt = self.__array_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __fence( self, glb ):
        if 'fence' in glb: return glb['fence']
        dflt = self.__fence_dflt( glb )
        if dflt is not None: return dflt
        return float(-1)
    def __center( self, glb ):
        if 'center' in glb: return glb['center']
        dflt = self.__center_dflt( glb )
        if dflt is not None: return dflt
        return 'mean'
    def __lside( self, glb ):
        if 'lside' in glb: return glb['lside']
        dflt = self.__lside_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __zscore( self, glb ):
        if 'zscore' in glb: return glb['zscore']
        dflt = self.__zscore_dflt( glb )
        if dflt is not None: return dflt
        return float(-1)
    def __maxiter( self, glb ):
        if 'maxiter' in glb: return glb['maxiter']
        dflt = self.__maxiter_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __selectdata_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('selectdata',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        if self.__field_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__field( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spw_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spw( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__intent( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __array_inp(self):
        out = self.__stdout or sys.stdout
        if self.__array_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__array( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('array',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__observation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__scan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __combine_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__combine( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('combine',pre,self.__to_string_(value),post,description))
    def __timebin_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timebin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('timebin',pre,self.__to_string_(value),post,description))
    def __slidetimebin_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__slidetimebin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'slidetimebin': value},{'slidetimebin': self.__schema['slidetimebin']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('slidetimebin',pre,self.__to_string_(value),post,description))
    def __chanbin_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chanbin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chanbin': value},{'chanbin': self.__schema['chanbin']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('chanbin',pre,self.__to_string_(value),post,description))
    def __minsamp_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__minsamp( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'minsamp': value},{'minsamp': self.__schema['minsamp']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('minsamp',pre,self.__to_string_(value),post,description))
    def __statalg_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__statalg( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'statalg': value},{'statalg': self.__schema['statalg']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('statalg',pre,self.__to_string_(value),post,description))
    def __fence_inp(self):
        out = self.__stdout or sys.stdout
        if self.__fence_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__fence( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'fence': value},{'fence': self.__schema['fence']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fence',pre,self.__to_string_(value),post,description))
    def __center_inp(self):
        out = self.__stdout or sys.stdout
        if self.__center_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__center( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'center': value},{'center': self.__schema['center']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('center',pre,self.__to_string_(value),post,description))
    def __lside_inp(self):
        out = self.__stdout or sys.stdout
        if self.__lside_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__lside( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'lside': value},{'lside': self.__schema['lside']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('lside',pre,self.__to_string_(value),post,description))
    def __zscore_inp(self):
        out = self.__stdout or sys.stdout
        if self.__zscore_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__zscore( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'zscore': value},{'zscore': self.__schema['zscore']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('zscore',pre,self.__to_string_(value),post,description))
    def __maxiter_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maxiter_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__maxiter( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maxiter': value},{'maxiter': self.__schema['maxiter']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maxiter',pre,self.__to_string_(value),post,description))
    def __fitspw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__fitspw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'fitspw': value},{'fitspw': self.__schema['fitspw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('fitspw',pre,self.__to_string_(value),post,description))
    def __excludechans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__excludechans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'excludechans': value},{'excludechans': self.__schema['excludechans']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('excludechans',pre,self.__to_string_(value),post,description))
    def __wtrange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__wtrange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'wtrange': value},{'wtrange': self.__schema['wtrange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('wtrange',pre,self.__to_string_(value),post,description))
    def __flagbackup_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__flagbackup( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'flagbackup': value},{'flagbackup': self.__schema['flagbackup']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('flagbackup',pre,self.__to_string_(value),post,description))
    def __preview_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__preview( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'preview': value},{'preview': self.__schema['preview']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('preview',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'fitspw' in glb: del glb['fitspw']
        if 'excludechans' in glb: del glb['excludechans']
        if 'statalg' in glb: del glb['statalg']
        if 'field' in glb: del glb['field']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'lside' in glb: del glb['lside']
        if 'intent' in glb: del glb['intent']
        if 'slidetimebin' in glb: del glb['slidetimebin']
        if 'center' in glb: del glb['center']
        if 'preview' in glb: del glb['preview']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'fence' in glb: del glb['fence']
        if 'timebin' in glb: del glb['timebin']
        if 'wtrange' in glb: del glb['wtrange']
        if 'array' in glb: del glb['array']
        if 'chanbin' in glb: del glb['chanbin']
        if 'zscore' in glb: del glb['zscore']
        if 'maxiter' in glb: del glb['maxiter']
        if 'combine' in glb: del glb['combine']
        if 'observation' in glb: del glb['observation']
        if 'flagbackup' in glb: del glb['flagbackup']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'minsamp' in glb: del glb['minsamp']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__selectdata_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__observation_inp( )
        self.__scan_inp( )
        self.__combine_inp( )
        self.__timebin_inp( )
        self.__slidetimebin_inp( )
        self.__chanbin_inp( )
        self.__minsamp_inp( )
        self.__statalg_inp( )
        self.__fence_inp( )
        self.__center_inp( )
        self.__lside_inp( )
        self.__zscore_inp( )
        self.__maxiter_inp( )
        self.__fitspw_inp( )
        self.__excludechans_inp( )
        self.__wtrange_inp( )
        self.__flagbackup_inp( )
        self.__preview_inp( )
        self.__datacolumn_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("statwt.last"):
                filename = "statwt.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, selectdata=None, field=None, spw=None, intent=None, array=None, observation=None, scan=None, combine=None, timebin=None, slidetimebin=None, chanbin=None, minsamp=None, statalg=None, fence=None, center=None, lside=None, zscore=None, maxiter=None, fitspw=None, excludechans=None, wtrange=None, flagbackup=None, preview=None, datacolumn=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('statwt.pre')
        _postfile = os.path.realpath('statwt.last')
        _return_result_ = None
        _arguments = [vis,selectdata,field,spw,intent,array,observation,scan,combine,timebin,slidetimebin,chanbin,minsamp,statalg,fence,center,lside,zscore,maxiter,fitspw,excludechans,wtrange,flagbackup,preview,datacolumn]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if selectdata is not None: local_global['selectdata'] = selectdata
            if combine is not None: local_global['combine'] = combine
            if timebin is not None: local_global['timebin'] = timebin
            if slidetimebin is not None: local_global['slidetimebin'] = slidetimebin
            if chanbin is not None: local_global['chanbin'] = chanbin
            if minsamp is not None: local_global['minsamp'] = minsamp
            if statalg is not None: local_global['statalg'] = statalg
            if fitspw is not None: local_global['fitspw'] = fitspw
            if excludechans is not None: local_global['excludechans'] = excludechans
            if wtrange is not None: local_global['wtrange'] = wtrange
            if flagbackup is not None: local_global['flagbackup'] = flagbackup
            if preview is not None: local_global['preview'] = preview
            if datacolumn is not None: local_global['datacolumn'] = datacolumn

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['combine'] = self.__combine( local_global )
            _invocation_parameters['timebin'] = self.__timebin( local_global )
            _invocation_parameters['slidetimebin'] = self.__slidetimebin( local_global )
            _invocation_parameters['chanbin'] = self.__chanbin( local_global )
            _invocation_parameters['minsamp'] = self.__minsamp( local_global )
            _invocation_parameters['statalg'] = self.__statalg( local_global )
            _invocation_parameters['fitspw'] = self.__fitspw( local_global )
            _invocation_parameters['excludechans'] = self.__excludechans( local_global )
            _invocation_parameters['wtrange'] = self.__wtrange( local_global )
            _invocation_parameters['flagbackup'] = self.__flagbackup( local_global )
            _invocation_parameters['preview'] = self.__preview( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['field'] = self.__field( _invocation_parameters ) if field is None else field
            _invocation_parameters['spw'] = self.__spw( _invocation_parameters ) if spw is None else spw
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['array'] = self.__array( _invocation_parameters ) if array is None else array
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['fence'] = self.__fence( _invocation_parameters ) if fence is None else fence
            _invocation_parameters['center'] = self.__center( _invocation_parameters ) if center is None else center
            _invocation_parameters['lside'] = self.__lside( _invocation_parameters ) if lside is None else lside
            _invocation_parameters['zscore'] = self.__zscore( _invocation_parameters ) if zscore is None else zscore
            _invocation_parameters['maxiter'] = self.__maxiter( _invocation_parameters ) if maxiter is None else maxiter

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['slidetimebin'] = self.__slidetimebin( self.__globals_( ) )
            _invocation_parameters['chanbin'] = self.__chanbin( self.__globals_( ) )
            _invocation_parameters['minsamp'] = self.__minsamp( self.__globals_( ) )
            _invocation_parameters['statalg'] = self.__statalg( self.__globals_( ) )
            _invocation_parameters['fence'] = self.__fence( self.__globals_( ) )
            _invocation_parameters['center'] = self.__center( self.__globals_( ) )
            _invocation_parameters['lside'] = self.__lside( self.__globals_( ) )
            _invocation_parameters['zscore'] = self.__zscore( self.__globals_( ) )
            _invocation_parameters['maxiter'] = self.__maxiter( self.__globals_( ) )
            _invocation_parameters['fitspw'] = self.__fitspw( self.__globals_( ) )
            _invocation_parameters['excludechans'] = self.__excludechans( self.__globals_( ) )
            _invocation_parameters['wtrange'] = self.__wtrange( self.__globals_( ) )
            _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
            _invocation_parameters['preview'] = self.__preview( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#statwt( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _statwt_t( _invocation_parameters['vis'],_invocation_parameters['selectdata'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['intent'],_invocation_parameters['array'],_invocation_parameters['observation'],_invocation_parameters['scan'],_invocation_parameters['combine'],_invocation_parameters['timebin'],_invocation_parameters['slidetimebin'],_invocation_parameters['chanbin'],_invocation_parameters['minsamp'],_invocation_parameters['statalg'],_invocation_parameters['fence'],_invocation_parameters['center'],_invocation_parameters['lside'],_invocation_parameters['zscore'],_invocation_parameters['maxiter'],_invocation_parameters['fitspw'],_invocation_parameters['excludechans'],_invocation_parameters['wtrange'],_invocation_parameters['flagbackup'],_invocation_parameters['preview'],_invocation_parameters['datacolumn'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

statwt = _statwt( )

