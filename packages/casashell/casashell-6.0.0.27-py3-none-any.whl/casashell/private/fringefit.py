##################### generated by xml-casa (v2) from fringefit.xml #################
##################### 6d9f3205347c29f8d8ba6f3080278941 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import fringefit as _fringefit_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _fringefit:
    """
    fringefit ---- Fringe fit delay and rates

    
    Phase offsets, groups delays and delay rates are calculated with
    respect to a specified referance antenna by a two-dimensional FFT and
    subsequent least-squares optimisation.
    
    Previous calibrations should be applied on the fly.

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file
    caltable    Name of output gain calibration table
    field       Select field using field id(s) or field name(s)
    spw         Select spectral window/channels
    intent      Select observing intent
    selectdata  Other data selection parameters
    timerange   Select data based on time range
    antenna     Select data based on antenna/baseline
    scan        Scan number range
    observation Select by observation ID(s)
    msselect    Optional complex data selection (ignore for now)
    solint      Solution interval: egs. \'inf\', \'60s\' (see help)
    combine     Data axes which to combine for solve (obs, scan, spw, and/or field)
    refant      Reference antenna name(s)
    minsnr      Reject solutions below this signal-to-noise ratio (at the FFT stage)
    zerorates   Zero delay-rates in solution table
    globalsolve Refine estimates of delay and rate with global least-squares solver
    niter       Maximum number of iterations for least-squares solver
    delaywindow Constrain FFT delay search to a window; a two-element list, units of nanoseconds
    ratewindow  Constrain FFT rate search to a window; a two-element list, units of seconds per second
    append      Append solutions to the (existing) table
    docallib    Use callib or traditional cal apply parameters
    callib      Cal Library filename
    gaintable   Gain calibration table(s) to apply on the fly
    gainfield   Select a subset of calibrators from gaintable(s)
    interp      Temporal interpolation for each gaintable (''=linear)
    spwmap      Spectral windows combinations to form for gaintables(s)
    parang      Apply parallactic angle correction on the fly

    --------- examples -----------------------------------------------------------

    
    
    Previous calibrations (egs, bandpass, opacity, parallactic angle) can
    be applied on the fly.  At present with dual-polarized data, both
    polarizations must be unflagged for any solution to be obtained.
    
    Keyword arguments:
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    caltable -- Name of output fringefit calibration table
    default: none; example: caltable='ngc5921.fringe'
    
    --- Data Selection (see help par.selectdata for more detailed information)
    
    field -- Select field using field id(s) or field name(s).
    ['go listobs' to obtain the list id's or names]
    default: ''=all fields
    If field string is a non-negative integer, it is assumed a
    field index,  otherwise, it is assumed a field name
    field='0~2'; field ids 0,1,2
    field='0,4,5~7'; field ids 0,4,5,6,7
    field='3C286,3C295'; field named 3C286 and 3C295
    field = '3,4C*'; field id 3, all names starting with 4C
    DON'T FORGET TO INCLUDE THE FLUX DENSITY CALIBRATOR IF YOU HAVE ONE
    spw -- Select spectral window/channels
    type 'help par.selection' for more examples.
    spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
    spw='<2';  spectral windows less than 2 (i.e. 0,1)
    spw='0:5~61'; spw 0, channels 5 to 61, INCLUSIVE
    spw='*:5~61'; all spw with channels 5 to 61
    spw='0,10,3:3~45'; spw 0,10 all channels, spw 3, channels 3 to 45.
    spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
    spw='0:0~10;15~60'; spectral window 0 with channels 0-10,15-60
    NOTE ';' to separate channel selections
    spw='0:0~10^2,1:20~30^5'; spw 0, channels 0,2,4,6,8,10,
    spw 1, channels 20,25,30
    intent -- Select observing intent
    default: ''  (no selection by intent)
    intent='*FRINGEFIT*'  (selects data labelled with
    FRINGEFIT intent)
    selectdata -- Other data selection parameters
    default: True
    
    Must set selectdata=True to use the following selections:
    
    timerange  -- Select data based on time range:
    default = '' (all); examples,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: if YYYY/MM/DD is missing date defaults to first day in data set
    timerange='09:14:0~09:54:0' picks 40 min on first day
    timerange= '25:00:00~27:30:00' picks 1 hr to 3 hr 30min on NEXT day
    timerange='09:44:00' pick data within one integration of time
    timerange='>10:24:00' data after this time
    uvrange -- Select data within uvrange (default units meters)
    default: '' (all); example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
    uvrange='>4klambda';uvranges greater than 4 kilo lambda
    antenna -- Select data based on antenna/baseline
    default: '' (all)
    If antenna string is a non-negative integer, it is assumed an
    antenna index, otherwise, it is assumed as an antenna name
    antenna='5&6'; baseline between antenna index 5 and index 6.
    antenna='VA05&VA06'; baseline between VLA antenna 5 and 6.
    antenna='5&6;7&8'; baselines with indices 5-6 and 7-8
    antenna='5'; all baselines with antenna index 5
    antenna='05'; all baselines with antenna number 05 (VLA old name)
    antenna='5,6,10'; all baselines with antennas 5,6,10 index numbers
    scan -- Scan number range.
    Check 'go listobs' to insure the scan numbers are in order.
    observation -- Observation ID(s).
    default: '' = all
    example: '0~2,4'
    msselect -- Optional complex data selection (ignore for now)
    
    solint --  Solution interval (units optional)
    default: 'inf' (~infinite, up to boundaries controlled by combine);
    Options: 'inf' (~infinite),
    'int' (per integration)
    any float or integer value with or without units
    examples: solint='1min'; solint='60s'; solint=60 --> 1 minute
    solint='0s'; solint=0; solint='int' --> per integration
    solint-'-1s'; solint='inf' --> ~infinite, up to boundaries
    interacts with combine
    combine -- Data axes to combine for solving
    default: '' --> solutions will break at obs, scan, field, and spw
    boundaries
    Options: '','obs','scan','spw',field', or any comma-separated
    combination in a single string
    For gaintype='K', if combine includes 'spw', multi-band
    delays will be determined; otherwise, (per-spw)
    single-band delays will be determined.
    example: combine='scan,spw'  --> extend solutions over scan boundaries
    (up to the solint), and combine spws for solving
    refant -- Reference antenna name(s); a prioritized list may be
    specified for solving and for applying solutions. For
    solving, the first reference antenna associated with
    unflagged data is used for the solution.
    default: '' => no refant applied
    example: refant='4' (antenna with index 4)
    refant='VA04' (VLA antenna #4)
    refant='EA02,EA23,EA13' (EVLA antenna EA02, use
    EA23 and EA13 as alternates if/when EA02
    drops out)
    Use taskname=listobs for antenna listing
    minsnr -- Reject solutions below this SNR
    default: 3.0
    solnorm -- Normalize average solution amps to 1.0 after solution (G, T only)
    default: False (no normalization)
    append -- Append solutions to the (existing) table.  Appended solutions
    must be derived from the same MS as the existing
    caltable, and solution spws must have the same
    meta-info (according to spw selection and solint)
    or be non-overlapping.
    default: False; overwrite existing table or make new table
    zerorates -- Write a solution table with delay-rates zeroed, for
    the case of "manual phase calibration".
    default: False
    
    globalsolve -- Refine fringefit solutions with global least-squares solver.
    default: False
    
    
    delaywindow -- Constrain FFT delay search to a window
    ratewindow -- Constrain FFT rate search to a window
    
    --- Other calibrations to apply on the fly before determining
    fringe fit solution
    
    docallib -- Control means of specifying the caltables:
    default: False ==> Use gaintable,gainfield,interp,spwmap,calwt
    If True, specify a file containing cal library in callib
    callib -- If docallib=True, specify a file containing cal
    library directives
    
    gaintable -- Gain calibration table(s) to apply
    default: '' (none);
    examples: gaintable='ngc5921.gcal'
    gaintable=['ngc5921.ampcal','ngc5921.phcal']
    gainfield -- Select a subset of calibrators from gaintable(s) to apply
    default:'' ==> all sources in table;
    'nearest' ==> nearest (on sky) available field in table
    otherwise, same syntax as field
    example: gainfield='0~2,5' means use fields 0,1,2,5 from gaintable
    gainfield=['0~3','4~6'] means use field 0 through 3
    from first gain file, field 4 through 6 for second.
    interp -- Interpolation type (in time[,freq]) to use for each gaintable.
    When frequency interpolation is relevant (B, Df, Xf),
    separate time-dependent and freq-dependent interp
    types with a comma (freq _after_ the comma).
    Specifications for frequency are ignored when the
    calibration table has no channel-dependence.
    Time-dependent interp options ending in 'PD' enable a
    "phase delay" correction per spw for non-channel-dependent
    calibration types.
    For multi-obsId datasets, 'perobs' can be appended to
    the time-dependent interpolation specification to
    enforce obsId boundaries when interpolating in time.
    default: '' --> 'linear,linear' for all gaintable(s)
    example: interp='nearest'   (in time, freq-dep will be
    linear, if relevant)
    interp='linear,cubic'  (linear in time, cubic
    in freq)
    interp='linearperobs,spline' (linear in time
    per obsId,
    spline in freq)
    interp=',spline'  (spline in freq; linear in
    time by default)
    interp=['nearest,spline','linear']  (for multiple gaintables)
    Options: Time: 'nearest', 'linear'
    Freq: 'nearest', 'linear', 'cubic', 'spline'
    spwmap -- Spectral windows combinations to form for gaintable(s)
    default: [] (apply solutions from each spw to that spw only)
    Example:  spwmap=[0,0,1,1] means apply the caltable solutions
    from spw = 0 to the spw 0,1 and spw 1 to spw 2,3.
    spwmap=[[0,0,1,1],[0,1,0,1]]
    parang -- If True, apply the parallactic angle correction (required
    for polarization calibration)
    default: False


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Fringe fit delay and rates"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cStr'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'selectdata': {'type': 'cBool'}, 'timerange': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'msselect': {'type': 'cStr'}, 'solint': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'combine': {'type': 'cStr'}, 'refant': {'type': 'cStr'}, 'minsnr': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'zerorates': {'type': 'cBool'}, 'globalsolve': {'type': 'cBool'}, 'niter': {'type': 'cInt'}, 'delaywindow': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'ratewindow': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'append': {'type': 'cBool'}, 'docallib': {'type': 'cBool'}, 'callib': {'type': 'cStr'}, 'gaintable': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'gainfield': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'interp': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'parang': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __solint_dflt( self, glb ):
        return 'inf'

    def __solint( self, glb ):
        if 'solint' in glb: return glb['solint']
        return 'inf'

    def __parang_dflt( self, glb ):
        return False

    def __parang( self, glb ):
        if 'parang' in glb: return glb['parang']
        return False

    def __combine_dflt( self, glb ):
        return ''

    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __ratewindow_dflt( self, glb ):
        return [  ]

    def __ratewindow( self, glb ):
        if 'ratewindow' in glb: return glb['ratewindow']
        return [  ]

    def __zerorates_dflt( self, glb ):
        return False

    def __zerorates( self, glb ):
        if 'zerorates' in glb: return glb['zerorates']
        return False

    def __globalsolve_dflt( self, glb ):
        return True

    def __globalsolve( self, glb ):
        if 'globalsolve' in glb: return glb['globalsolve']
        return True

    def __refant_dflt( self, glb ):
        return ''

    def __refant( self, glb ):
        if 'refant' in glb: return glb['refant']
        return ''

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __delaywindow_dflt( self, glb ):
        return [  ]

    def __delaywindow( self, glb ):
        if 'delaywindow' in glb: return glb['delaywindow']
        return [  ]

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __minsnr_dflt( self, glb ):
        return float(3.0)

    def __minsnr( self, glb ):
        if 'minsnr' in glb: return glb['minsnr']
        return float(3.0)

    def __append_dflt( self, glb ):
        return False

    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        return False

    def __niter_dflt( self, glb ):
        return int(100)

    def __niter( self, glb ):
        if 'niter' in glb: return glb['niter']
        return int(100)

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __docallib_dflt( self, glb ):
        return False

    def __docallib( self, glb ):
        if 'docallib' in glb: return glb['docallib']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __callib_dflt( self, glb ):
        if self.__docallib( glb ) == bool(True): return ""
        return None
    def __gainfield_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __msselect_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __interp_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __gaintable_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __msselect( self, glb ):
        if 'msselect' in glb: return glb['msselect']
        dflt = self.__msselect_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __callib( self, glb ):
        if 'callib' in glb: return glb['callib']
        dflt = self.__callib_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __gaintable( self, glb ):
        if 'gaintable' in glb: return glb['gaintable']
        dflt = self.__gaintable_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        dflt = self.__gainfield_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [ ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __caltable_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('caltable',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __selectdata_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('selectdata',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__scan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __observation_inp(self):
        out = self.__stdout or sys.stdout
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__observation( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('observation',pre,self.__to_string_(value),post,description))
    def __msselect_inp(self):
        out = self.__stdout or sys.stdout
        if self.__msselect_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__msselect( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'msselect': value},{'msselect': self.__schema['msselect']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('msselect',pre,self.__to_string_(value),post,description))
    def __solint_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__solint( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'solint': value},{'solint': self.__schema['solint']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('solint',pre,self.__to_string_(value),post,description))
    def __combine_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__combine( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('combine',pre,self.__to_string_(value),post,description))
    def __refant_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__refant( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'refant': value},{'refant': self.__schema['refant']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('refant',pre,self.__to_string_(value),post,description))
    def __minsnr_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__minsnr( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'minsnr': value},{'minsnr': self.__schema['minsnr']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('minsnr',pre,self.__to_string_(value),post,description))
    def __zerorates_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__zerorates( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'zerorates': value},{'zerorates': self.__schema['zerorates']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('zerorates',pre,self.__to_string_(value),post,description))
    def __globalsolve_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__globalsolve( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'globalsolve': value},{'globalsolve': self.__schema['globalsolve']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('globalsolve',pre,self.__to_string_(value),post,description))
    def __niter_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__niter( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'niter': value},{'niter': self.__schema['niter']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('niter',pre,self.__to_string_(value),post,description))
    def __delaywindow_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__delaywindow( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'delaywindow': value},{'delaywindow': self.__schema['delaywindow']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('delaywindow',pre,self.__to_string_(value),post,description))
    def __ratewindow_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__ratewindow( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'ratewindow': value},{'ratewindow': self.__schema['ratewindow']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('ratewindow',pre,self.__to_string_(value),post,description))
    def __append_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__append( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('append',pre,self.__to_string_(value),post,description))
    def __docallib_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__docallib( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'docallib': value},{'docallib': self.__schema['docallib']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('docallib',pre,self.__to_string_(value),post,description))
    def __callib_inp(self):
        out = self.__stdout or sys.stdout
        if self.__callib_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__callib( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'callib': value},{'callib': self.__schema['callib']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('callib',pre,self.__to_string_(value),post,description))
    def __gaintable_inp(self):
        out = self.__stdout or sys.stdout
        if self.__gaintable_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__gaintable( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'gaintable': value},{'gaintable': self.__schema['gaintable']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gaintable',pre,self.__to_string_(value),post,description))
    def __gainfield_inp(self):
        out = self.__stdout or sys.stdout
        if self.__gainfield_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__gainfield( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('gainfield',pre,self.__to_string_(value),post,description))
    def __interp_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interp( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interp',pre,self.__to_string_(value),post,description))
    def __spwmap_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-11.11s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwmap',pre,self.__to_string_(value),post,description))
    def __parang_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__parang( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'parang': value},{'parang': self.__schema['parang']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-14.14s = %s%-23.22s%s # %-.60s\n' % ('parang',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'callib' in glb: del glb['callib']
        if 'gainfield' in glb: del glb['gainfield']
        if 'ratewindow' in glb: del glb['ratewindow']
        if 'zerorates' in glb: del glb['zerorates']
        if 'parang' in glb: del glb['parang']
        if 'field' in glb: del glb['field']
        if 'globalsolve' in glb: del glb['globalsolve']
        if 'msselect' in glb: del glb['msselect']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'refant' in glb: del glb['refant']
        if 'minsnr' in glb: del glb['minsnr']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'interp' in glb: del glb['interp']
        if 'delaywindow' in glb: del glb['delaywindow']
        if 'docallib' in glb: del glb['docallib']
        if 'combine' in glb: del glb['combine']
        if 'niter' in glb: del glb['niter']
        if 'solint' in glb: del glb['solint']
        if 'caltable' in glb: del glb['caltable']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'gaintable' in glb: del glb['gaintable']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__observation_inp( )
        self.__msselect_inp( )
        self.__solint_inp( )
        self.__combine_inp( )
        self.__refant_inp( )
        self.__minsnr_inp( )
        self.__zerorates_inp( )
        self.__globalsolve_inp( )
        self.__niter_inp( )
        self.__delaywindow_inp( )
        self.__ratewindow_inp( )
        self.__append_inp( )
        self.__docallib_inp( )
        self.__callib_inp( )
        self.__gaintable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__parang_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("fringefit.last"):
                filename = "fringefit.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, caltable=None, field=None, spw=None, intent=None, selectdata=None, timerange=None, antenna=None, scan=None, observation=None, msselect=None, solint=None, combine=None, refant=None, minsnr=None, zerorates=None, globalsolve=None, niter=None, delaywindow=None, ratewindow=None, append=None, docallib=None, callib=None, gaintable=None, gainfield=None, interp=None, spwmap=None, parang=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('fringefit.pre')
        _postfile = os.path.realpath('fringefit.last')
        _return_result_ = None
        _arguments = [vis,caltable,field,spw,intent,selectdata,timerange,antenna,scan,observation,msselect,solint,combine,refant,minsnr,zerorates,globalsolve,niter,delaywindow,ratewindow,append,docallib,callib,gaintable,gainfield,interp,spwmap,parang]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if intent is not None: local_global['intent'] = intent
            if selectdata is not None: local_global['selectdata'] = selectdata
            if solint is not None: local_global['solint'] = solint
            if combine is not None: local_global['combine'] = combine
            if refant is not None: local_global['refant'] = refant
            if minsnr is not None: local_global['minsnr'] = minsnr
            if zerorates is not None: local_global['zerorates'] = zerorates
            if globalsolve is not None: local_global['globalsolve'] = globalsolve
            if niter is not None: local_global['niter'] = niter
            if delaywindow is not None: local_global['delaywindow'] = delaywindow
            if ratewindow is not None: local_global['ratewindow'] = ratewindow
            if append is not None: local_global['append'] = append
            if docallib is not None: local_global['docallib'] = docallib
            if parang is not None: local_global['parang'] = parang

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['solint'] = self.__solint( local_global )
            _invocation_parameters['combine'] = self.__combine( local_global )
            _invocation_parameters['refant'] = self.__refant( local_global )
            _invocation_parameters['minsnr'] = self.__minsnr( local_global )
            _invocation_parameters['zerorates'] = self.__zerorates( local_global )
            _invocation_parameters['globalsolve'] = self.__globalsolve( local_global )
            _invocation_parameters['niter'] = self.__niter( local_global )
            _invocation_parameters['delaywindow'] = self.__delaywindow( local_global )
            _invocation_parameters['ratewindow'] = self.__ratewindow( local_global )
            _invocation_parameters['append'] = self.__append( local_global )
            _invocation_parameters['docallib'] = self.__docallib( local_global )
            _invocation_parameters['parang'] = self.__parang( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['msselect'] = self.__msselect( _invocation_parameters ) if msselect is None else msselect
            _invocation_parameters['callib'] = self.__callib( _invocation_parameters ) if callib is None else callib
            _invocation_parameters['gaintable'] = self.__gaintable( _invocation_parameters ) if gaintable is None else gaintable
            _invocation_parameters['gainfield'] = self.__gainfield( _invocation_parameters ) if gainfield is None else gainfield
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
            _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
            _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
            _invocation_parameters['minsnr'] = self.__minsnr( self.__globals_( ) )
            _invocation_parameters['zerorates'] = self.__zerorates( self.__globals_( ) )
            _invocation_parameters['globalsolve'] = self.__globalsolve( self.__globals_( ) )
            _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
            _invocation_parameters['delaywindow'] = self.__delaywindow( self.__globals_( ) )
            _invocation_parameters['ratewindow'] = self.__ratewindow( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
            _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
            _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['parang'] = self.__parang( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#fringefit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _fringefit_t( _invocation_parameters['vis'],_invocation_parameters['caltable'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['intent'],_invocation_parameters['selectdata'],_invocation_parameters['timerange'],_invocation_parameters['antenna'],_invocation_parameters['scan'],_invocation_parameters['observation'],_invocation_parameters['msselect'],_invocation_parameters['solint'],_invocation_parameters['combine'],_invocation_parameters['refant'],_invocation_parameters['minsnr'],_invocation_parameters['zerorates'],_invocation_parameters['globalsolve'],_invocation_parameters['niter'],_invocation_parameters['delaywindow'],_invocation_parameters['ratewindow'],_invocation_parameters['append'],_invocation_parameters['docallib'],_invocation_parameters['callib'],_invocation_parameters['gaintable'],_invocation_parameters['gainfield'],_invocation_parameters['interp'],_invocation_parameters['spwmap'],_invocation_parameters['parang'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

fringefit = _fringefit( )

