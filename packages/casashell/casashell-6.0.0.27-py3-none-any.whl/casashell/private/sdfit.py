##################### generated by xml-casa (v2) from sdfit.xml #####################
##################### e5f4bc7758b363cbc46d1bccb70263c9 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import sdfit as _sdfit_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdfit:
    """
    sdfit ---- Fit a spectral line

    
    Task sdfit is a basic line-fitter for single-dish spectra.
    It assumes that the spectra have been calibrated in tsdcal
    or sdreduce.
    

    --------- parameter descriptions ---------------------------------------------

    infile     name of input SD dataset
    datacolumn name of data column to be used ["data", "float_data", or "corrected_data"]
    antenna    select data by antenna name or ID, e.g. "PM03"
    field      select data by field IDs and names, e.g. "3C2*" (""=all)
    spw        select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)
    timerange  select data by time range, e.g. "09:14:0~09:54:0" (""=all) (see examples in help)
    scan       select data by scan numbers, e.g. "21~23" (""=all)
    pol        select data by polarization IDs, e.g. "XX,YY" (""=all)
    intent     select data by observational intent, e.g. "*ON_SOURCE*" (""=all)
    timebin    bin width for time averaging
    timespan   span the timebin across "scan", "state", "field", or a combination of them (e.g., "scan,state")
    polaverage polarization averaging mode ("", "stokes" or "geometric").
    fitfunc    function for fitting
    fitmode    mode for setting additional channel masks.
    nfit       list of number of lines to fit in maskline region.
    thresh     S/N threshold for linefinder
    avg_limit  channel averaging for broad lines
    minwidth   the minimum channel width to detect as a line
    edge       channels to drop at beginning and end of spectrum
    outfile    name of output file
    overwrite  overwrite the output file if already exists
    [1;42mRETURNS[1;m       variant

    --------- examples -----------------------------------------------------------

    
    -----------------
    Keyword arguments
    -----------------
    infile -- name of input SD dataset
    datacolumn -- name of data column to be used
    options: 'data', 'float_data', or 'corrected_data'
    default: 'data'
    antenna -- select data by antenna name or ID
    default: '' (use all antennas)
    example: 'PM03'
    field -- select data by field IDs and names
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 0 or field named 3C273)
    this selection is in addition to the other selections to data
    spw -- select data by IF IDs (spectral windows)/channels
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    this selection is in addition to the other selections to data
    timerange -- select data by time range
    default: '' (use all)
    example: timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: YYYY/MM/DD can be dropped as needed:
    timerange='09:14:00~09:54:00' # this time range
    timerange='09:44:00' # data within one integration of time
    timerange='>10:24:00' # data after this time
    timerange='09:44:00+00:13:00' #data 13 minutes after time
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    this selection is in addition to the other selections to data
    pol -- select data by polarization IDs
    default: '' (use all polarizations)
    example: pol='XX,YY' (polarizations XX and YY)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: '' (use all scan intents)
    example: intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    this selection is in addition to the other selections to data
    timebin -- bin width for time averaging. it must be a positive value.
    default: '' (no averaging over time)
    example: timebin='1s' (time averaging performed over 1 second bins)
    >>> timebin expandable parameters
    timespan -- span the timebin across 'scan', 'state', 'field', or a combination of them (e.g., 'scan,state')
    default: '' (average each scan, intent and field separately)
    example: 'scan' time averaging is done across scan ID boundaries
    polaverage -- polarization averaging mode
    default: '' (no averaging over polarization)
    options: '', 'stokes', 'geometric'
    fitfunc -- function for fitting
    options: 'gaussian', 'lorentzian'
    default: 'gaussian'
    fitmode -- mode for fitting
    options: 'list' ('auto' and 'interact' will be available later)
    default: 'list'
    example: 'list' will use channel ranges specified in the parameter
    spw to fit for lines
    'auto'  will use the linefinder to fit for lines
    using the following parameters
    'interact' allows adding and deleting mask
    regions by drawing rectangles on the plot
    with mouse. Draw a rectangle with LEFT-mouse
    to ADD the region to the mask and with RIGHT-mouse
    to DELETE the region.
    >>> fitmode expandable parameters
    nfit -- list of number of lines to fit in each region specified by the
    parameter spw (only available in fitmode='list')
    default: [0] (no fitting)
    example: nfit=[1] for single line in single region,
    nfit=[2] for two lines in single region,
    nfit=[1,1] for single lines in each of two regions, etc.
    thresh -- S/N threshold for linefinder. a single channel S/N ratio
    above which the channel is considered to be a detection.
    (only available in fitmode='auto')
    default: 5
    avg_limit -- channel averaging for broad lines. a number of
    consecutive channels not greater than this parameter
    can be averaged to search for broad lines.
    (only available in fitmode='auto')
    default: 4
    minwidth -- minimum number of consecutive channels required to
    pass threshold
    (only available in fitmode='auto')
    default: 4
    edge -- channels to drop at beginning and end of spectrum
    (only available in fitmode='auto')
    default: 0
    example: edge=[1000] drops 1000 channels at beginning AND end.
    edge=[1000,500] drops 1000 from beginning and 500
    from end
    
    Note: For bad baselines threshold should be increased,
    and avg_limit decreased (or even switched off completely by
    setting this parameter to 1) to avoid detecting baseline
    undulations instead of real lines.
    outfile -- name of output file
    default: no output fit file
    example: 'mysd.fit'
    overwrite -- overwrite the output file if already exists
    options: (bool) True, False
    default: False
    
    -------
    Returns
    -------
    a Python dictionary of line statistics
    keys: 'peak', 'cent', 'fwhm', 'nfit'
    example: each value except for 'nfit' is a list of lists with
    a list of 2 entries [fitvalue,error] per component.
    e.g. xstat['peak']=[[234.9, 4.8],[234.2, 5.3]]
    for 2 components.
    
    -----------
    DESCRIPTION
    -----------
    Task sdfit is a basic line-fitter for single-dish spectra.
    It assumes that the spectra have been calibrated in tsdcal
    or sdreduce.
    
    Note that multiple scans, IFs, and polarizations can in principle
    be handled, but we recommend that you use scan, field, spw, and pol
    to give a single selection for each fit.
    
    -------
    POLARIZATION AVERAGE
    -------
    Two modes of polarization averaging are available. The default is
    'stokes' which is an average based on a formulation of Stokes
    parameter. In this mode, averaged data is calculated by
    (XX + YY) / 2 or (RR + LL) / 2. Other option is 'geometric', which
    is a conventional way of averaging in the field of single-dish
    data reduction. The averaged data is given by weighted average
    of XX and YY, or RR and LL.
    
    -------
    FITMODE
    -------
    As described in the parameter description section, sdfit implements
    fitting modes 'list' and 'auto' so far.
    The 'list' mode allows users to set  initial guess manually. The only
    controllable parameter for the guess is  range of the line region and
    number of lines per region. In 'list' mode, users must give line
    region via spw parameter by using ms selection syntax while number of
    lines per region can be specified via nfit parameter. For example,
    
    spw = '17:1500~2500'
    nfit = [1]
    
    will set line region between channels 1500 and 2500 for spw 17, and
    indicate that there is only one line in this region. Specifying single
    region with multiple line is also possible but is not recommended.
    In 'auto' mode, the line finder detects channel ranges of spectral lines
    based on median absolute deviation (MAD) of the spectra using user defined
    criteria, thres, avg_limit, minwidth, and edge. The number of channels
    in both edges of spectra defined by edge parameter are ignored in line
    detection. The median of lower 80% of MAD values in a spectrum is
    multiplied by thres parameter value to define a threshold of line
    detection. All channels with MAD above the threshold is detected as
    spectral line candidates and accepted as spectral lines only if the
    channel width of the line exceeds the value of minwidth parameter. The
    line detection is iteratively invoked for channel averaged spectra
    up to avg_limit.
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """Fit a spectral line"""

    __schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'datacolumn': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'timerange': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'pol': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'timebin': {'type': 'cStr'}, 'timespan': {'type': 'cStr'}, 'polaverage': {'type': 'cStr'}, 'fitfunc': {'type': 'cStr'}, 'fitmode': {'type': 'cStr'}, 'nfit': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'thresh': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'avg_limit': {'type': 'cInt'}, 'minwidth': {'type': 'cInt'}, 'edge': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __polaverage_dflt( self, glb ):
        return ''

    def __polaverage( self, glb ):
        if 'polaverage' in glb: return glb['polaverage']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __datacolumn_dflt( self, glb ):
        return 'data'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'data'

    def __fitmode_dflt( self, glb ):
        return 'list'

    def __fitmode( self, glb ):
        if 'fitmode' in glb: return glb['fitmode']
        return 'list'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __pol_dflt( self, glb ):
        return ''

    def __pol( self, glb ):
        if 'pol' in glb: return glb['pol']
        return ''

    def __timebin_dflt( self, glb ):
        return ''

    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __infile_dflt( self, glb ):
        return ''

    def __infile( self, glb ):
        if 'infile' in glb: return glb['infile']
        return ''

    def __fitfunc_dflt( self, glb ):
        return 'gaussian'

    def __fitfunc( self, glb ):
        if 'fitfunc' in glb: return glb['fitfunc']
        return 'gaussian'

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __thresh_dflt( self, glb ):
        if self.__fitmode( glb ) == "auto": return float(5.0)
        return None
    def __nfit_dflt( self, glb ):
        if self.__fitmode( glb ) == "list": return [int(0)]
        if self.__fitmode( glb ) == "interact": return [int(0)]
        return None
    def __minwidth_dflt( self, glb ):
        if self.__fitmode( glb ) == "auto": return int(4)
        return None
    def __avg_limit_dflt( self, glb ):
        if self.__fitmode( glb ) == "auto": return int(4)
        return None
    def __timespan_dflt( self, glb ):
        if self.__timebin( glb ) != "": return ""
        return None
    def __edge_dflt( self, glb ):
        if self.__fitmode( glb ) == "auto": return [int(0)]
        return None

    #--------- return subparam values -------------------------------------------------
    def __timespan( self, glb ):
        if 'timespan' in glb: return glb['timespan']
        dflt = self.__timespan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __nfit( self, glb ):
        if 'nfit' in glb: return glb['nfit']
        dflt = self.__nfit_dflt( glb )
        if dflt is not None: return dflt
        return [ int(0) ]
    def __thresh( self, glb ):
        if 'thresh' in glb: return glb['thresh']
        dflt = self.__thresh_dflt( glb )
        if dflt is not None: return dflt
        return float(5.0)
    def __avg_limit( self, glb ):
        if 'avg_limit' in glb: return glb['avg_limit']
        dflt = self.__avg_limit_dflt( glb )
        if dflt is not None: return dflt
        return int(4)
    def __minwidth( self, glb ):
        if 'minwidth' in glb: return glb['minwidth']
        dflt = self.__minwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(4)
    def __edge( self, glb ):
        if 'edge' in glb: return glb['edge']
        dflt = self.__edge_dflt( glb )
        if dflt is not None: return dflt
        return [ int(0),int(0) ]

    #--------- subparam inp output ----------------------------------------------------
    def __infile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__infile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'infile': value},{'infile': self.__schema['infile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('infile',pre,self.__to_string_(value),post,description))
    def __datacolumn_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('datacolumn',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __timerange_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('timerange',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __pol_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__pol( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'pol': value},{'pol': self.__schema['pol']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('pol',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__intent( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __timebin_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__timebin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timebin',pre,self.__to_string_(value),post,description))
    def __timespan_inp(self):
        out = self.__stdout or sys.stdout
        if self.__timespan_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__timespan( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'timespan': value},{'timespan': self.__schema['timespan']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('timespan',pre,self.__to_string_(value),post,description))
    def __polaverage_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__polaverage( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'polaverage': value},{'polaverage': self.__schema['polaverage']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('polaverage',pre,self.__to_string_(value),post,description))
    def __fitfunc_inp(self):
        out = self.__stdout or sys.stdout
        description = 'function for fitting ["gaussian", "lorentzian"]'
        value = self.__fitfunc( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'fitfunc': value},{'fitfunc': self.__schema['fitfunc']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('fitfunc',pre,self.__to_string_(value),post,description))
    def __fitmode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'mode for setting additional channel masks. "list" and "auto" are available now.'
        value = self.__fitmode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'fitmode': value},{'fitmode': self.__schema['fitmode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('fitmode',pre,self.__to_string_(value),post,description))
    def __nfit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__nfit_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__nfit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'nfit': value},{'nfit': self.__schema['nfit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('nfit',pre,self.__to_string_(value),post,description))
    def __thresh_inp(self):
        out = self.__stdout or sys.stdout
        if self.__thresh_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__thresh( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'thresh': value},{'thresh': self.__schema['thresh']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('thresh',pre,self.__to_string_(value),post,description))
    def __avg_limit_inp(self):
        out = self.__stdout or sys.stdout
        if self.__avg_limit_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__avg_limit( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'avg_limit': value},{'avg_limit': self.__schema['avg_limit']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('avg_limit',pre,self.__to_string_(value),post,description))
    def __minwidth_inp(self):
        out = self.__stdout or sys.stdout
        if self.__minwidth_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__minwidth( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'minwidth': value},{'minwidth': self.__schema['minwidth']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('minwidth',pre,self.__to_string_(value),post,description))
    def __edge_inp(self):
        out = self.__stdout or sys.stdout
        if self.__edge_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__edge( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'edge': value},{'edge': self.__schema['edge']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('edge',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'infile' in glb: del glb['infile']
        if 'outfile' in glb: del glb['outfile']
        if 'polaverage' in glb: del glb['polaverage']
        if 'field' in glb: del glb['field']
        if 'thresh' in glb: del glb['thresh']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'intent' in glb: del glb['intent']
        if 'nfit' in glb: del glb['nfit']
        if 'minwidth' in glb: del glb['minwidth']
        if 'scan' in glb: del glb['scan']
        if 'timebin' in glb: del glb['timebin']
        if 'avg_limit' in glb: del glb['avg_limit']
        if 'timespan' in glb: del glb['timespan']
        if 'fitmode' in glb: del glb['fitmode']
        if 'edge' in glb: del glb['edge']
        if 'overwrite' in glb: del glb['overwrite']
        if 'pol' in glb: del glb['pol']
        if 'fitfunc' in glb: del glb['fitfunc']
        if 'spw' in glb: del glb['spw']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__infile_inp( )
        self.__datacolumn_inp( )
        self.__antenna_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__timerange_inp( )
        self.__scan_inp( )
        self.__pol_inp( )
        self.__intent_inp( )
        self.__timebin_inp( )
        self.__timespan_inp( )
        self.__polaverage_inp( )
        self.__fitfunc_inp( )
        self.__fitmode_inp( )
        self.__nfit_inp( )
        self.__thresh_inp( )
        self.__avg_limit_inp( )
        self.__minwidth_inp( )
        self.__edge_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("sdfit.last"):
                filename = "sdfit.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, infile=None, datacolumn=None, antenna=None, field=None, spw=None, timerange=None, scan=None, pol=None, intent=None, timebin=None, timespan=None, polaverage=None, fitfunc=None, fitmode=None, nfit=None, thresh=None, avg_limit=None, minwidth=None, edge=None, outfile=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdfit.pre')
        _postfile = os.path.realpath('sdfit.last')
        _return_result_ = None
        _arguments = [infile,datacolumn,antenna,field,spw,timerange,scan,pol,intent,timebin,timespan,polaverage,fitfunc,fitmode,nfit,thresh,avg_limit,minwidth,edge,outfile,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infile is not None: local_global['infile'] = infile
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if antenna is not None: local_global['antenna'] = antenna
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if timerange is not None: local_global['timerange'] = timerange
            if scan is not None: local_global['scan'] = scan
            if pol is not None: local_global['pol'] = pol
            if intent is not None: local_global['intent'] = intent
            if timebin is not None: local_global['timebin'] = timebin
            if polaverage is not None: local_global['polaverage'] = polaverage
            if fitfunc is not None: local_global['fitfunc'] = fitfunc
            if fitmode is not None: local_global['fitmode'] = fitmode
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infile'] = self.__infile( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['pol'] = self.__pol( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['timebin'] = self.__timebin( local_global )
            _invocation_parameters['polaverage'] = self.__polaverage( local_global )
            _invocation_parameters['fitfunc'] = self.__fitfunc( local_global )
            _invocation_parameters['fitmode'] = self.__fitmode( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timespan'] = self.__timespan( _invocation_parameters ) if timespan is None else timespan
            _invocation_parameters['nfit'] = self.__nfit( _invocation_parameters ) if nfit is None else nfit
            _invocation_parameters['thresh'] = self.__thresh( _invocation_parameters ) if thresh is None else thresh
            _invocation_parameters['avg_limit'] = self.__avg_limit( _invocation_parameters ) if avg_limit is None else avg_limit
            _invocation_parameters['minwidth'] = self.__minwidth( _invocation_parameters ) if minwidth is None else minwidth
            _invocation_parameters['edge'] = self.__edge( _invocation_parameters ) if edge is None else edge

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['pol'] = self.__pol( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['timespan'] = self.__timespan( self.__globals_( ) )
            _invocation_parameters['polaverage'] = self.__polaverage( self.__globals_( ) )
            _invocation_parameters['fitfunc'] = self.__fitfunc( self.__globals_( ) )
            _invocation_parameters['fitmode'] = self.__fitmode( self.__globals_( ) )
            _invocation_parameters['nfit'] = self.__nfit( self.__globals_( ) )
            _invocation_parameters['thresh'] = self.__thresh( self.__globals_( ) )
            _invocation_parameters['avg_limit'] = self.__avg_limit( self.__globals_( ) )
            _invocation_parameters['minwidth'] = self.__minwidth( self.__globals_( ) )
            _invocation_parameters['edge'] = self.__edge( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdfit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _sdfit_t( _invocation_parameters['infile'],_invocation_parameters['datacolumn'],_invocation_parameters['antenna'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['timerange'],_invocation_parameters['scan'],_invocation_parameters['pol'],_invocation_parameters['intent'],_invocation_parameters['timebin'],_invocation_parameters['timespan'],_invocation_parameters['polaverage'],_invocation_parameters['fitfunc'],_invocation_parameters['fitmode'],_invocation_parameters['nfit'],_invocation_parameters['thresh'],_invocation_parameters['avg_limit'],_invocation_parameters['minwidth'],_invocation_parameters['edge'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

sdfit = _sdfit( )

