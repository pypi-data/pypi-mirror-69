##################### generated by xml-casa (v2) from immath.xml ####################
##################### 2dd420932b0fa04625143efdc61c86c2 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import immath as _immath_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _immath:
    """
    immath ---- Perform math operations on images

    math on images

    --------- parameter descriptions ---------------------------------------------

    imagename  a list of input images
    mode       mode for math operation (evalexpr, spix, pola, poli, lpoli, tpoli)
    outfile    File where the output is saved
    expr       Mathematical expression using images
    varnames   a list of variable names to use with the image files
    sigma      standard deviation of noise for debiasing
    polithresh Threshold in linear polarization intensity image below which to mask pixels.
    mask       Mask to use. Default is none.
    region     Region selection. Default is to use the full image.
    box        Rectangular region to select in direction plane. Default is to use the entire direction plane.
    chans      Channels to use. Default is to use all channels.
    stokes     Stokes planes to use. Default is to use all Stokes planes.
    stretch    Stretch the mask if necessary and possible? See help stretch.par
    imagemd    An image name from which metadata should be copied. The input can be either an image listed under imagename or any other image on disk. Leaving this parameter unset may copy header metadata from any of the input images, which one is not guaranteed.
    prec       Precision for the output image pixels if mode="evalexpr" or "spix". "float" or "double" (minimum match supported)
    [1;42mRETURNS[1;m       bool

    --------- examples -----------------------------------------------------------

    
    
    This task evaluates mathematical expressions involving existing
    image files. The results of the calculations are stored in the
    designated output file.  Options are available to specify mathematical
    expression directly or pre-defined expression for calculation of
    spectral index image, and polarization intensity and position angle
    images are available. The image file names imbedded in the expression or
    specified in the imagename parameter for the pre-defined calculations may
    be CASA images or FITS images.
    
    
    NOTE: Index values start at 0 Use the imhead task to see the range of
    index values for each axes.
    
    
    Keyword arguments:
    imagename  input image name(s)
    Default: none;
    Examples: mode='evalexpr'; imagename=['image1.im', 'image2.im' ]
    The text 'IM0' is replaced by 'image1.im' in the
    expression and 'IM1' is repalced with 'image2.im'
    mode='spix'; imagename=['image1.im','image2.im'] will calculate
    an image of log(S1/S2)/log(f1/f2), where S1 and S2 are fluxes and
    f1 and f2 are frequencies
    mode='pola'; imagename='multistokes.im' (where that image contains both Q and U
    stokes planes) or imagename=['imageQ.im','imageU.im'] will calculate
    an image of polarization angle distribution, where imageQ.im and
    imageU.im are Stokes Q and U images, respectively. Calculate 0.5*arctan(U/Q).
    mode='poli'; imagename=['imageQ.im','imageU.im','imageV.im'] will calculate
    total polarization intensity image, where imageQ.im, imageU.im, imageV.im
    are Stokes Q, U, and V images, respectively. Alternatively, with
    imagename = ['imageQ.im','imageU.im'] the linear polarization intensity
    image will be calculated. In the case where imagename is a single multi-stokes
    image, the total polarization image will be calculated if all of the Q, U, and
    V stokes planes are present, and the linear polarization intensity image will
    be calculated if the Q and U (but not V) planes are present.
    
    mode       mode for mathematical operation
    Default: evalexpr
    Options: 'evalexpr' : evalulate a mathematical expression defined in 'expr'
    'spix' : spectalindex image
    'pola' : polarization position angle image
    'poli' : polarization intesity image
    >>> mode expandable parameters
    sigma       (for mode='poli') standard deviation of noise of Stokes images with unit such as
    Jy/beam to correct for bias
    Default: '0.0Jy/beam' (= no debiasing)
    polithresh  (for mode='pola') Quantity (eg '30uJy/beam') describing the linear (not total;
    the stokes V contribution is not included) polarization threshold. A mask ('mask0')
    is written to the output image and is False for all corresponding linear polarization
    values below this threshold. This parameter overrides the mask input parameter
    (below). Default ('') means use the value given in mask, or no masking if that
    value is empty as well.
    expr        (for mode='evalexpr') A LEL expression with images.
    Image file names are specified in the imagenames paramter, and
    the variables IM0, IM1, ... (or optionally via the varnames parameter, see below)
    are used to represent these files
    in the expression. Explicit notations of file names in the
    expression are also supported, in which cases the file names must
    be enclosed in double quotes (") and imagename is ignored.
    Examples:
    Make an image that is image1.im - image2.im
    expr=' (IM0 - IM1 )'
    or with an explicit notation,
    expr='("image1.im" - "image2.im")'
    Clip an image below a value (0.5 in this case)
    expr = ' iif( IM0 >=0.5, IM0, 0.0) '
    Note: iif (a, b, c)   a is the boolean expression
    b is the value if true
    c is the value if false
    Take the rms value of two images
    expr = ' sqrt(IM0 * IM0 + IM1 * IM1) '
    Build an image pixel by pixel from the minimum of (image2.im, 2*image1.im)
    expr='min(IM1,2*max(IM0))'
    varnames   For mode="evalexpr". Instead of the default variable names IM0, IM1, ..., use
    the names in this array to represent the input images.
    outfile    The output image. Overwriting an existing outfile is not permitted.
    Default: immath_results.im;  Example: outfile='results.im'
    mask       Mask to use. Default is none. Also see polithresh.
    stretch    Stretch the input mask if necessary and possible. See below.
    region     Region selection. Default is to use the full image.
    box        Rectangular region to select in direction plane. Default
    is to use the entire direction plane.
    Example: box='10,10,50,50'
    chans      Channels to use. Default is to use all channels.
    stokes     Stokes planes to use. Default is to use all Stokes planes.
    Not used in for cases of mode='poli' or mode='pola'
    imagemd    The image from which metadata should be copied to the output. Default means no guarantee from
    which image is used. The image must exist and should conform to the output image spec.
    
    Available functions in the expr and mask parameters:
    pi(), e(), sin(), sinh(), asinh(), cos(), cosh(), tan(), tanh(),
    atan(), exp(), log(), log10(), pow(), sqrt(), complex(), conj()
    real(), imag(), abs(), arg(), phase(), amplitude(), min(), max()
    round(), isgn(), floor(), ceil(), rebin(), spectralindex(), pa(),
    iif(), indexin(), replace(), ...
    
    If the mask has fewer dimensions than the image and if the shape
    of the dimensions the mask and image have in common are the same,
    the mask will automatically have the missing dimensions added so
    it conforms to the image.
    
    For a full description of the allowed syntax see the
    Lattice Expression Language (LEL) documentation on the at:
    http://aips2.nrao.edu/docs/notes/223/223.html
    
    NOTE: where indexing and axis numbering are used in the above
    functions they are 1-based, ie. numbering starts at 1.
    
    If stretch is true and if the number of mask dimensions is less than
    or equal to the number of image dimensions and some axes in the
    mask are degenerate while the corresponding axes in the image are not,
    the mask will be stetched in the degenerate axis dimensions. For example,
    if the input image has shape [100, 200, 10] and the input
    mask has shape [100, 200, 1] and stretch is true, the mask will be
    stretched along the third dimension to shape [100, 200, 10]. However if
    the mask is shape [100, 200, 2], stretching is not possible and an
    error will result.
    
    CAUTIONS REGARDING OUTPUT IMAGE METADATA, INCLUDING BRIGHTNESS UNIT
    
    EXCEPT IN THE CASES NOTED BELOW, THIS APPLICATION MAKES NO ATTEMPT TO
    DETERMINE WHAT THE CORRECT BRIGHTNESS UNIT OF THE OUTPUT IMAGE SHOULD BE. THIS
    RESPONSIBILITY LIES SOLELY WITH THE USER. The brightness unit of the output image
    can be modified using tool method ia.setbrightnessunit() or task imhead with
    mode='put' and hdkey='bunit'.
    
    Note that when multiple image are used in the expression, there is
    no garauntee about which of those images will be used to create the metadata
    of the output image, unless imagemd is specified. If imagemd is specified, the following
    rules of metadata copying will be followed:
    
    1. The pixel data type of the image specified by imagemd and the output image must
    be the same.
    2. The metadata copied include the coordinate system (and so of course the dimensionality of
    the output image must correspond to the coordinate system to be copied), the image_info record
    (which contains things like the beam(s)), the misc_info record (should one exist in the image
    specified by imagemd), and the units.
    3. If the output image is a spectral image, the brightness units are set to the empty string.
    4. If the ouptut image is a polarization angle image, the brightness unit is set to "deg" and
    the stokes coordinate is set to have a single plane of type of Pangle.
    
    Examples:
    # Double all values in an image.
    immath( imagesname='myimage.im', expr='IM0*2', outfile='double.im' )
    # or with an explicit notation,
    immath( expr='"myimage.im"*2', outfile='double.im' )
    
    # Taking the sin of an image and adding it to another
    # Note that the images need to be the same size
    immath(images=['image1.im', 'image2.im'], expr='sin(IM1)+IM0;',outfile='newImage.im')
    
    # Adding only the plane associated with the 'V' stokes value and
    # the 1st channel together in two images
    immath(imagename=[image1', 'image2'], expr='IM0+IM1',chans='1',stokes='V')
    
    
    # Selecting a single plane (5th channel), of the 3-D cube and
    # adding it to the original image.  In this example the 2-D plane
    # gets expanded out and the values are applied to each plane in the
    # 3-D cube.
    default('immath')
    imagename='ngc7538.image'
    outfile='chanFive.im'
    expr='IM0'
    chans='5'
    go
    default('immath')
    imagename=['ngc7538.image', chanFive.im']
    outfile='ngc7538_chanFive.im'
    expr='IM0+IM1'
    go
    
    # Selecting and saving the inner 3/4 of an image for channels 40,42,44
    # as well as channels less than 10
    default('immath')
    imagename='my_image.im'
    expr='IM0'
    box='25,25,123,123'
    chans='<10;40,42,44'
    outfile='my_image_inner.im' )
    go
    
    # Dividing an image by another, making sure we aren't dividing by zero
    default('immath')
    imagename=['orion.image', 'my.image']
    expr='IM0/iif(IM1==0,1.0,IM1)'
    outfile='my_orion.image'
    go
    
    # Applying a mask to all of the images in the expression
    default('immath')
    imagename=['ngc7538.image','ngc7538_clean.image']
    expr='(IM0*10)+IM1'
    mask='"ngc7538.mask"'
    outfile='really_noisy_ngc7538.image'
    go
    
    
    # Applying a pixel mask contained in the image information
    default('immath')
    imagename='ngc5921.image'
    expr='IM0*10'
    mask='mask("ngc5921.mask")'
    outfile='ngc5921.masked.image'
    go
    
    # Creating a total polarization intensity image from an multi-stokes image
    # containing IQUV.
    default('immath')
    outfile='pol_intensity'
    stokes=''
    # in imagename, you can also specify a list containing single stokes images
    # of Q and U (for linear polarization intensity) and V (for total
    # polarization intensity)
    imagename='3C138_pcal'
    mode='poli'
    go
    
    # Creating a polarization position angle image
    default('immath')
    outfile='pol_angle.im'
    mode='pola'
    # you can also do imagename=['Q.im','U.im'] for single stokes images, order of
    # the two Stokes images does not matter
    imagename='3C138_pcal' # multi-stokes image containing at least Q and U stokes
    go
    
    # same as before but write a mask with values of False for pixels for which the
    # corresponding linear polarization ( sqrt(Q*Q+U*U)) is less than 30 microJy/beam
    polithresh='30uJy/beam'
    go
    
    # Creating a spectral index image from the images at two different observing frequencies
    default('immath')
    outfile='mySource_sp.im'
    mode='spix'
    imagename=['mySource_5GHz.im','mySource_8GHz.im']
    go
    
    TEMPORARY IMAGES
    
    At this time, it is usually necessary for this task to create intermediate, temporary disk images.
    The names of these images start with '_immath' and are created in the directory in which the task
    is run. The task makes reasonable attempts to remove these images before it exits, but there are
    conceivably instances where the temporary images may not be automatically deleted. It is generally
    safe to delete them by hand, assuming no immath instance is currently in progress.
    
    The hope and plan is that the necessity of these images will decrease in the future (i.e. the computations
    will require only RAM and not temporary persistent storage of intermediate results).
    
    


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Perform math operations on images"""

    __schema = {'imagename': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'mode': {'type': 'cStr'}, 'outfile': {'type': 'cStr'}, 'expr': {'type': 'cStr'}, 'varnames': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'sigma': {'type': 'cStr'}, 'polithresh': {'type': 'cStr'}, 'mask': {'type': 'cStr'}, 'region': {'type': 'cStr'}, 'box': {'type': 'cStr'}, 'chans': {'type': 'cStr'}, 'stokes': {'type': 'cStr'}, 'stretch': {'type': 'cBool'}, 'imagemd': {'type': 'cStr'}, 'prec': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __prec_dflt( self, glb ):
        return 'float'

    def __prec( self, glb ):
        if 'prec' in glb: return glb['prec']
        return 'float'

    def __mode_dflt( self, glb ):
        return 'evalexpr'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'evalexpr'

    def __imagemd_dflt( self, glb ):
        return ''

    def __imagemd( self, glb ):
        if 'imagemd' in glb: return glb['imagemd']
        return ''

    def __mask_dflt( self, glb ):
        return ''

    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __region_dflt( self, glb ):
        return ''

    def __region( self, glb ):
        if 'region' in glb: return glb['region']
        return ''

    def __outfile_dflt( self, glb ):
        return 'immath_results.im'

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return 'immath_results.im'

    def __chans_dflt( self, glb ):
        return ''

    def __chans( self, glb ):
        if 'chans' in glb: return glb['chans']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __box_dflt( self, glb ):
        return ''

    def __box( self, glb ):
        if 'box' in glb: return glb['box']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __varnames_dflt( self, glb ):
        if self.__mode( glb ) == "evalexpr": return ""
        return None
    def __stretch_dflt( self, glb ):
        if self.__mask( glb ) != "": return bool(False)
        return None
    def __expr_dflt( self, glb ):
        if self.__mode( glb ) == "evalexpr": return ""
        return None
    def __sigma_dflt( self, glb ):
        if self.__mode( glb ) == "poli": return "0.0mJy/beam"
        if self.__mode( glb ) == "lpoli": return "0.0mJy/beam"
        if self.__mode( glb ) == "tpoli": return "0.0mJy/beam"
        return None
    def __polithresh_dflt( self, glb ):
        if self.__mode( glb ) == "pola": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __expr( self, glb ):
        if 'expr' in glb: return glb['expr']
        dflt = self.__expr_dflt( glb )
        if dflt is not None: return dflt
        return 'IM0'
    def __varnames( self, glb ):
        if 'varnames' in glb: return glb['varnames']
        dflt = self.__varnames_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __sigma( self, glb ):
        if 'sigma' in glb: return glb['sigma']
        dflt = self.__sigma_dflt( glb )
        if dflt is not None: return dflt
        return '0.0mJy/beam'
    def __polithresh( self, glb ):
        if 'polithresh' in glb: return glb['polithresh']
        dflt = self.__polithresh_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __stretch( self, glb ):
        if 'stretch' in glb: return glb['stretch']
        dflt = self.__stretch_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __expr_inp(self):
        out = self.__stdout or sys.stdout
        if self.__expr_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__expr( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'expr': value},{'expr': self.__schema['expr']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('expr',pre,self.__to_string_(value),post,description))
    def __varnames_inp(self):
        out = self.__stdout or sys.stdout
        if self.__varnames_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__varnames( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'varnames': value},{'varnames': self.__schema['varnames']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('varnames',pre,self.__to_string_(value),post,description))
    def __sigma_inp(self):
        out = self.__stdout or sys.stdout
        if self.__sigma_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__sigma( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'sigma': value},{'sigma': self.__schema['sigma']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('sigma',pre,self.__to_string_(value),post,description))
    def __polithresh_inp(self):
        out = self.__stdout or sys.stdout
        if self.__polithresh_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__polithresh( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'polithresh': value},{'polithresh': self.__schema['polithresh']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('polithresh',pre,self.__to_string_(value),post,description))
    def __mask_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mask( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mask',pre,self.__to_string_(value),post,description))
    def __region_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__region( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'region': value},{'region': self.__schema['region']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('region',pre,self.__to_string_(value),post,description))
    def __box_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__box( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'box': value},{'box': self.__schema['box']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('box',pre,self.__to_string_(value),post,description))
    def __chans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chans': value},{'chans': self.__schema['chans']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('chans',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __stretch_inp(self):
        out = self.__stdout or sys.stdout
        if self.__stretch_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__stretch( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'stretch': value},{'stretch': self.__schema['stretch']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('stretch',pre,self.__to_string_(value),post,description))
    def __imagemd_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagemd( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagemd': value},{'imagemd': self.__schema['imagemd']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('imagemd',pre,self.__to_string_(value),post,description))
    def __prec_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__prec( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'prec': value},{'prec': self.__schema['prec']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('prec',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'varnames' in glb: del glb['varnames']
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'mask' in glb: del glb['mask']
        if 'imagemd' in glb: del glb['imagemd']
        if 'stretch' in glb: del glb['stretch']
        if 'imagename' in glb: del glb['imagename']
        if 'prec' in glb: del glb['prec']
        if 'expr' in glb: del glb['expr']
        if 'sigma' in glb: del glb['sigma']
        if 'chans' in glb: del glb['chans']
        if 'region' in glb: del glb['region']
        if 'mode' in glb: del glb['mode']
        if 'box' in glb: del glb['box']
        if 'polithresh' in glb: del glb['polithresh']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__mode_inp( )
        self.__outfile_inp( )
        self.__expr_inp( )
        self.__varnames_inp( )
        self.__sigma_inp( )
        self.__polithresh_inp( )
        self.__mask_inp( )
        self.__region_inp( )
        self.__box_inp( )
        self.__chans_inp( )
        self.__stokes_inp( )
        self.__stretch_inp( )
        self.__imagemd_inp( )
        self.__prec_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("immath.last"):
                filename = "immath.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, mode=None, outfile=None, expr=None, varnames=None, sigma=None, polithresh=None, mask=None, region=None, box=None, chans=None, stokes=None, stretch=None, imagemd=None, prec=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('immath.pre')
        _postfile = os.path.realpath('immath.last')
        _return_result_ = None
        _arguments = [imagename,mode,outfile,expr,varnames,sigma,polithresh,mask,region,box,chans,stokes,stretch,imagemd,prec]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if mode is not None: local_global['mode'] = mode
            if outfile is not None: local_global['outfile'] = outfile
            if mask is not None: local_global['mask'] = mask
            if region is not None: local_global['region'] = region
            if box is not None: local_global['box'] = box
            if chans is not None: local_global['chans'] = chans
            if stokes is not None: local_global['stokes'] = stokes
            if imagemd is not None: local_global['imagemd'] = imagemd
            if prec is not None: local_global['prec'] = prec

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['mask'] = self.__mask( local_global )
            _invocation_parameters['region'] = self.__region( local_global )
            _invocation_parameters['box'] = self.__box( local_global )
            _invocation_parameters['chans'] = self.__chans( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['imagemd'] = self.__imagemd( local_global )
            _invocation_parameters['prec'] = self.__prec( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['expr'] = self.__expr( _invocation_parameters ) if expr is None else expr
            _invocation_parameters['varnames'] = self.__varnames( _invocation_parameters ) if varnames is None else varnames
            _invocation_parameters['sigma'] = self.__sigma( _invocation_parameters ) if sigma is None else sigma
            _invocation_parameters['polithresh'] = self.__polithresh( _invocation_parameters ) if polithresh is None else polithresh
            _invocation_parameters['stretch'] = self.__stretch( _invocation_parameters ) if stretch is None else stretch

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['expr'] = self.__expr( self.__globals_( ) )
            _invocation_parameters['varnames'] = self.__varnames( self.__globals_( ) )
            _invocation_parameters['sigma'] = self.__sigma( self.__globals_( ) )
            _invocation_parameters['polithresh'] = self.__polithresh( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['region'] = self.__region( self.__globals_( ) )
            _invocation_parameters['box'] = self.__box( self.__globals_( ) )
            _invocation_parameters['chans'] = self.__chans( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['stretch'] = self.__stretch( self.__globals_( ) )
            _invocation_parameters['imagemd'] = self.__imagemd( self.__globals_( ) )
            _invocation_parameters['prec'] = self.__prec( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#immath( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _immath_t( _invocation_parameters['imagename'],_invocation_parameters['mode'],_invocation_parameters['outfile'],_invocation_parameters['expr'],_invocation_parameters['varnames'],_invocation_parameters['sigma'],_invocation_parameters['polithresh'],_invocation_parameters['mask'],_invocation_parameters['region'],_invocation_parameters['box'],_invocation_parameters['chans'],_invocation_parameters['stokes'],_invocation_parameters['stretch'],_invocation_parameters['imagemd'],_invocation_parameters['prec'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

immath = _immath( )

