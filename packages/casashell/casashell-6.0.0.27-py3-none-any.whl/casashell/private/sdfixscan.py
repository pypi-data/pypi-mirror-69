##################### generated by xml-casa (v2) from sdfixscan.xml #################
##################### 02fe5170b3d6cbde77ba90b2c7b67f09 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import sdfixscan as _sdfixscan_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdfixscan:
    """
    sdfixscan ---- Task for single-dish image processing

    
    Task sdfixscan is used to remove a scanning noise that appears
    as a striped noise pattern along the scan direction in a raster
    scan data.
    
    By default, the scanning noise is removed by using the
    FFT-based 'Basket-Weaving' method (Emerson & Grave 1988) that
    requires multiple images that observed exactly the same area with
    different scanning direction. If only one image is available, the
    'Pressed-out' method (Sofue & Reich 1979) can be used to remove
    the scanning effect.
    

    --------- parameter descriptions ---------------------------------------------

    infiles    list of name of input SD images (FITS or CASA image)
    mode       image processing mode
    numpoly    order of polynomial fit for Pressed-out method
    beamsize   beam size for Pressed-out method
    smoothsize size of smoothing beam for Pressed-out method
    direction  scan direction (p.a.) counterclockwise from the horizontal axis in unit of degree
    maskwidth  mask width for Basket-Weaving (on percentage)
    tmax       maximum threshold value for processing
    tmin       minimum threshold value for processing
    outfile    name of output file
    overwrite  overwrite the output file if already exists
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    -----------------
    Keyword arguments
    -----------------
    infiles -- name or list of names of input SD (FITS or CASA) image(s)
    mode -- image processing mode
    options: 'fft_mask' (FFT-based Basket-Weaving),
    'model' (Pressed-out method)
    default: 'fft_mask'
    >>>mode expandable parameter
    direction -- scan direction (p.a.) counterclockwise from the
    horizontal axis in unit of degree.
    default: []
    example: direction=[0.0, 90.0] means that the first image
    has scan direction along longitude axis while the
    second image is along latitude axis.
    maskwidth -- mask width for Basket-Weaving on percentage
    default: 1.0 (1.0% of map size)
    numpoly -- order of polynomial fit in Presssed-out method
    default: 2
    beamsize -- beam size for Pressed-out method
    default: 0.0
    example: beamsize=10.0 is interpreted as '10arcsec'.
    beamsize='1arcmin' specifies beam size as
    quantity.
    smoothsize -- smoothing beam size in Pressed-out method.
    if numeric value is given, it is interpreted in unit
    of beam size specified by the parameter beamsize
    default: 2.0
    example: smoothsize=2.0 means that smoothing beam size is
    2.0 * beamsize.
    smoothsize='1arcmin' sets smoothsize directly.
    tmax -- maximum threshold value for processing
    default: 0.0 (no threshold in maximum)
    example: 10.0 (mask data larger value than 10.0)
    tmin -- minimum threshold value for processing
    default: 0.0 (no threshold in minimum)
    example: -10.0 (mask data smaller value than -10.0)
    outfile -- name of output file. output file is in CASA image format.
    default: '' (use default name 'sdfixscan.out.im')
    example: 'output.im'
    overwrite -- overwrite the output file if already exists
    options: (bool) True, False
    default: False
    
    -----------
    DESCRIPTION
    -----------
    Task sdfixscan is used to remove a scanning noise that appears
    as a striped noise pattern along the scan direction in a raster
    scan data.
    
    By default, the scanning noise is removed by using the FFT-based
    'Basket-Weaving' method (Emerson & Grave 1988) that requires
    multiple images that observed exactly the same area with different
    scanning direction. If only one image is available, the 'Pressed-out'
    method (Sofue & Reich 1979) can be used to remove the scanning
    effect.
    
    For 'Basket-Weaving', scanning directions must have at least two
    different values. Normally, the scanning direction should be
    specified for each input image. Otherwise, specified scanning
    directions will be used iteratively. The maskwidth is a width of
    masking region in the Fourier plane. It is specified as a fraction
    (percentage) of the image size.
    
    For 'Pressed-out', the scanning direction must be unique. There are
    two ways to specify a size of smoothing beam used for process. One
    is to specify smoothing size directly. To do this, smoothsize should
    be specified as string that consists of a numerical value and an unit
    (e.g. '10.0arcsec'). A value of beamsize will be ignored in this case.
    Another way to specify smoothing size is to set an observed beam size
    and indicate smoothing size as a scale factor of the observed beam
    size. In this case, the beamsize is interpreted as the observed beam
    size, and the smoothsize is the scale factor. If the beamsize is
    provided as float value, its unit is assumed to 'arcsec'. It is also
    possible to set the beamsize as string consisting of the numerical
    value and the unit. The smoothsize must be float value.
    
    The infiles only allows an image data (CASA or FITS), and does not
    work with MS or Scantable. The direction is an angle with respect to
    the horizontal direction, and its unit is degree. Any value may be
    interpreted properly, but the value ranging from 0.0 to 180.0 will
    be secure. The tmax and the tmin is used to specify a threshold that
    defines a range of spectral values used for processing. The data point
    that has the value larger than tmax or smaller than tmin will be
    excluded from the processing. The default (0.0) is no threshold.
    The outfile specifies an output CASA image name. If the outfile is
    empty, the default name ('sdfixscan.out.im') will be used.
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """Task for single-dish image processing"""

    __schema = {'infiles': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'mode': {'type': 'cStr'}, 'numpoly': {'type': 'cInt'}, 'beamsize': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'smoothsize': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'direction': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'maskwidth': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'tmax': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'tmin': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __tmax_dflt( self, glb ):
        return float(0.0)

    def __tmax( self, glb ):
        if 'tmax' in glb: return glb['tmax']
        return float(0.0)

    def __tmin_dflt( self, glb ):
        return float(0.0)

    def __tmin( self, glb ):
        if 'tmin' in glb: return glb['tmin']
        return float(0.0)

    def __infiles_dflt( self, glb ):
        return [  ]

    def __infiles( self, glb ):
        if 'infiles' in glb: return glb['infiles']
        return [  ]

    def __mode_dflt( self, glb ):
        return 'fft_mask'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'fft_mask'

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __direction_dflt( self, glb ):
        if self.__mode( glb ) == "fft_mask": return []
        if self.__mode( glb ) == "model": return 0.0
        return None
    def __maskwidth_dflt( self, glb ):
        if self.__mode( glb ) == "fft_mask": return 1.0
        return None
    def __smoothsize_dflt( self, glb ):
        if self.__mode( glb ) == "model": return 2.0
        return None
    def __beamsize_dflt( self, glb ):
        if self.__mode( glb ) == "model": return float(0.0)
        return None
    def __numpoly_dflt( self, glb ):
        if self.__mode( glb ) == "model": return int(2)
        return None

    #--------- return subparam values -------------------------------------------------
    def __numpoly( self, glb ):
        if 'numpoly' in glb: return glb['numpoly']
        dflt = self.__numpoly_dflt( glb )
        if dflt is not None: return dflt
        return int(2)
    def __beamsize( self, glb ):
        if 'beamsize' in glb: return glb['beamsize']
        dflt = self.__beamsize_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __smoothsize( self, glb ):
        if 'smoothsize' in glb: return glb['smoothsize']
        dflt = self.__smoothsize_dflt( glb )
        if dflt is not None: return dflt
        return float(2.0)
    def __direction( self, glb ):
        if 'direction' in glb: return glb['direction']
        dflt = self.__direction_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __maskwidth( self, glb ):
        if 'maskwidth' in glb: return glb['maskwidth']
        dflt = self.__maskwidth_dflt( glb )
        if dflt is not None: return dflt
        return float(1.0)

    #--------- subparam inp output ----------------------------------------------------
    def __infiles_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__infiles( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'infiles': value},{'infiles': self.__schema['infiles']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('infiles',pre,self.__to_string_(value),post,description))
    def __mode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'image processing mode ["fft_mask", "model"]'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mode',pre,self.__to_string_(value),post,description))
    def __numpoly_inp(self):
        out = self.__stdout or sys.stdout
        if self.__numpoly_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__numpoly( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'numpoly': value},{'numpoly': self.__schema['numpoly']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('numpoly',pre,self.__to_string_(value),post,description))
    def __beamsize_inp(self):
        out = self.__stdout or sys.stdout
        if self.__beamsize_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__beamsize( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'beamsize': value},{'beamsize': self.__schema['beamsize']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('beamsize',pre,self.__to_string_(value),post,description))
    def __smoothsize_inp(self):
        out = self.__stdout or sys.stdout
        if self.__smoothsize_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__smoothsize( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'smoothsize': value},{'smoothsize': self.__schema['smoothsize']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('smoothsize',pre,self.__to_string_(value),post,description))
    def __direction_inp(self):
        out = self.__stdout or sys.stdout
        if self.__direction_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__direction( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'direction': value},{'direction': self.__schema['direction']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('direction',pre,self.__to_string_(value),post,description))
    def __maskwidth_inp(self):
        out = self.__stdout or sys.stdout
        if self.__maskwidth_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__maskwidth( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'maskwidth': value},{'maskwidth': self.__schema['maskwidth']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('maskwidth',pre,self.__to_string_(value),post,description))
    def __tmax_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__tmax( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'tmax': value},{'tmax': self.__schema['tmax']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('tmax',pre,self.__to_string_(value),post,description))
    def __tmin_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__tmin( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'tmin': value},{'tmin': self.__schema['tmin']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('tmin',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'outfile' in glb: del glb['outfile']
        if 'tmax' in glb: del glb['tmax']
        if 'direction' in glb: del glb['direction']
        if 'maskwidth' in glb: del glb['maskwidth']
        if 'smoothsize' in glb: del glb['smoothsize']
        if 'beamsize' in glb: del glb['beamsize']
        if 'mode' in glb: del glb['mode']
        if 'numpoly' in glb: del glb['numpoly']
        if 'overwrite' in glb: del glb['overwrite']
        if 'infiles' in glb: del glb['infiles']
        if 'tmin' in glb: del glb['tmin']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__infiles_inp( )
        self.__mode_inp( )
        self.__numpoly_inp( )
        self.__beamsize_inp( )
        self.__smoothsize_inp( )
        self.__direction_inp( )
        self.__maskwidth_inp( )
        self.__tmax_inp( )
        self.__tmin_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("sdfixscan.last"):
                filename = "sdfixscan.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, infiles=None, mode=None, numpoly=None, beamsize=None, smoothsize=None, direction=None, maskwidth=None, tmax=None, tmin=None, outfile=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdfixscan.pre')
        _postfile = os.path.realpath('sdfixscan.last')
        _return_result_ = None
        _arguments = [infiles,mode,numpoly,beamsize,smoothsize,direction,maskwidth,tmax,tmin,outfile,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infiles is not None: local_global['infiles'] = infiles
            if mode is not None: local_global['mode'] = mode
            if tmax is not None: local_global['tmax'] = tmax
            if tmin is not None: local_global['tmin'] = tmin
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infiles'] = self.__infiles( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['tmax'] = self.__tmax( local_global )
            _invocation_parameters['tmin'] = self.__tmin( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['numpoly'] = self.__numpoly( _invocation_parameters ) if numpoly is None else numpoly
            _invocation_parameters['beamsize'] = self.__beamsize( _invocation_parameters ) if beamsize is None else beamsize
            _invocation_parameters['smoothsize'] = self.__smoothsize( _invocation_parameters ) if smoothsize is None else smoothsize
            _invocation_parameters['direction'] = self.__direction( _invocation_parameters ) if direction is None else direction
            _invocation_parameters['maskwidth'] = self.__maskwidth( _invocation_parameters ) if maskwidth is None else maskwidth

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['numpoly'] = self.__numpoly( self.__globals_( ) )
            _invocation_parameters['beamsize'] = self.__beamsize( self.__globals_( ) )
            _invocation_parameters['smoothsize'] = self.__smoothsize( self.__globals_( ) )
            _invocation_parameters['direction'] = self.__direction( self.__globals_( ) )
            _invocation_parameters['maskwidth'] = self.__maskwidth( self.__globals_( ) )
            _invocation_parameters['tmax'] = self.__tmax( self.__globals_( ) )
            _invocation_parameters['tmin'] = self.__tmin( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdfixscan( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _sdfixscan_t( _invocation_parameters['infiles'],_invocation_parameters['mode'],_invocation_parameters['numpoly'],_invocation_parameters['beamsize'],_invocation_parameters['smoothsize'],_invocation_parameters['direction'],_invocation_parameters['maskwidth'],_invocation_parameters['tmax'],_invocation_parameters['tmin'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

sdfixscan = _sdfixscan( )

