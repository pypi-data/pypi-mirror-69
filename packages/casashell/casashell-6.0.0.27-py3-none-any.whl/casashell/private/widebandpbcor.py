##################### generated by xml-casa (v2) from widebandpbcor.xml #############
##################### 56faf64d36bc394b34f3d061962c207a ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import widebandpbcor as _widebandpbcor_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _widebandpbcor:
    """
    widebandpbcor ---- Wideband PB-correction on the output of the MS-MFS algorithm

    WideBand Primary-beam correction. It computes a set of PBs at the specified frequencies, calculates Taylor-coefficient images that represent the PB spectrum, performs a polynomial division to PB-correct the output Taylor-coefficient images from clean(nterms>1), and recompute spectral index (and curvature) using the PB-corrected Taylor-coefficient images

    --------- parameter descriptions ---------------------------------------------

    vis        Name of measurement set.
    imagename  Name-prefix of multi-termimages to operate on.
    nterms     Number of taylor terms to use
    threshold  Intensity above which to re-calculate spectral index
    action     PB-correction (pbcor) or only calc spectral-index (calcalpha)
    reffreq    Reference frequency (if specified in clean)
    pbmin      PB threshold below which to not correct
    field      Fields to include in the PB calculation
    spwlist    List of N spw ids
    chanlist   List of N channel ids
    weightlist List of N weights (relative)
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    
    Wide-band Primary-beam correction
    
    (1) Compute a set of Primary Beams at the specified frequencies
    (2) Calculate Taylor-coefficient images that represent the PB spectrum
    (3) Perform a polynomial division to PB-correct the output Taylor-coefficient
    images from the MS-MFS algorithm ( clean(nterms>1) )
    (4) Recompute spectral index (and curvature) using the corrected Taylor-coefficient images.
    
    [ Optionally, skip PB-correction, and only recalculate spectral index
    with a different threshold ]
    
    This is a temporary task, meant for use until a widebandpbcor option is enabled from
    within the tclean task.
    
    An output directory named imagename.pbcor.workdirectory is created, and filled with
    an image-cube of the evaluated primary beams at all specified frequencies,
    Taylor-coefficients, and a 'spectral index' due to the primary beam.
    Note that for the actual pb-correction, only the Taylor-coefficient images are used.
    
    Task parameters :
    
    vis -- Name of input visibility file
    example : vis = 'ngc5921.ms'
    Only one MS can be specified here, and it must contain at-least one
    timestep of data at all frequencies required to calculate the PB spectrum.
    
    Note : If the imaging was done using a list of MSs, and any one MS covers
    the entire frequency range, then it will suffice to supply only that one
    MS.  This MS is used only to extract frequencies at which to compute
    primary beams before fitting Taylor polynomials.
    
    Note : In case of multiple MSs that cover different frequency ranges,
    please split/concat a small fraction of the data from each MS to form
    one single MS that contains the full frequency range. This task uses
    the MS only for frequency meta-data.
    
    imagename -- Pre-name of input and output images. Same as in the clean task.
    example : imagename = 'run1'
    Restored-images ( run1.image.tt0,etc) and residual images ( run1.residual.tt0, etc.. )
    must be available on disk.
    
    nterms -- Number of Taylor terms to be used to model the frequency-dependence
    of the primary beam.
    example : nterms = 2
    nterms must be less than or equal to the number of frequencies specified via
    spwlist, chanlist and weightlist.
    nterms=1 will do a standard division by the average PB computed over all
    specified frequencies.
    
    threshold -- Flux level in the restored intensity map, below which to not
    recalculate spectral index.
    example : threshold = '0.1Jy'
    
    action -- Choice of PB-correction with spectral-index recalculation
    or only spectral-index recalculation (using the specified threshold)
    example : action='pbcor'  or action='calcalpha'
    
    With action='pbcor', the following output images are created/overwritten.
    
    - imagename.pbcor.workdirectory  :  This directory contains an image cube with
    PBs at the list of specified frequencies, and Taylor-coefficient images that
    describe the PB spectrum.
    -  imagename.pb.cube : Concatenated cube of PBs
    -  imagename.pb.tt0, tt1, ... : Taylor coefficients describing the PB spectrum
    -  imagename.pb.alpha : Spectral index of the PB (for information only)
    - imagename.image.pbcor.tt0,tt1,... : Corrected Taylor coefficients
    - imagename.pbcor.image.alpha : Corrected Spectral Index
    - imagename.pbcor.image.alpha.error : New error map.
    
    With action='calcalpha', the following output images are created/overwritten
    - imagename.image.alpha : Corrected Spectral Index
    - imagename.image.alpha.error : New error map.
    
    reffreq -- Reference frequency about which the Taylor-expansion is defined.
    example : reffreq = '1.5GHz'
    If left unspecified, it is picked from the input restored image.
    Note : If reffreq was specified during task clean to produce the images
    it must be specified here.
    
    pbmin -- PB gain level below which to not compute Taylor-coefficients or
    apply PB-corrections.
    example : pbmin = 0.1
    
    field -- Field selection for the Primary Beam calculation.
    example : field = '3C291'
    This field selection must be identical to that used in 'clean'
    
    spwlist -- List of SPW ids for which to make separate Primary Beams
    chanlist -- List of channel ids, within the above SPW ids, at which to make PBs.
    
    example :  spwlist=[0,1,2], chanlist=[32,32,32]
    Make PBs at frequencies corresponding to channel 32 of
    spws 0,1 and 2.
    example :  spwlist=[0,0,0], chanlist=[0,10,20]
    Make PBs at frequencies corresponding to channels 0,10,20
    of spw 0
    
    Primary beams are computed at these specified frequencies and
    for pointings selected by 'field'.  Taylor-coefficients that represent
    the PB spectrum are computed from these images.
    
    weightlist -- List of relative weights to apply to the PBs selected via the
    spwlist,chanlist parameters. Weights should approximately represent the
    sum-of-weights applicable during imaging each of these frequencies.
    example : weightlist=[0.5,1.0,1.0]
    The first frequency had less usable data due to flagged RFI,
    but the other two had relatively equal weight.
    These weights are applied to the PB spectrum while computing
    PB Taylor-coefficients. Setting weights to anything other than 1.0
    makes a difference only with very lop-sided weights.
    
    
    NOTE : One frequently asked question relates to how best to choose spwlist,chanlist,weightlist.
    
    The basic principles at work here are
    
    (1) Imaging = fitting a polynomial to a noisy spectrum (with weights).
    The polynomial represents I(nu) x P(nu)
    
    (2) PB model = fitting a polynomial to a collection of PBs at different
    frequencies (with weights). The polynomial represents P(nu)
    
    (3) Dividing the two polynomials via their coefficients.
    
    Steps (1) and (2) need to be consistent with each other (w.r.to frequencies used
    and their weights) to produce fits that when divided give exactly only the sky parameters.
    Unless you use the same math (and code) for both, they won't be exactly consistent.
    The way to minimize differences is to choose a list of frequencies (via spws/chans)
    and weights for widebandpbcor that resemble the frequency structure of the data you
    have used for imaging.
    For example, if you have 3 spws in your data and the middle spw has a factor of 10
    less weight in the data, then, using just one channel each from the two outer spws for
    the PB modeling may be close enough to using all 3 spws. Or, you could also pick
    the middle channel of all 3 spws, and assign weights as [1.0, 0.1, 1.0].
    
    
    


    """

    _info_group_ = """imaging"""
    _info_desc_ = """Wideband PB-correction on the output of the MS-MFS algorithm"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'imagename': {'type': 'cStr'}, 'nterms': {'type': 'cInt'}, 'threshold': {'type': 'cStr'}, 'action': {'type': 'cStr'}, 'reffreq': {'type': 'cStr'}, 'pbmin': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'field': {'type': 'cStr'}, 'spwlist': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'chanlist': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'weightlist': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __nterms_dflt( self, glb ):
        return int(2)

    def __nterms( self, glb ):
        if 'nterms' in glb: return glb['nterms']
        return int(2)

    def __threshold_dflt( self, glb ):
        return ''

    def __threshold( self, glb ):
        if 'threshold' in glb: return glb['threshold']
        return ''

    def __action_dflt( self, glb ):
        return 'pbcor'

    def __action( self, glb ):
        if 'action' in glb: return glb['action']
        return 'pbcor'

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __chanlist_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return []
        return None
    def __field_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return ""
        return None
    def __reffreq_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return ""
        return None
    def __spwlist_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return []
        return None
    def __pbmin_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return float(0.2)
        return None
    def __weightlist_dflt( self, glb ):
        if self.__action( glb ) == "pbcor": return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __reffreq( self, glb ):
        if 'reffreq' in glb: return glb['reffreq']
        dflt = self.__reffreq_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __pbmin( self, glb ):
        if 'pbmin' in glb: return glb['pbmin']
        dflt = self.__pbmin_dflt( glb )
        if dflt is not None: return dflt
        return float(0.2)
    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        dflt = self.__field_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwlist( self, glb ):
        if 'spwlist' in glb: return glb['spwlist']
        dflt = self.__spwlist_dflt( glb )
        if dflt is not None: return dflt
        return [ int() ]
    def __chanlist( self, glb ):
        if 'chanlist' in glb: return glb['chanlist']
        dflt = self.__chanlist_dflt( glb )
        if dflt is not None: return dflt
        return [ int() ]
    def __weightlist( self, glb ):
        if 'weightlist' in glb: return glb['weightlist']
        dflt = self.__weightlist_dflt( glb )
        if dflt is not None: return dflt
        return [ float() ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__vis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('vis',pre,self.__to_string_(value),post,description))
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __nterms_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__nterms( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'nterms': value},{'nterms': self.__schema['nterms']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('nterms',pre,self.__to_string_(value),post,description))
    def __threshold_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__threshold( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'threshold': value},{'threshold': self.__schema['threshold']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('threshold',pre,self.__to_string_(value),post,description))
    def __action_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__action( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'action': value},{'action': self.__schema['action']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('action',pre,self.__to_string_(value),post,description))
    def __reffreq_inp(self):
        out = self.__stdout or sys.stdout
        if self.__reffreq_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__reffreq( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'reffreq': value},{'reffreq': self.__schema['reffreq']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('reffreq',pre,self.__to_string_(value),post,description))
    def __pbmin_inp(self):
        out = self.__stdout or sys.stdout
        if self.__pbmin_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__pbmin( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'pbmin': value},{'pbmin': self.__schema['pbmin']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('pbmin',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        if self.__field_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__field( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spwlist_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwlist_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spwlist( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwlist': value},{'spwlist': self.__schema['spwlist']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwlist',pre,self.__to_string_(value),post,description))
    def __chanlist_inp(self):
        out = self.__stdout or sys.stdout
        if self.__chanlist_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__chanlist( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'chanlist': value},{'chanlist': self.__schema['chanlist']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('chanlist',pre,self.__to_string_(value),post,description))
    def __weightlist_inp(self):
        out = self.__stdout or sys.stdout
        if self.__weightlist_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__weightlist( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'weightlist': value},{'weightlist': self.__schema['weightlist']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('weightlist',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'chanlist' in glb: del glb['chanlist']
        if 'field' in glb: del glb['field']
        if 'nterms' in glb: del glb['nterms']
        if 'reffreq' in glb: del glb['reffreq']
        if 'imagename' in glb: del glb['imagename']
        if 'vis' in glb: del glb['vis']
        if 'spwlist' in glb: del glb['spwlist']
        if 'pbmin' in glb: del glb['pbmin']
        if 'weightlist' in glb: del glb['weightlist']
        if 'threshold' in glb: del glb['threshold']
        if 'action' in glb: del glb['action']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__vis_inp( )
        self.__imagename_inp( )
        self.__nterms_inp( )
        self.__threshold_inp( )
        self.__action_inp( )
        self.__reffreq_inp( )
        self.__pbmin_inp( )
        self.__field_inp( )
        self.__spwlist_inp( )
        self.__chanlist_inp( )
        self.__weightlist_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("widebandpbcor.last"):
                filename = "widebandpbcor.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, vis=None, imagename=None, nterms=None, threshold=None, action=None, reffreq=None, pbmin=None, field=None, spwlist=None, chanlist=None, weightlist=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('widebandpbcor.pre')
        _postfile = os.path.realpath('widebandpbcor.last')
        _return_result_ = None
        _arguments = [vis,imagename,nterms,threshold,action,reffreq,pbmin,field,spwlist,chanlist,weightlist]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if imagename is not None: local_global['imagename'] = imagename
            if nterms is not None: local_global['nterms'] = nterms
            if threshold is not None: local_global['threshold'] = threshold
            if action is not None: local_global['action'] = action

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['nterms'] = self.__nterms( local_global )
            _invocation_parameters['threshold'] = self.__threshold( local_global )
            _invocation_parameters['action'] = self.__action( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['reffreq'] = self.__reffreq( _invocation_parameters ) if reffreq is None else reffreq
            _invocation_parameters['pbmin'] = self.__pbmin( _invocation_parameters ) if pbmin is None else pbmin
            _invocation_parameters['field'] = self.__field( _invocation_parameters ) if field is None else field
            _invocation_parameters['spwlist'] = self.__spwlist( _invocation_parameters ) if spwlist is None else spwlist
            _invocation_parameters['chanlist'] = self.__chanlist( _invocation_parameters ) if chanlist is None else chanlist
            _invocation_parameters['weightlist'] = self.__weightlist( _invocation_parameters ) if weightlist is None else weightlist

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['nterms'] = self.__nterms( self.__globals_( ) )
            _invocation_parameters['threshold'] = self.__threshold( self.__globals_( ) )
            _invocation_parameters['action'] = self.__action( self.__globals_( ) )
            _invocation_parameters['reffreq'] = self.__reffreq( self.__globals_( ) )
            _invocation_parameters['pbmin'] = self.__pbmin( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spwlist'] = self.__spwlist( self.__globals_( ) )
            _invocation_parameters['chanlist'] = self.__chanlist( self.__globals_( ) )
            _invocation_parameters['weightlist'] = self.__weightlist( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#widebandpbcor( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _widebandpbcor_t( _invocation_parameters['vis'],_invocation_parameters['imagename'],_invocation_parameters['nterms'],_invocation_parameters['threshold'],_invocation_parameters['action'],_invocation_parameters['reffreq'],_invocation_parameters['pbmin'],_invocation_parameters['field'],_invocation_parameters['spwlist'],_invocation_parameters['chanlist'],_invocation_parameters['weightlist'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

widebandpbcor = _widebandpbcor( )

