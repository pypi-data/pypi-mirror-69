##################### generated by xml-casa (v2) from imregrid.xml ##################
##################### fc4ad665d7ea257dadef463f166dde6b ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import imregrid as _imregrid_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _imregrid:
    """
    imregrid ---- regrid an image onto a template image

    
    Imregrid will regrid an input image onto a new coordinate system from a template image
    or to a new directional reference frame. If a template image is used, then the input and
    template images must have the same coordinate structure.

    --------- parameter descriptions ---------------------------------------------

    imagename     Name of the source image
    template      A dictionary, refcode, or name of an image that provides the output shape and coordinate system
    output        Name for the regridded image
    asvelocity    Regrid spectral axis in velocity space rather than frequency space?
    axes          The pixel axes to regrid. -1 => all.
    shape         Shape of the output image. Only used if template is an image. If not specified (-1), the output image shape will be the same as the template image shape along the axes that are regridded and the same as input image shape along the axes which are not regridded.
    interpolation The interpolation method.  One of "nearest", "linear", "cubic".
    decimate      Decimation factor for coordinate grid computation
    replicate     Replicate image rather than regrid?
    overwrite     Overwrite (unprompted) pre-existing output file?

    --------- examples -----------------------------------------------------------

    
    The imregrid task currently finds the nearest input pixel center and interpolates to the output pixel center.
    No averaging is done in any direction!
    
    Imregrid will regrid an input image onto a new coordinate system from a template image
    or to a new directional reference frame. If a template image is used, then the input and
    template images must have the same coordinate structure.
    
    Keyword arguments:
    
    imagename       Name of the source image that needs to be regridded. Must be specified.
    example: imagename='orion.image'
    template        Dictionary, directional reference code, or imagename defining the new
    shape and coordinate system, or 'get' to return the template
    dictionary for imagename.  Recognized directional reference codes are:
    'J2000', 'B1950', 'B1950_VLA', 'GALACTIC', 'HADEC', 'AZEL',
    'AZELSW', 'AZELNE', 'ECLIPTIC', 'MECLIPTIC', 'TECLIPTIC',
    and 'SUPERGAL'.
    default: 'get'; example: template='orion_j2000.im' (for a template image),
    template='J2000' (to regrid the input image to J2000 coordinates).
    shape           Shape of the output image. Only used if template is an image.
    If not specified (-1), the output image will be the same as the template image
    shape along the axes which are regridded and the same as the input image shpae
    along the axes which are not regridded. If specified and the axis ordering between
    the input image and the template are not the same, the values in the array correspond
    to the axis ordering of the input image; the output image will have the same axis
    ordering as the input image. Ignored if template is set equal to a
    reference code. If template is a dictionary, the output shape is
    retrieved from the dictionary so the shape input parameter is ignored.
    output          Name for the regridded image.  Must be specified.
    example: imagename='orion_shifted.im'
    asvelocity      If True, regrid spectral axis with respect to velocity, not frequency. If False,
    regrid with respect to frequency. default: True
    axes            The pixel axes to regrid. Default value [-1] => all except Stokes. Ignored
    if template is set equal to a reference code (in which case only the directional
    axes are regridded). If specified, this should
    be provided as an array. example axes=[0,1] (only regrid the first two axes, which
    are normally the directional axes).
    interpolation   The interpolation method.  One of 'nearest', 'linear', 'cubic'.
    decimate        Decimation factor for coordinate grid computation
    replicate       Replicate image rather than regrid?
    overwrite">     Overwrite (unprompted) pre-existing output file?
    
    The new coordinate system is defined by the template parameter, which can be:
    
    * a recognized directional reference frame string. This will rotate the image and the coordinate system so that
    the new reference frame's axes are aligned to the cardinal directions (left-right, up-down).
    Rotation occurs about the center direction pixel. If this pixel is not the reference pixel,
    a temporary copy of the original image is created and the coordinate system is adjusted so
    the center direction pixel is the reference pixel. The coordinate system of the input image
    is not modified and the output image's reference direction pixel is the center pixel.
    Note that the conversion between one frame and another in general becomes less accurate
    as distance from the output image's reference pixel increases. Before the rotation occurs, the
    image is padded with masked pixels to ensure that all good pixels are used in the rotation (ie the
    corners of the image are not cropped after the rotation). After the image is rotated, any masked slices
    remaining along the edges of the image in the directional coordinate are cropped, so that there are
    no masked slices in the directional coordinate along the edges of the final image.
    * a {'csys': [valid coordinate system dictionary], 'shap': [int array describing the output shape]} dictionary.
    This is normally obtained by first running regrid with template='get'. In this case imregrid returns the
    necessary dictionary.
    * 'get', which does not regrid but returns the template dictionary
    for imagename, suitable for modification and reuse (see the point immediately above), or
    * the name of an image from which to get the coordinate system and shape.
    The input and template images must have the same
    coordinate structure.
    
    Regridding of complex-valued images is supported. The real and imaginary parts are
    regridded independently and the resulting regridded pixel values are combined to
    form the regridded, complex-valued image.
    
    The argument {stfaf replicate} can be used to simply replicate pixels
    rather than regridding them.  Normally ({stfaf replicate=F}), for every
    output pixel, its world coordinate is computed and the corresponding
    input pixel found (then a little interpolation grid is generated).  If
    you set {stfaf replicate=T}, then what happens is that for every output
    axis, a vector of regularly sampled input pixels is generated (based on
    the ratio of the output and input axis shapes).  So this just means the
    pixels get replicated (by whatever interpolation scheme you use) rather
    than regridded in world coordinate space.  This process is much faster,
    but its not a true world coordinate based regrid.
    
    As decribed above, when {stfaf replicate} is False, a coordinate is
    computed for each output pixel; this is an expensive operation.  The
    argument {stfaf decimate} allows you to decimate the computation of
    that coordinate grid to a sparse grid, which is then filled in via fast
    interpolation.  The default for {stfaf decimate} is 10.  The number of
    pixels per axis in the sparse grid is the number of output pixels for
    that axis divided by the decimation factor.  A factor of 10 does pretty
    well.  You may find that for very non-linear coordinate systems (e.g.
    very close to the pole) that you have to reduce the decimation factor.
    You may also have to reduce the decimation factor if the number of pixels
    in the output image along an axis to be regridded is less than about 50, or
    the output image may be completely masked.
    
    If one of the axes to be regridded is a spectral axis and asvelocity=T,
    the axis will be regridded to match the velocity, not the frequency,
    coordinate of the template coordinate system. Thus the output pixel
    values will correspond only to the velocity, not the frequency, of the
    output axis.
    
    A variety of interpolation schemes are provided (only
    the first three characters to be specified).  The cubic interpolation
    is substantially slower than linear, and often the improvement is
    modest.  By default linear interpolation is used.
    
    If an image has per-plane beams and one attempts to regrid the spectral axis,
    an exception is thrown.
    
    RULES USED FOR GENERATING OUTPUT IMAGES IN SPECIFIC CASES
    
    There are numerous rules governing the shape and coordinate system of the output
    image depending on the input image, template image, and wheher default values of the
    axes and shape parameters are used. They are enumerated below.
    
    NOTE: If you want to be certain of what type of output you will get, it is highly
    recommended you specify both axes and shape to avoid any ambiguity.
    
    1. Rules governing Stokes axes
    1.1. If the input image has no stokes axis, then the output image will have no stokes axis.
    1.2. If the input image has a stokes axis, but the template image/coordinate system does not,
    and if the default value of the shape parameter is used or if shape is specified and the
    specified value for the length stokes axis in equal to the length of the input image
    stokes axis, then all stokes in the input
    image will be present in the output image
    1.3. If the input image has a stokes axis, but the template image/coordinate system does not,
    and if the value of the shape parameter is specified but the length of the resulting stokes
    axis is not equal to the length of the input image's stokes axis, a failure will occur.
    1.4. If the input image has a stokes axis, if the template parameter is an image name, and if the
    template image has a degenerate stokes axis, if the axes parameter is not specified or is specified
    but does not contain the input stokes axis number, and if the shape parameter is not specified, then
    all stokes planes in the input image will be present in the output image.
    1.5. If the input image has a stokes axis, if the template parameter is an image name, and if the
    template image has a degenerate stokes axis, if the axes parameter is not specified or is specified
    but does not contain the input stokes axis number, if the shape parameter is specified, and if the
    specified length of the stokes axis is not equal to the length of the input stokes axis, then
    a failure will occur.
    1.6. If the input image has a stokes axis, if the template parameter is an image name, if the
    template image has a degenerate stokes axis, if the axes parameter is specified contains the
    input stokes axis number, then use the applicable rule of rules 1.7. and 1.8. for the template
    image having a nondegenerate stokes axis.
    1.7. If the input image has a stokes axis, if the template parameter is an image name, if the
    template image has a nondegenerate stokes axis, and if axes is not specified or if it is, it contains
    the input stokes axis number, then only the stokes parameters common to both the input image and
    the template image will be present in the output image. If the input image and the template image
    have no common stokes parameters, failure will occur. If shape is specified and the length of the
    specified stokes axis is not equal to the number of common stokes parameters in the input image and
    the template image, then failure will result.
    1.8. If the input image has a stokes axis, if the template parameter is an image name, if the
    template image has a nondegenerate stokes axis, and if axes is specified but does not contain the input
    image stokes axis number, then all stokes present in the input image will be present in the output image.
    If shape is also specified but the length of the specified stokes axis does not equal the length of
    the input stokes axis, then failure will result.
    
    2. Rules governing spectral axes
    In all cases, if the shape parameter is specified, the spectral axis length must be consistent with what
    one would normally expect in the special cases, or a failure will result.
    2.1. If the input image does not have a spectral axis, then the output image will not have a spectral axis.
    2.2. If the input image has a degenerate spectral axis, if the template parameter is an image name, and if the
    template image has a spectral axis, if axes is not specified or if it is and does not
    contain the input image spectral axis number, then the spectral coordinate of the input image is copied
    to the output image and the output image will have a degenerate spectral axis.
    2.3. If the input image has a degenerate spectral axis, if the template parameter is an image name, and if the
    template image has a spectral axis, if axes is specified and it
    contains the input image spectral axis number, then the spectral coordinate of the template image is copied
    to the output image. If shape is not specified, the output image will have the same number of channels
    as the input image. If shape is specified, the output image will have the number of channels as specified
    in shape for the spectral axis. In these cases, the pixel and mask values for all spectral hyperplanes
    will be identical; the regridded single spectral plane is simply replicated n times, where n is the
    number of channels in the output image.
    2.4. If the input image has a spectral axis, if the template parameter is an image name, and if the
    template image does not have a spectral axis, if axes is not specified or if it is and does not
    contain the input image spectral axis number, then the spectral coordinate of the input image is copied
    to the output image and the output image will have the same number of channels as the input image.
    2.5. If the input image has a spectral axis, if the template parameter is an image name, if the
    template image does not have a spectral axis, if axes is specified it
    contains the input image spectral axis number, then failure will result.
    2.6. If the input image has a spectral axis, if the template parameter is an image name, if the
    template image has a degenerate spectral axis, and if axes is unspecified or if it is but does not
    contain the spectral axis number of the input image, the spectral coordinate of the input image is
    copied to the output image and the output image will have the same number of channels as the input
    image.
    2.7. If the input image has a spectral axis, if the template parameter is an image name, if the
    template image has a nondegenerate spectral axis, and if axes is unspecified or if it is and
    contains the spectral axis number of the input image, regrid the spectral axis of the input to
    match the spectral axis of the template.
    
    IMPORTANT NOTE ABOUT FLUX CONSERVATION
    in general regridding is inaccurate for images that the angular resolution is poorly
    sampled. A check is done for such cases and a warning message is emitted if a beam present.
    However, no such check is done if there is no beam present. To add a restoring beam to
    an image, use ia.setrestoringbeam().
    
    Basic Examples
    
    # Regrid an image to the "B1950" or "GALACTIC" coordinate systems
    
    imregrid(imagename="input.image", output="output.image", template="B1950")
    imregrid(imagename="input.image", output="output.image", template="GALACTIC")
    
    Note that when regridding to another coordinate system in the manner above, if the
    input image's direction coordinate is already in the frame specified by template,
    a straight copy of the image is made. No regridding is actually done.
    
    # Obtain a template dictionary from an image and then use it to regrid another image
    
    temp_dict = imregrid(imagename="target.image", template="get")
    imregrid(imagename="input.image", output="output.image", template=temp_dict)
    
    In this example, the template="get" option is used in the first command in order to
    characterize the desired shape and coordinate system used, and a new dictionary,
    temp_dict, is generated accordingly. This is then used when performing the actual
    regridding of input.image in the second command.
    
    
    More Advanced Examples
    
    It is also possible to directly use a template image for regridding with imregrid.
    For this to work reliably and predictably, the dimensionality (i.e. which
    dimensions are present in an image) and the axis ordering of the input image must
    be the same. The type and ordering of the axes of both the input and template
    images can (and should) first be examined using the CASA imhead task. Any
    necessary reordering of axes can be performed using the CASA imtrans task.
    
    Unless the user explicitly specifies which dimensions to regrid using the axes
    parameter (see the following example), imregrid will also attempt to regrid
    degenerate axes (i.e. image axes of length one pixel). Stokes axes are never
    regridded.
    
    In the case where template is an image name and the default value of shape is specified,
    the output image's shape will be the same as the template image's shape along the axes which
    are regridded and the same as the input image's shape along the axes which are not regridded.
    So for example, if the input image has a shape of [20, 30, 40] and the template image has a shape
    of [10, 40, 70] and only axes=[0, 1], the output image will have a shape of [10, 40, 40]. If axes=[2],
    the output image will have a shape of [20, 30, 70].
    
    # Regrid input.image by directly using target.image as a template
    
    imregrid(imagename="input.image", output="output.image", template="target.image", shape=[500,500,40,1])
    
    In this example, it is assumed that the axis order of the input image is of the
    form (direction_x, direction_y, spectral, Stokes), where 'direction_x' and 'direction_y'
    are the directional coordinates on the sky (in some reference frame),
    'spectral' is a velocity/frequency axis, and 'Stokes' contains polarization
    information.  In this example, input.image might typically be a data cube of
    shape [100, 100, 40, 1]. Note that the default value of asvelocity (True) will be used so that
    the spectral axis will be regridded to the same velocity system as that of the template image.
    
    
    # Regrid only the first two axes of an image
    
    Firstly, the user should inspect the type and ordering of the axes with imhead,
    and then correct with imtrans if necessary.
    
    imregrid(imagename="input.image", output="output.image", template="target.image", axes=[0,1])
    
    The above command will regrid only the first two axes (normally the directional axes)  of input.image and
    leave all other axes unchanged. The output image will have the shape of the template image along the regridded
    axes [0, 1] and the shape of the  input image along the other axes since the shape parameter was not
    explicitly specified.
    
    
    # Regrid the third axis, considering velocity rather than frequency units
    
    imregrid(imagename="input.image", output="output.image", template="target.image", axes=[2], asvelocity=True)
    
    This example regrids the spectral axis (zero-based axis number 2)  with respect to velocity because the asvelocity parameter
    has been set to True. This is useful when eg, regridding a cube containing one spectral line to match the velocity coordinate
    of another cube containing a different spectral line.
    
    
    # Regrid the third axis, considering velocity rather than frequency units but first set the rest frequency
    
    imhead("input.image", mode="put", hdkey="restfreq", hdvalue="110GHz")
    imregrid(imagename="input.image", output="output.image", template="target.image", axes=[2], asvelocity=True)
    
    The first command in this example uses the imhead task to set the value of the
    image rest frequency to a value of 110GHz in input.image. The following
    imregrid command then performs a frequency units regridding only of the third
    axis listed (zero-based axis) (2), taking account of the input.image rest frequency in the input file.


    """

    _info_group_ = """analysis"""
    _info_desc_ = """regrid an image onto a template image"""

    __schema = {'imagename': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'template': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'output': {'type': 'cStr'}, 'asvelocity': {'type': 'cBool'}, 'axes': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'shape': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'interpolation': {'type': 'cStr'}, 'decimate': {'type': 'cInt'}, 'replicate': {'type': 'cBool'}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __template_dflt( self, glb ):
        return 'get'

    def __template( self, glb ):
        if 'template' in glb: return glb['template']
        return 'get'

    def __decimate_dflt( self, glb ):
        return int(10)

    def __decimate( self, glb ):
        if 'decimate' in glb: return glb['decimate']
        return int(10)

    def __axes_dflt( self, glb ):
        return [ int(-1) ]

    def __axes( self, glb ):
        if 'axes' in glb: return glb['axes']
        return [ int(-1) ]

    def __replicate_dflt( self, glb ):
        return False

    def __replicate( self, glb ):
        if 'replicate' in glb: return glb['replicate']
        return False

    def __interpolation_dflt( self, glb ):
        return 'linear'

    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        return 'linear'

    def __asvelocity_dflt( self, glb ):
        return True

    def __asvelocity( self, glb ):
        if 'asvelocity' in glb: return glb['asvelocity']
        return True

    def __output_dflt( self, glb ):
        return ''

    def __output( self, glb ):
        if 'output' in glb: return glb['output']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __shape_dflt( self, glb ):
        if self.__template( glb ) != "get": return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __shape( self, glb ):
        if 'shape' in glb: return glb['shape']
        dflt = self.__shape_dflt( glb )
        if dflt is not None: return dflt
        return [ int(-1) ]

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __template_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__template( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'template': value},{'template': self.__schema['template']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('template',pre,self.__to_string_(value),post,description))
    def __output_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__output( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'output': value},{'output': self.__schema['output']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('output',pre,self.__to_string_(value),post,description))
    def __asvelocity_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__asvelocity( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'asvelocity': value},{'asvelocity': self.__schema['asvelocity']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('asvelocity',pre,self.__to_string_(value),post,description))
    def __axes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__axes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'axes': value},{'axes': self.__schema['axes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('axes',pre,self.__to_string_(value),post,description))
    def __shape_inp(self):
        out = self.__stdout or sys.stdout
        if self.__shape_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__shape( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'shape': value},{'shape': self.__schema['shape']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('shape',pre,self.__to_string_(value),post,description))
    def __interpolation_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__interpolation( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('interpolation',pre,self.__to_string_(value),post,description))
    def __decimate_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__decimate( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'decimate': value},{'decimate': self.__schema['decimate']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('decimate',pre,self.__to_string_(value),post,description))
    def __replicate_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__replicate( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'replicate': value},{'replicate': self.__schema['replicate']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('replicate',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-13.13s = %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'interpolation' in glb: del glb['interpolation']
        if 'decimate' in glb: del glb['decimate']
        if 'imagename' in glb: del glb['imagename']
        if 'replicate' in glb: del glb['replicate']
        if 'axes' in glb: del glb['axes']
        if 'asvelocity' in glb: del glb['asvelocity']
        if 'template' in glb: del glb['template']
        if 'shape' in glb: del glb['shape']
        if 'output' in glb: del glb['output']
        if 'overwrite' in glb: del glb['overwrite']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__template_inp( )
        self.__output_inp( )
        self.__asvelocity_inp( )
        self.__axes_inp( )
        self.__shape_inp( )
        self.__interpolation_inp( )
        self.__decimate_inp( )
        self.__replicate_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("imregrid.last"):
                filename = "imregrid.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, template=None, output=None, asvelocity=None, axes=None, shape=None, interpolation=None, decimate=None, replicate=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('imregrid.pre')
        _postfile = os.path.realpath('imregrid.last')
        _return_result_ = None
        _arguments = [imagename,template,output,asvelocity,axes,shape,interpolation,decimate,replicate,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if template is not None: local_global['template'] = template
            if output is not None: local_global['output'] = output
            if asvelocity is not None: local_global['asvelocity'] = asvelocity
            if axes is not None: local_global['axes'] = axes
            if interpolation is not None: local_global['interpolation'] = interpolation
            if decimate is not None: local_global['decimate'] = decimate
            if replicate is not None: local_global['replicate'] = replicate
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['template'] = self.__template( local_global )
            _invocation_parameters['output'] = self.__output( local_global )
            _invocation_parameters['asvelocity'] = self.__asvelocity( local_global )
            _invocation_parameters['axes'] = self.__axes( local_global )
            _invocation_parameters['interpolation'] = self.__interpolation( local_global )
            _invocation_parameters['decimate'] = self.__decimate( local_global )
            _invocation_parameters['replicate'] = self.__replicate( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['shape'] = self.__shape( _invocation_parameters ) if shape is None else shape

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['template'] = self.__template( self.__globals_( ) )
            _invocation_parameters['output'] = self.__output( self.__globals_( ) )
            _invocation_parameters['asvelocity'] = self.__asvelocity( self.__globals_( ) )
            _invocation_parameters['axes'] = self.__axes( self.__globals_( ) )
            _invocation_parameters['shape'] = self.__shape( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['decimate'] = self.__decimate( self.__globals_( ) )
            _invocation_parameters['replicate'] = self.__replicate( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#imregrid( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _imregrid_t( _invocation_parameters['imagename'],_invocation_parameters['template'],_invocation_parameters['output'],_invocation_parameters['asvelocity'],_invocation_parameters['axes'],_invocation_parameters['shape'],_invocation_parameters['interpolation'],_invocation_parameters['decimate'],_invocation_parameters['replicate'],_invocation_parameters['overwrite'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

imregrid = _imregrid( )

