##################### generated by xml-casa (v2) from sdgaincal.xml #################
##################### 2baf73c5102ad31307f90a3f365bd8e1 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import sdgaincal as _sdgaincal_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdgaincal:
    """
    sdgaincal ---- MS SD gain calibration task

    
    
    

    --------- parameter descriptions ---------------------------------------------

    infile     name of input SD dataset (must be MS)
    calmode    gain calibration mode
    radius     radius of central region to be used for calibration
    smooth     smooth data or not
    antenna    select data by antenna name or ID, e.g. "PM03"
    field      select data by field IDs and names, e.g. "3C2*" ("" = all)
    spw        select data by spw IDs (spectral windows), e.g., "3,5,7" ("" = all)
    scan       select data by scan numbers, e.g. "21~23" (""=all)
    intent     select data by observation intent, e.g. "OBSERVE_TARGET#ON_SOURCE" (""=all)
    applytable (List of) sky and/or tsys tables for pre-application
    interp     Interp type in time[,freq], per gaintable. default==linear,linear
    spwmap     Spectral windows combinations to form for gaintables(s)
    outfile    name of output caltable
    overwrite  overwrite the output file if already exists
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infile -- Name of input SD dataset
    calmode -- Gain calibration mode. Currently, only 'doublecircle' is supported.
    options: 'doublecircle'
    default: 'doublecircle'
    >>> calmode expandable parameter
    radius -- Radius of the central region for double circle calibration.
    Default ('') is a radius of the primary beam. If numeric value
    is given, it is interpreted as a value in arcsec.
    default: ''
    options: '20arcsec', 20.0
    smooth -- Whether apply smoothing during gain calibration or not.
    options: (bool) True, False
    default: True
    antenna -- select data by antenna name or ID
    default: '' (use all antennas)
    example: 'PM03'
    field -- select data by field IDs and names
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 0 or field named 3C273)
    this selection is in addition to the other selections to data
    spw -- select data by spw IDs (spectral windows)
    NOTE this task only supports spw ID selction and ignores channel
    selection.
    default: '' (use all spws and channels)
    example: spw='3,5,7' (spw IDs 3,5,7; all channels)
    spw='<2' (spw IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (spw IDs with the center frequencies in range 30-45GHz; all channels)
    this selection is in addition to the other selections to data
    NOTE spw input must be '' (''= all) in calmode='tsys'.
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    this selection is in addition to the other selections to data
    NOTE scan input must be '' (''= all) in calmode='tsys'.
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: '' (use all scan intents)
    example: intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    this selection is in addition to the other selections to data
    applytable -- List of sky/Tsys calibration tables you want to pre-apply.
    default: ''
    >>> applytable expandable parameter
    interp -- Interpolation type (in time[,freq]) to use for each gaintable.
    When frequency interpolation is relevant (bandpass solutions,
    frequency-dependent polcal solutions, ALMA Tsys)
    separate time-dependent and freq-dependent interp
    types with a comma (freq _after_ the comma).
    Specifications for frequency are ignored when the
    calibration table has no channel-dependence.
    Time-dependent interp options ending in 'PD' enable a
    "phase delay" correction per spw for non-channel-dependent
    calibration types.
    For multi-obsId datasets, 'perobs' can be appended to
    the time-dependent interpolation specification to
    enforce obsId boundaries when interpolating in time.
    Add 'flag' to the freq-dependent interpolation options
    to enforce channel-dependent flagging (rather than
    interpolation/extrapolation).
    default: '' --> 'linear,linear' for all gaintable(s)
    example: interp='nearest'   (in time, freq-dep will be
    linear, if relevant)
    interp='linear,cubic'  (linear in time, cubic
    in freq)
    interp='linearperobs,splineflag' (linear in time
    per obsId,
    spline in
    freq with
    channelized
    flagging)
    interp=',spline'  (spline in freq; linear in
    time by default)
    interp=['nearest,spline','linear']  (for multiple gaintables)
    Options: Time: 'nearest', 'linear', 'nearestPD', 'linearPD'
    Freq: 'nearest', 'linear', 'cubic', 'spline',
    'nearestflag', 'linearflag', 'cubicflag', 'splineflag',
    
    spwmap -- Spectral windows combinations to form for gaintable(s)
    default: [] (apply solutions from each spw to that spw only)
    Example:  spwmap=[0,0,1,1] means apply the caltable solutions
    from spw = 0 to the spw 0,1 and spw 1 to spw 2,3.
    spwmap=[[0,0,1,1],[0,1,0,1]]  (for multiple gaintables)
    
    Complicated example:
    
    gaintable=['tab1','tab2','tab3']
    gainfield='3C286'
    interp=['linear','nearest']
    spwmap=[[],[0,0,2]]
    
    This means: apply 3 cal tables, selecting only solutions for 3C286
    from tab1 (but all fields from tab2 and tab3, indicated by
    no gainfield entry for these files).  Linear interpolation
    (in time) will be used for 'tab1' and 'tab3' (default); 'tab2' will
    use nearest.  For the 'tab2', the calibration spws map
    will be mapped to the data spws according to 0->0, 0->1, 2->2.
    (I.e., for data spw=0 and 2, the spw mapping is one to one,
    but data spw 1 will be calibrated by solutions from spw 0.)
    
    outfile -- Name of output caltable.
    default: '' (<infile>_<suffix> for calibration)
    overwrite -- overwrite the output caltable if already exists
    options: (bool) True,False
    default: False
    
    
    DESCRIPTION:
    sdgaincal computes and removes a time-dependent gain variation in single-dish
    data on a per-spectral-window and per-antenna basis. Presently the task
    operates only on data taken with the ALMA fast-mapped, double-circle
    observation modes [1]. This task exploits the fact that the double-circle mode
    observes the same position in the center of the mapped field, approximately
    circular every sub-cycle, and normalizes the gains throughout the entire
    dataset, relative to the measured brightness at the center position.
    
    Note that this gain calibration task is done independently of the atmosphere
    (i.e. Tsys) and sky calibration steps. This can be applied through the sdcal
    task. Alternatively, you can pass those caltables to applytable parameter to
    apply them on-the-fly prior to gain calibration.
    
    Presently, this task has only one calibration mode: calmode='doublecircle'.
    In this mode, the size of the region that CASA regards as "the center" is
    user-configurable via the expandable 'radius' (in arcsec) parameter (under
    'calmode'). The default is to use the size of the primary beam. The data can
    also be smoothed in the time domain, prior to computation of the gain variation.
    Selection is by specral window/channels, field IDs, and antenna through the spw,
    field, and antenna selection parameters. The default is to use all data for the
    gain calibration. The caltable can be output with the 'outfile' parameter.
    
    REFERENCE:
    [1] Phillips et al, 2015. Fast Single-Dish Scans of the Sun Using ALMA
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """ MS SD gain calibration task"""

    __schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'calmode': {'type': 'cStr'}, 'radius': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'smooth': {'type': 'cBool'}, 'antenna': {'type': 'cStr'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'applytable': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'interp': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'outfile': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __calmode_dflt( self, glb ):
        return 'doublecircle'

    def __calmode( self, glb ):
        if 'calmode' in glb: return glb['calmode']
        return 'doublecircle'

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __infile_dflt( self, glb ):
        return ''

    def __infile( self, glb ):
        if 'infile' in glb: return glb['infile']
        return ''

    def __applytable_dflt( self, glb ):
        return ''

    def __applytable( self, glb ):
        if 'applytable' in glb: return glb['applytable']
        return ''

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __interp_dflt( self, glb ):
        if self.__applytable( glb ) != "": return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__applytable( glb ) != "": return []
        return None
    def __smooth_dflt( self, glb ):
        if self.__calmode( glb ) == "doublecircle": return bool(True)
        return None
    def __radius_dflt( self, glb ):
        if self.__calmode( glb ) == "doublecircle": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __radius( self, glb ):
        if 'radius' in glb: return glb['radius']
        dflt = self.__radius_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __smooth( self, glb ):
        if 'smooth' in glb: return glb['smooth']
        dflt = self.__smooth_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [ ]

    #--------- subparam inp output ----------------------------------------------------
    def __infile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__infile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'infile': value},{'infile': self.__schema['infile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('infile',pre,self.__to_string_(value),post,description))
    def __calmode_inp(self):
        out = self.__stdout or sys.stdout
        description = 'gain calibration mode ("doublecircle")'
        value = self.__calmode( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'calmode': value},{'calmode': self.__schema['calmode']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('calmode',pre,self.__to_string_(value),post,description))
    def __radius_inp(self):
        out = self.__stdout or sys.stdout
        if self.__radius_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__radius( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'radius': value},{'radius': self.__schema['radius']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-7.7s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('radius',pre,self.__to_string_(value),post,description))
    def __smooth_inp(self):
        out = self.__stdout or sys.stdout
        if self.__smooth_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__smooth( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'smooth': value},{'smooth': self.__schema['smooth']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-7.7s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('smooth',pre,self.__to_string_(value),post,description))
    def __antenna_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('antenna',pre,self.__to_string_(value),post,description))
    def __field_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__field( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('field',pre,self.__to_string_(value),post,description))
    def __spw_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__spw( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('spw',pre,self.__to_string_(value),post,description))
    def __scan_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__scan( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('scan',pre,self.__to_string_(value),post,description))
    def __intent_inp(self):
        out = self.__stdout or sys.stdout
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__intent( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-7.7s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('intent',pre,self.__to_string_(value),post,description))
    def __applytable_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__applytable( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'applytable': value},{'applytable': self.__schema['applytable']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-10.10s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('applytable',pre,self.__to_string_(value),post,description))
    def __interp_inp(self):
        out = self.__stdout or sys.stdout
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__interp( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-7.7s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('interp',pre,self.__to_string_(value),post,description))
    def __spwmap_inp(self):
        out = self.__stdout or sys.stdout
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-7.7s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('spwmap',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-10.10s = %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'infile' in glb: del glb['infile']
        if 'outfile' in glb: del glb['outfile']
        if 'field' in glb: del glb['field']
        if 'smooth' in glb: del glb['smooth']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'scan' in glb: del glb['scan']
        if 'interp' in glb: del glb['interp']
        if 'radius' in glb: del glb['radius']
        if 'applytable' in glb: del glb['applytable']
        if 'calmode' in glb: del glb['calmode']
        if 'overwrite' in glb: del glb['overwrite']
        if 'spw' in glb: del glb['spw']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__infile_inp( )
        self.__calmode_inp( )
        self.__radius_inp( )
        self.__smooth_inp( )
        self.__antenna_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__applytable_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("sdgaincal.last"):
                filename = "sdgaincal.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, infile=None, calmode=None, radius=None, smooth=None, antenna=None, field=None, spw=None, scan=None, intent=None, applytable=None, interp=None, spwmap=None, outfile=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdgaincal.pre')
        _postfile = os.path.realpath('sdgaincal.last')
        _return_result_ = None
        _arguments = [infile,calmode,radius,smooth,antenna,field,spw,scan,intent,applytable,interp,spwmap,outfile,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infile is not None: local_global['infile'] = infile
            if calmode is not None: local_global['calmode'] = calmode
            if antenna is not None: local_global['antenna'] = antenna
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if applytable is not None: local_global['applytable'] = applytable
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infile'] = self.__infile( local_global )
            _invocation_parameters['calmode'] = self.__calmode( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['applytable'] = self.__applytable( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['radius'] = self.__radius( _invocation_parameters ) if radius is None else radius
            _invocation_parameters['smooth'] = self.__smooth( _invocation_parameters ) if smooth is None else smooth
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
            _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
            _invocation_parameters['radius'] = self.__radius( self.__globals_( ) )
            _invocation_parameters['smooth'] = self.__smooth( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['applytable'] = self.__applytable( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdgaincal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _sdgaincal_t( _invocation_parameters['infile'],_invocation_parameters['calmode'],_invocation_parameters['radius'],_invocation_parameters['smooth'],_invocation_parameters['antenna'],_invocation_parameters['field'],_invocation_parameters['spw'],_invocation_parameters['scan'],_invocation_parameters['intent'],_invocation_parameters['applytable'],_invocation_parameters['interp'],_invocation_parameters['spwmap'],_invocation_parameters['outfile'],_invocation_parameters['overwrite'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

sdgaincal = _sdgaincal( )

