##################### generated by xml-casa (v2) from rmfit.xml #####################
##################### d5d49dc42b43537504dae59d8802ee3d ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import rmfit as _rmfit_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _rmfit:
    """
    rmfit ---- Calculate rotation measure.

    --------- parameter descriptions ---------------------------------------------

    imagename Name(s) of the input image(s). Must be specified.
    rm        Output rotation measure image name. If not specified, no image is written.
    rmerr     Output rotation measure error image name. If not specified, no image is written.
    pa0       Output position angle (degrees) at zero wavelength image name. If not specified, no image is written.
    pa0err    Output position angle (degrees) at zero wavelength error image name. If not specified, no image is written.
    nturns    Output number of turns image name. If not specified, no image is written.
    chisq     Output reduced chi squared image name. If not specified, no image is written.
    sigma     Estimate of the thermal noise.  A value less than 0 means auto estimate.
    rmfg      Foreground rotation measure in rad/m/m to subtract.
    rmmax     Maximum rotation measure in rad/m/m for which to solve. IMPORTANT TO SPECIFY.
    maxpaerr  Maximum input position angle error in degrees to allow in solution determination.
    [1;42mRETURNS[1;m      bool

    --------- examples -----------------------------------------------------------

    
    PARAMETER SUMMARY
    imagename        Name(s) of the input image(s).
    rm               Output rotation measure image name. If not specified, no image is written.
    rmerr            Output rotation measure error image name. If not specified, no image is written.
    pa0              Output position angle (degrees) at zero wavelength image name. If not specified, no image is written.
    pa0err           Output position angle (degrees) at zero wavelength error image name. If not specified, no image is written.
    nturns           Output number of turns image name. If not specified, no image is written.
    chisq            Output reduced chi squared image name. If not specified, no image is written.
    sigma            Estimate of the thermal noise.  A value less than 0 means auto estimate.
    rmfg             Foreground rotation measure in rad/m/m to subtract.
    rmmax            Maximum rotation measure in rad/m/m for which to solve. IMPORTANT TO SPECIFY.
    
    This task generates the rotation measure image from stokes Q and U  measurements at several
    different frequencies.  You are required to specify the name of at least one image with a polarization
    axis containing stokes Q and U planes and with a frequency axis containing more than two pixels. The
    frequencies do not have to be equally spaced (ie the frequency coordinate can be a tabular coordinate).
    It will work out the position angle images for you. You may also specify multiple image names, in which
    case these images will first be concatenated along the spectral axis using ia.imageconcat(). The requirments
    are that for all images, the axis order must be the same and the number of pixels along each axis must
    be identical, except for the spectral axis which may differ in length between images. The spectral axis need
    not be contiguous from one image to another.
    
    See also the fourierrotationmeasure
    function for a new Fourier-based approach.
    
    Rotation measure algorithms that work robustly are few.  The main
    problem is in trying to account for the $n- pi$ ambiguity (see Leahy et
    al, Astronomy & Astrophysics, 156, 234 or Killeen et al;
    http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps).
    
    The algorithm that this task uses is that of Leahy et al. in see
    Appendix A.1.  But as in all these algorithms, the basic process is that
    for each spatial pixel, the position angle vs frequency data is fit to
    determine the rotation measure and the position angle at zero wavelength
    (and associated errors).   An image containing the number of $n- pi$ turns
    that were added to the data at each spatial pixel and for which the best fit
    was found can be written. The reduced chi-squared image for the fits can
    also be written.
    
    Note that no assessment of curvature (i.e. deviation
    from the simple linear position angle - $lambda^2$ functional form)
    is made.
    
    Any combination of output images can be written.
    
    The parameter sigma gives the thermal noise in Stokes Q and U.
    By default it is determined automatically using the image data.  But if it
    proves to be inaccurate (maybe not many signal-free pixels), it may be
    specified. This is used for calculating the error in the position angles (via
    propagation of Gaussian errors).
    
    The argument maxpaerr specifies the maximum allowable error in
    the position angle that is acceptable.  The default is an infinite
    value.  From the standard propagation of errors, the error in the
    linearly polarized position angle is determined from the Stokes Q and
    U images (at each directional pixel for each frequency). If the position angle
    error for any pixel exceeds the specified value, the position angle at that pixel
    is omitted from the fit. The process generates an error for the
    fit and this is used to compute the errors in the output
    images.
    
    Note that maxpaerr is not used to mask pixels in the output images.
    
    The argument rmfg is used to specify a foreground RM value.  For
    example, you may know the mean RM in some direction out of the Galaxy,
    then including this can improve the algorithm by reducing ambiguity.
    
    The parameter rmmax specifies the maximum absolute RM value that
    should be solved for.  This quite an important parameter.  If you leave
    it at the default, zero, no ambiguity handling will be
    used.  So some apriori information should be supplied; this
    is the basic problem with rotation measure algorithms.
    
    EXAMPLES
    
    # Calculate the rotation measure for a single polarization image
    rmfit(imagename="mypol.im", rm="myrm.im", rmmax=50.0)
    
    # calculate the rotation measure using a set of polarization images from
    # different spectral windows or bands.
    
    rmfit(imagename=["pol1.im", "pol2.im", "pol3.im", rm="myrm2.im", rmmax=50.0)


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Calculate rotation measure."""

    __schema = {'imagename': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'rm': {'type': 'cStr'}, 'rmerr': {'type': 'cStr'}, 'pa0': {'type': 'cStr'}, 'pa0err': {'type': 'cStr'}, 'nturns': {'type': 'cStr'}, 'chisq': {'type': 'cStr'}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'rmfg': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'rmmax': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'maxpaerr': {'type': 'cFloat', 'coerce': _coerce.to_float}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __pa0err_dflt( self, glb ):
        return ''

    def __pa0err( self, glb ):
        if 'pa0err' in glb: return glb['pa0err']
        return ''

    def __sigma_dflt( self, glb ):
        return float(-1)

    def __sigma( self, glb ):
        if 'sigma' in glb: return glb['sigma']
        return float(-1)

    def __pa0_dflt( self, glb ):
        return ''

    def __pa0( self, glb ):
        if 'pa0' in glb: return glb['pa0']
        return ''

    def __rmmax_dflt( self, glb ):
        return float(0.0)

    def __rmmax( self, glb ):
        if 'rmmax' in glb: return glb['rmmax']
        return float(0.0)

    def __nturns_dflt( self, glb ):
        return ''

    def __nturns( self, glb ):
        if 'nturns' in glb: return glb['nturns']
        return ''

    def __rm_dflt( self, glb ):
        return ''

    def __rm( self, glb ):
        if 'rm' in glb: return glb['rm']
        return ''

    def __maxpaerr_dflt( self, glb ):
        return float(1e30)

    def __maxpaerr( self, glb ):
        if 'maxpaerr' in glb: return glb['maxpaerr']
        return float(1e30)

    def __rmfg_dflt( self, glb ):
        return float(0.0)

    def __rmfg( self, glb ):
        if 'rmfg' in glb: return glb['rmfg']
        return float(0.0)

    def __chisq_dflt( self, glb ):
        return ''

    def __chisq( self, glb ):
        if 'chisq' in glb: return glb['chisq']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __rmerr_dflt( self, glb ):
        return ''

    def __rmerr( self, glb ):
        if 'rmerr' in glb: return glb['rmerr']
        return ''



    #--------- return inp/go default --------------------------------------------------


    #--------- return subparam values -------------------------------------------------


    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __rm_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__rm( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'rm': value},{'rm': self.__schema['rm']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('rm',pre,self.__to_string_(value),post,description))
    def __rmerr_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__rmerr( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'rmerr': value},{'rmerr': self.__schema['rmerr']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('rmerr',pre,self.__to_string_(value),post,description))
    def __pa0_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__pa0( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'pa0': value},{'pa0': self.__schema['pa0']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('pa0',pre,self.__to_string_(value),post,description))
    def __pa0err_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__pa0err( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'pa0err': value},{'pa0err': self.__schema['pa0err']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('pa0err',pre,self.__to_string_(value),post,description))
    def __nturns_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__nturns( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'nturns': value},{'nturns': self.__schema['nturns']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('nturns',pre,self.__to_string_(value),post,description))
    def __chisq_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chisq( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chisq': value},{'chisq': self.__schema['chisq']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('chisq',pre,self.__to_string_(value),post,description))
    def __sigma_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__sigma( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'sigma': value},{'sigma': self.__schema['sigma']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('sigma',pre,self.__to_string_(value),post,description))
    def __rmfg_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__rmfg( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'rmfg': value},{'rmfg': self.__schema['rmfg']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('rmfg',pre,self.__to_string_(value),post,description))
    def __rmmax_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__rmmax( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'rmmax': value},{'rmmax': self.__schema['rmmax']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('rmmax',pre,self.__to_string_(value),post,description))
    def __maxpaerr_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__maxpaerr( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'maxpaerr': value},{'maxpaerr': self.__schema['maxpaerr']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-9.9s = %s%-23.22s%s # %-.60s\n' % ('maxpaerr',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'pa0err' in glb: del glb['pa0err']
        if 'maxpaerr' in glb: del glb['maxpaerr']
        if 'chisq' in glb: del glb['chisq']
        if 'imagename' in glb: del glb['imagename']
        if 'rm' in glb: del glb['rm']
        if 'nturns' in glb: del glb['nturns']
        if 'pa0' in glb: del glb['pa0']
        if 'sigma' in glb: del glb['sigma']
        if 'rmerr' in glb: del glb['rmerr']
        if 'rmmax' in glb: del glb['rmmax']
        if 'rmfg' in glb: del glb['rmfg']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__rm_inp( )
        self.__rmerr_inp( )
        self.__pa0_inp( )
        self.__pa0err_inp( )
        self.__nturns_inp( )
        self.__chisq_inp( )
        self.__sigma_inp( )
        self.__rmfg_inp( )
        self.__rmmax_inp( )
        self.__maxpaerr_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("rmfit.last"):
                filename = "rmfit.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, rm=None, rmerr=None, pa0=None, pa0err=None, nturns=None, chisq=None, sigma=None, rmfg=None, rmmax=None, maxpaerr=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('rmfit.pre')
        _postfile = os.path.realpath('rmfit.last')
        _return_result_ = None
        _arguments = [imagename,rm,rmerr,pa0,pa0err,nturns,chisq,sigma,rmfg,rmmax,maxpaerr]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if rm is not None: local_global['rm'] = rm
            if rmerr is not None: local_global['rmerr'] = rmerr
            if pa0 is not None: local_global['pa0'] = pa0
            if pa0err is not None: local_global['pa0err'] = pa0err
            if nturns is not None: local_global['nturns'] = nturns
            if chisq is not None: local_global['chisq'] = chisq
            if sigma is not None: local_global['sigma'] = sigma
            if rmfg is not None: local_global['rmfg'] = rmfg
            if rmmax is not None: local_global['rmmax'] = rmmax
            if maxpaerr is not None: local_global['maxpaerr'] = maxpaerr

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['rm'] = self.__rm( local_global )
            _invocation_parameters['rmerr'] = self.__rmerr( local_global )
            _invocation_parameters['pa0'] = self.__pa0( local_global )
            _invocation_parameters['pa0err'] = self.__pa0err( local_global )
            _invocation_parameters['nturns'] = self.__nturns( local_global )
            _invocation_parameters['chisq'] = self.__chisq( local_global )
            _invocation_parameters['sigma'] = self.__sigma( local_global )
            _invocation_parameters['rmfg'] = self.__rmfg( local_global )
            _invocation_parameters['rmmax'] = self.__rmmax( local_global )
            _invocation_parameters['maxpaerr'] = self.__maxpaerr( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['rm'] = self.__rm( self.__globals_( ) )
            _invocation_parameters['rmerr'] = self.__rmerr( self.__globals_( ) )
            _invocation_parameters['pa0'] = self.__pa0( self.__globals_( ) )
            _invocation_parameters['pa0err'] = self.__pa0err( self.__globals_( ) )
            _invocation_parameters['nturns'] = self.__nturns( self.__globals_( ) )
            _invocation_parameters['chisq'] = self.__chisq( self.__globals_( ) )
            _invocation_parameters['sigma'] = self.__sigma( self.__globals_( ) )
            _invocation_parameters['rmfg'] = self.__rmfg( self.__globals_( ) )
            _invocation_parameters['rmmax'] = self.__rmmax( self.__globals_( ) )
            _invocation_parameters['maxpaerr'] = self.__maxpaerr( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#rmfit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _rmfit_t( _invocation_parameters['imagename'],_invocation_parameters['rm'],_invocation_parameters['rmerr'],_invocation_parameters['pa0'],_invocation_parameters['pa0err'],_invocation_parameters['nturns'],_invocation_parameters['chisq'],_invocation_parameters['sigma'],_invocation_parameters['rmfg'],_invocation_parameters['rmmax'],_invocation_parameters['maxpaerr'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

rmfit = _rmfit( )

