##################### generated by xml-casa (v2) from specsmooth.xml ################
##################### 9ce67b6e18c266da65d2ed749fef7884 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatasks import specsmooth as _specsmooth_t
from collections import OrderedDict
import sys
import os

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _specsmooth:
    """
    specsmooth ---- Smooth an image region in one dimension

    --------- parameter descriptions ---------------------------------------------

    imagename Name of the input image
    outfile   Output image name.
    box       Rectangular region to select in direction plane. Default is to use the entire direction plane.
    chans     Channels to use. Channels must be contiguous. Default is to use all channels.
    stokes    Stokes planes to use. Planes specified must be contiguous. Default is to use all Stokes planes.
    region    Region selection. Default is to use the full image.
    mask      Mask to use. Default is none..
    overwrite Overwrite the output if it exists?
    stretch   Stretch the mask if necessary and possible? Default False
    axis      The profile axis. Default: use the spectral axis if one exists, axis 0 otherwise (<0).
    function  Convolution function. hanning and boxcar are supported functions. Minimum match is supported.
    width     Width of boxcar, in pixels.
    dmethod   Decimation method. "" means no decimation, "copy" and "mean" are also supported (minimum match).
    [1;42mRETURNS[1;m      record

    --------- examples -----------------------------------------------------------

    
    
    Smooth an image region in one dimension.
    
    ARAMETER SUMMARY
    imagename       Name of the input (CASA, FITS, MIRIAD) image
    box             Rectangular region to select in direction plane.
    Default is to use the entire direction plane. Only a single box may be specified.
    chans           Channels to use. Channels must be contiguous.
    Default is to use all channels.
    stokes          Stokes planes to use. Planes specified must be
    contiguous. Default is to use all Stokes planes.
    region          Region selection. Default is to use the full image.
    mask            Mask to use. Default is none.
    overwrite       If the specified outfile already exists, overwrite it if True.
    stretch         Stretch the input mask if necessary and possible? Only used if a mask is specified.
    
    axis            Pixel axis along which to do the convolution <0 means use the spectral axis.
    function        Convolution function to use. Supported values are "boxcar" and "hanning". Minimum
    match is supported.
    width           Width of boxcar in pixels. Used only if function parameter minimally matches "boxcar".
    dmethod         Plane decimation method. "" means no decimation should be performed. Other supported
    values are "copy" and "mean". Minimal match is supported. See below for details.
    
    This application performs one dimensional convolution along a specified axis of an image
    or selected region of an image. Hanning smoothing and boxcar smoothing are supported.
    Both float valued and complex valued images are supported. Masked pixel values are set to
    zero prior to convolution. All nondefault pixel masks are ignored during
    the calculation. The convolution is done in the image domain (i.e., not
    with an FFT).
    
    BOXCAR SMOOTHING
    
    One dimensional boxcar convolution is defined by
    
    z[i] = (y[i] + y[i+i] + ... + y[i+w])/w
    
    where z[i] is the value at pixel i in the box car smoothed image, y[k]
    is the pixel value of the input image at pixel k, and w is a postivie integer
    representing the width of the boxcar in pixels.  The length of the axis along which the
    convolution is to occur must be at least w pixels in the selected region,
    unless decimation using the mean function is chosen in which case the axis
    length must be at least 2*w (see below).
    
    If dmethod="" (no decimation), the length of the output axis will be equal
    to the length of the input axis - w + 1. The pixel mask, ORed with the OTF mask
    if specified, is copied from the selected region of the input image to the
    output image. Thus for example, if the selected region in the input image has
    six planes along the convolution axis, if the specified boxcar width is 2,
    and if the pixel values, which are all unmasked, on a slice along this axis
    are [1, 2, 5, 10, 17, 26], then the corresponding output slice will be of
    length five pixels and the output pixel values will be [1.5, 3.5, 7.5, 13.5, 21.5].
    
    If dmethod="copy", the output image is the image calculated
    if dmethod="", except that only every wth plane is kept. Both the pixel and mask
    values of these planes are copied directly to the output image, without further
    processing. Thus for example, if the selected region in the input image has six
    planes along the convolution axis, the boxcar width is chosen to be 2, and if
    the pixel values, which are all unmasked, on a slice along this axis are [1, 2,
    5, 10, 17, 26], the corresponding output pixel values will be [1.5, 7.5, 21.5].
    
    If dmethod="mean", first the image described in the dmethod=""
    case is calculated. Then, the ith plane of the output image is calculated by
    averaging the i*w to the (i+1)*w-1  planes of this intermediate image. Thus, for
    example, if the selected region in the input image has six planes along the
    convolution axis, the boxcar width is chosen to be 2, and if the pixel values,
    which are all unmasked, on a slice along this axis are [1, 2, 5, 10, 17, 26],
    then the corresponding output pixel values will be [2.5, 10.5]. Any pixels at the
    end of the convolution axis of the intermediate image that do not fall into a complete bin of
    width w are ignored. Masked values are taken into consideration when forming this
    average, so if one of the values is masked, it is not used in the average. If at
    least one of the values in the intermediate image bin is not masked, the
    corresponding output pixel will not be masked.
    
    HANNING SMOOTHING
    
    Hanning convolution of one axis of an image is defined by
    
    z[i] = 0.25*y[i-1] + 0.5*y[i] + 0.25*y[i+1]       (equation 1)
    
    where z[i] is the value at pixel i in the hanning smoothed image, and
    y[i-1], y[i], and y[i+1] are the values of the input image at pixels i-1,
    i, and i+1 respectively. The length of the axis along which the convolution is
    to occur must be at least three pixels in the selected region.
    
    If dmethod="" (no decimation of image planes), the length of the output axis will
    be the same as that of the input axis. The output pixel values along the convolution
    axis will be related to those of the input values according to equation 1, except
    the first and last pixels. In that case,
    
    z[0] = 0.5*(y[0] + y[1])
    
    and,
    
    z[N-1] = 0.5*(y[N-2] + y[N-1])
    
    where N is the number of pixels along the convolution aixs.
    The pixel mask, ORed with the OTF mask if specified, is copied from the selected
    region of the input image to the output image. Thus for example, if the selected
    region in the input image has six planes along the convolution axis, and if the pixel
    values, which are all unmasked, on a slice along this axis are [1, 2, 5, 10, 17, 26],
    the corresponding output pixel values will be [1.5, 2.5, 5.5, 10.5, 17.5, 21.5].
    
    If dmethod="copy", the output image is the image calculated if
    dmethod="", except that only the odd-numbered planes are kept. Furthermore, if the
    number of planes along the convolution axis in the selected region of the input image
    is even, the last odd number plane is also discarded. Thus, if the selected region
    has N pixels along the convolution axis in the input image, along the convolution
    axis the output image will have (N-1)/2 planes if N is odd, or (N-2)/2 planes if N
    is even. The pixel and mask values are copied directly, without further
    processing. Thus for example, if the selected region in the input image has six planes
    along the convolution axis, and if the pixel values, which are all unmasked, on a slice
    along this axis are [1, 2, 5, 10, 17, 26], the corresponding output pixel values will be
    [2.5, 10.5].
    
    If dmethod="mean", first the image described in the dmethod="" case
    is calculated. The first plane and last plane(s) of that image are then discarded as
    described in the dmethod="copy" case. Then, the ith plane of the output
    image is calculated by averaging the (2*i)th and (2*i + 1)th planes of the intermediate
    image. Thus for example, if the selected region in the input image has six planes
    along the convolution axis, and if the pixel values, which are all unmasked, on a slice
    along this axis are [1, 2, 5, 10, 17, 26], the corresponding output pixel values will be
    [4.0, 14.0]. Masked values are taken into consideration when forming this average, so if
    one of the values is masked, it is not used in the average. If at least one of the values
    in the input pair is not masked, the corresponding output pixel will not be masked.
    
    
    EXAMPLES
    
    # boxcar smooth the spectral axis by 3 pixels, say it's axis 2 and only
    # write every other pixel
    specsmooth(imagename="mynonsmoothed.im", outfile="myboxcarsmoothed.im",
    axis=2, function="boxcar", dmethod="copy", width=3, overwrite=True)
    
    # hanning smooth the spectral axis, say it's axis 2 and do not perform decimation
    # of image planes
    specsmooth(imagename="mynonsmoothed.im", outfile="myhanningsmoothed.im",
    axis=2, dmethod=""," overwrite=True)


    """

    _info_group_ = """analysis"""
    _info_desc_ = """Smooth an image region in one dimension"""

    __schema = {'imagename': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outfile': {'type': 'cStr'}, 'box': {'type': 'cStr'}, 'chans': {'type': 'cStr'}, 'stokes': {'type': 'cStr'}, 'region': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'mask': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'stretch': {'type': 'cBool'}, 'axis': {'type': 'cInt'}, 'function': {'type': 'cStr'}, 'width': {'type': 'cInt'}, 'dmethod': {'type': 'cStr'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    #--------- return nonsubparam values ----------------------------------------------

    def __function_dflt( self, glb ):
        return 'boxcar'

    def __function( self, glb ):
        if 'function' in glb: return glb['function']
        return 'boxcar'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __dmethod_dflt( self, glb ):
        return 'copy'

    def __dmethod( self, glb ):
        if 'dmethod' in glb: return glb['dmethod']
        return 'copy'

    def __axis_dflt( self, glb ):
        return int(-1)

    def __axis( self, glb ):
        if 'axis' in glb: return glb['axis']
        return int(-1)

    def __mask_dflt( self, glb ):
        return ''

    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __region_dflt( self, glb ):
        return ''

    def __region( self, glb ):
        if 'region' in glb: return glb['region']
        return ''

    def __chans_dflt( self, glb ):
        return ''

    def __chans( self, glb ):
        if 'chans' in glb: return glb['chans']
        return ''

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''

    def __box_dflt( self, glb ):
        return ''

    def __box( self, glb ):
        if 'box' in glb: return glb['box']
        return ''

    #--------- return non subparam/when values ---------------------------------------------
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        return int(2)

    #--------- return inp/go default --------------------------------------------------
    def __stretch_dflt( self, glb ):
        if self.__mask( glb ) != "": return bool(False)
        return None
    def __overwrite_dflt( self, glb ):
        if self.__outfile( glb ) != "": return bool(False)
        return None
    def __width_dflt( self, glb ):
        if self.__function( glb ) != "hanning": return int(2)
        return None

    #--------- return subparam values -------------------------------------------------
    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        dflt = self.__overwrite_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __stretch( self, glb ):
        if 'stretch' in glb: return glb['stretch']
        dflt = self.__stretch_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('imagename',pre,self.__to_string_(value),post,description))
    def __outfile_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('outfile',pre,self.__to_string_(value),post,description))
    def __box_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__box( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'box': value},{'box': self.__schema['box']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('box',pre,self.__to_string_(value),post,description))
    def __chans_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__chans( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'chans': value},{'chans': self.__schema['chans']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('chans',pre,self.__to_string_(value),post,description))
    def __stokes_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('stokes',pre,self.__to_string_(value),post,description))
    def __region_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__region( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'region': value},{'region': self.__schema['region']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('region',pre,self.__to_string_(value),post,description))
    def __mask_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__mask( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('mask',pre,self.__to_string_(value),post,description))
    def __overwrite_inp(self):
        out = self.__stdout or sys.stdout
        if self.__overwrite_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__overwrite( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('overwrite',pre,self.__to_string_(value),post,description))
    def __stretch_inp(self):
        out = self.__stdout or sys.stdout
        if self.__stretch_dflt( self.__globals_( ) ) is not None:
             description = ''
             value = self.__stretch( self.__globals_( ) )
             (pre,post) = ('','') if self.__validate_({'stretch': value},{'stretch': self.__schema['stretch']}) else ('\x1B[91m','\x1B[0m')
             out.write('   \x1B[92m%-9.9s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('stretch',pre,self.__to_string_(value),post,description))
    def __axis_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__axis( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'axis': value},{'axis': self.__schema['axis']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('axis',pre,self.__to_string_(value),post,description))
    def __function_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__function( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'function': value},{'function': self.__schema['function']}) else ('\x1B[91m','\x1B[0m')
        out.write('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23.22s%s # %-.60s\n' % ('function',pre,self.__to_string_(value),post,description))
    def __width_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__width( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('width',pre,self.__to_string_(value),post,description))
    def __dmethod_inp(self):
        out = self.__stdout or sys.stdout
        description = ''
        value = self.__dmethod( self.__globals_( ) )
        (pre,post) = ('','') if self.__validate_({'dmethod': value},{'dmethod': self.__schema['dmethod']}) else ('\x1B[91m','\x1B[0m')
        out.write('%-12.12s = %s%-23.22s%s # %-.60s\n' % ('dmethod',pre,self.__to_string_(value),post,description))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'mask' in glb: del glb['mask']
        if 'dmethod' in glb: del glb['dmethod']
        if 'stretch' in glb: del glb['stretch']
        if 'imagename' in glb: del glb['imagename']
        if 'function' in glb: del glb['function']
        if 'chans' in glb: del glb['chans']
        if 'region' in glb: del glb['region']
        if 'box' in glb: del glb['box']
        if 'axis' in glb: del glb['axis']
        if 'overwrite' in glb: del glb['overwrite']
        if 'width' in glb: del glb['width']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        self.__imagename_inp( )
        self.__outfile_inp( )
        self.__box_inp( )
        self.__chans_inp( )
        self.__stokes_inp( )
        self.__region_inp( )
        self.__mask_inp( )
        self.__overwrite_inp( )
        self.__stretch_inp( )
        self.__axis_inp( )
        self.__function_inp( )
        self.__width_inp( )
        self.__dmethod_inp( )

    #--------- tget function ----------------------------------------------------------
    def tget(self,file=None):
        from .stack_manip import find_frame
        from runpy import run_path
        filename = None
        if file is None:
            if os.path.isfile("specsmooth.last"):
                filename = "specsmooth.last"
        elif isinstance(file, str):
            if os.path.isfile(file):
                filename = file
        if filename is not None:
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]

    def __call__( self, imagename=None, outfile=None, box=None, chans=None, stokes=None, region=None, mask=None, overwrite=None, stretch=None, axis=None, function=None, width=None, dmethod=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('specsmooth.pre')
        _postfile = os.path.realpath('specsmooth.last')
        _return_result_ = None
        _arguments = [imagename,outfile,box,chans,stokes,region,mask,overwrite,stretch,axis,function,width,dmethod]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if outfile is not None: local_global['outfile'] = outfile
            if box is not None: local_global['box'] = box
            if chans is not None: local_global['chans'] = chans
            if stokes is not None: local_global['stokes'] = stokes
            if region is not None: local_global['region'] = region
            if mask is not None: local_global['mask'] = mask
            if axis is not None: local_global['axis'] = axis
            if function is not None: local_global['function'] = function
            if width is not None: local_global['width'] = width
            if dmethod is not None: local_global['dmethod'] = dmethod

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['box'] = self.__box( local_global )
            _invocation_parameters['chans'] = self.__chans( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['region'] = self.__region( local_global )
            _invocation_parameters['mask'] = self.__mask( local_global )
            _invocation_parameters['axis'] = self.__axis( local_global )
            _invocation_parameters['function'] = self.__function( local_global )
            _invocation_parameters['width'] = self.__width( local_global )
            _invocation_parameters['dmethod'] = self.__dmethod( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['overwrite'] = self.__overwrite( _invocation_parameters ) if overwrite is None else overwrite
            _invocation_parameters['stretch'] = self.__stretch( _invocation_parameters ) if stretch is None else stretch

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['box'] = self.__box( self.__globals_( ) )
            _invocation_parameters['chans'] = self.__chans( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['region'] = self.__region( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['stretch'] = self.__stretch( self.__globals_( ) )
            _invocation_parameters['axis'] = self.__axis( self.__globals_( ) )
            _invocation_parameters['function'] = self.__function( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['dmethod'] = self.__dmethod( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#specsmooth( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _return_result_ = _specsmooth_t( _invocation_parameters['imagename'],_invocation_parameters['outfile'],_invocation_parameters['box'],_invocation_parameters['chans'],_invocation_parameters['stokes'],_invocation_parameters['region'],_invocation_parameters['mask'],_invocation_parameters['overwrite'],_invocation_parameters['stretch'],_invocation_parameters['axis'],_invocation_parameters['function'],_invocation_parameters['width'],_invocation_parameters['dmethod'] )
        except: _return_result_ = False
        try:
            os.rename(_prefile,_postfile)
        except: pass
        return _return_result_

specsmooth = _specsmooth( )

