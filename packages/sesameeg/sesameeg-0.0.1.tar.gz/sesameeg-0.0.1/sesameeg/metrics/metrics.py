# -*- coding: utf-8 -*-

# Author: Gianvittorio Luria <luria@dima.unige.it>
#
# License: BSD (3-clause)

import numpy as np
import itertools as it
import scipy.spatial.distance as ssd
from ..utils import initialize_radius


def compute_mld(src, pmap_tot, true_pos):
    """Compute the Map Localization Discrepancy

    Parameters
    ----------
    src :  array of floats, shape (n_verts, 3)
        The coordinates of the points in the brain discretization.
    pmap_tot : array of floats, shape (n_verts)
        The intensity measure of the point process.
    true_pos: array of floats, shape (n_true_sources, 3)
        The coordinates of the sourcespace grid points in which the sources are located.
    Returns
    -------
    mld: float
        Map Localization Discrepancy in millimeters.
    """
    all_dist = list()
    _r = initialize_radius(src)
    if _r == 0.01:
        _scale = 1000
    elif _r == 1:
        _scale = 10
    elif _r == 10:
        _scale = 1
    else:
        raise ValueError
    for t in true_pos:
        all_dist.append(list(map(lambda x: _scale * ssd.euclidean(x, t), src)))
    _dist = np.amin(np.asarray(all_dist), axis=0).flatten()
    _num = np.sum(list(map(lambda x,y : (x*np.abs(y))**2, _dist, pmap_tot.flatten())))
    _denum = np.sum(np.abs(pmap_tot)**2)
    return np.sqrt(_num / _denum)


def compute_ospa(src, true_locs, est_locs, true_src=None):
    """

    :param src: array
            Source space
    :param true_locs: array
    :param est_locs: array
    :return:
    """

    if true_src is not None:
        distance_matrix = ssd.cdist(true_src, src)
    else:
        distance_matrix = ssd.cdist(src, src)
    true_n_dips = true_locs.shape[0]
    est_n_dips = est_locs.shape[0]

    if est_n_dips <= true_n_dips:
        all_perms_idx = np.asarray(list(it.permutations(range(true_n_dips))))
        ospa_temp = np.mean(distance_matrix[true_locs[all_perms_idx][:, :est_n_dips], est_locs],
                            axis=1)
        ospa = np.min(ospa_temp)
    elif est_n_dips > true_n_dips:
        all_perms_idx = np.asarray(list(it.permutations(range(est_n_dips))))
        ospa_temp = np.mean(distance_matrix[true_locs, est_locs[all_perms_idx][:, :true_n_dips]],
                            axis=1)
        ospa = np.min(ospa_temp)
    else:
        raise ValueError

    return ospa


def compute_goodness_of_fit(meas_field, est_n_dips, est_locs, est_dip_moms, lead_field):
    """Evaluate the estimated configuration of dipoles. The goodness
    of fit (GOF) with the recorded data is defined as

    .. math:: GOF = \\frac{\\| \\mathbf{y} - \\hat{\\mathbf{y}} \\|}
                     { \\|\\mathbf{y}\\|}

    where :math:`\\mathbf{y}` is the recorded data,
    :math:`\\hat{\\mathbf{y}}` is the field generated by the
    estimated configuration of dipoles, and :math:`\\| \\cdot \\|`
    is the Frobenius norm.

    Returns
    -------
    gof : float
        The goodness of fit with the recorded data.
    """

    if est_n_dips == 0:
        raise ValueError("No dipole has been estimated!")
    if est_dip_moms is None:
        raise AttributeError("No dipoles' moment found."
                             " Run compute_q first.")

    rec_field = np.zeros(meas_field.shape)
    for i_d in range(est_n_dips):
        rec_field += np.dot(lead_field[:, 3*est_locs[i_d]:
                                            3*(est_locs[i_d]+1)],
                            est_dip_moms[:, 3*i_d:3*(i_d+1)].T)

    gof = 1 - np.linalg.norm(meas_field - rec_field) \
        / np.linalg.norm(meas_field)

    return gof


def compute_sd(src, pmap_tot, est_pos):
    """Compute the Source Dispersion

    Parameters
    ----------
    src :  array of floats, shape (n_verts, 3)
        The coordinates of the points in the brain discretization.
    pmap_tot : array of floats, shape (n_verts)
        The intensity measure of the point process.
    est_pos: array of floats, shape (n_true_sources, 3)
        The coordinates of the sourcespace grid points in which the sources have been estimated.
    Returns
    -------
    sd: float
        Source Dispersion in millimeters.
    """
    all_dist = list()
    _r = initialize_radius(src)
    if _r == 0.01:
        _scale = 1000
    elif _r == 1:
        _scale = 10
    elif _r == 10:
        _scale = 1
    else:
        raise ValueError
    for t in est_pos:
        all_dist.append(list(map(lambda x: _scale * ssd.euclidean(x, t), src)))
    _dist = np.amin(np.asarray(all_dist), axis=0).flatten()
    _num = np.sum(list(map(lambda x,y : (x*np.abs(y))**2, _dist, pmap_tot.flatten())))
    _denum = np.sum(np.abs(pmap_tot)**2)
    return np.sqrt(_num / _denum)
