##################### generated by xml-casa (v2) from split.xml #####################
##################### 4f4939f48df6d95ab11c44115a8d0423 ##############################
from __future__ import absolute_import
import numpy
from casatools.typecheck import CasaValidator as _val_ctor
_pc = _val_ctor( )
from casatools.coercetype import coerce as _coerce
from .private.task_split import split as _split_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log

class _split:
    """
    split ---- Create a visibility subset from an existing visibility set

    
    Split is the general purpose program to make a new data set that is a
    subset or averaged form of an existing data set. General selection
    parameters are included, and one or all of the various data columns
    (DATA, LAG_DATA and/or FLOAT_DATA, MODEL_DATA and/or CORRECTED_DATA)
    can be selected.
    
    Split is often used after the initial calibration of the data to make
    a smaller Measurement Set with only the data that will be used in
    further flagging, imaging and/or self-calibration. Split can average
    over frequency (channels) and time (integrations).
    
    The split task uses the MSTransform framework underneath. Split also
    supports the Multi-MS (MMS) format as input.

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file
                Default: none
                
                   Example: vis='ngc5921.ms'
    outputvis   Name of output visibility file
                Default: '' (same as vis)
                
                   Example: outputvis='ngc5921_out.ms'
                
                IMPORTANT: if a .flagversions file with the name
                of the output MS exist, this task will exit with
                an error. The user needs to rename or remove the
                existing flagbackup or choose a different output
                name for the MS.
    keepmms     Create a Multi-MS as the output if the input is a
                Multi-MS.
                Default: True
                Options: True|False
                
                By default it will create a Multi-MS when the
                input is a Multi-MS. The output Multi-MS will
                have the same partition axis of the input
                MMS. See CASA Docs for more information on
                the MMS format.
                
                NOTE: It is not possible to do time average with
                combine='scan' if the input MMS was partitioned
                with separationaxis='scan' or 'auto'. In this
                case, the task will abort with an error.
    field       Select field using field id(s) or field name(s)
                Default: '' (all fields)
                
                Use 'go listobs' to obtain the list id's or
                names. If field string is a non-negative integer,
                it is assumed a field index,  otherwise, it is
                assumed a field name.
                
                   Examples:
                   field='0~2'; field ids 0,1,2
                   field='0,4,5~7'; field ids 0,4,5,6,7
                   field='3C286,3C295'; field named 3C286 and
                   3C295
                   field = '3,4C*'; field id 3, all names
                   starting with 4C
    spw         Select spectral window/channels
                          Default: ''=all spectral windows and channels
                
                             Examples:
                             spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                             spw='<2';  spectral windows less than 2 (i.e. 0,1)
                             spw='0:5~61'; spw 0, channels 5 to 61
                             spw='0,10,3:3~45'; spw 0,10 all channels, spw
                             3 - chans 3 to 45.
                             spw='0~2:2~6'; spw 0,1,2 with channels 2
                             through 6 in each.
                             spw = '*:3~64'  channels 3 through 64 for all sp id's
                             spw = ' :3~64' will NOT work.
                
                          NOTE: mstransform does not support multiple
                          channel ranges per spectral window (';').
    scan        Scan number range
                Subparameter of selectdata=True
                Default: '' = all
    antenna     Select data based on antenna/baseline
                                   Subparameter of selectdata=True
                                   Default: '' (all)
                
                                   If antenna string is a non-negative integer, it
                                   is assumed an antenna index, otherwise, it is
                                   assumed as an antenna name
                
                                       Examples: 
                                       antenna='5&6'; baseline between antenna
                                       index 5 and index 6.
                                       antenna='VA05&VA06'; baseline between VLA
                                       antenna 5 and 6.
                                       antenna='5&6;7&8'; baselines with
                                       indices 5-6 and 7-8
                                       antenna='5'; all baselines with antenna index
                                       5
                                       antenna='05'; all baselines with antenna
                                       number 05 (VLA old name)
                                       antenna='5,6,10'; all baselines with antennas
                                       5,6,10 index numbers
    correlation Select data based on correlation
                Default: '' ==> all
                
                   Example: correlation="XX,YY".
    timerange   Select data based on time range
                Subparameter of selectdata=True
                Default = '' (all)
                
                   Examples:
                   timerange =
                   'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                   (Note: if YYYY/MM/DD is missing date defaults
                   to first day in data set.)
                   timerange='09:14:0~09:54:0' picks 40 min on
                   first day 
                   timerange= '25:00:00~27:30:00' picks 1 hr to 3
                   hr 30min on NEXT day
                   timerange='09:44:00' pick data within one
                   integration of time
                   timerange='>10:24:00' data after this time
    intent      Select observing intent
                Default: '' (no selection by intent)
                
                   Example: intent='*BANDPASS*'  (selects data
                   labelled with BANDPASS intent)
    array       (Sub)array number range
                Default: '' (all)
    uvrange     Select data by baseline length.
                Default = '' (all)
                
                   Examples:
                   uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                   uvrange='>4klambda';uvranges greater than 4 kilo-lambda
                   uvrange='0~1000km'; uvrange in kilometers
    observation Select by observation ID(s)
                Subparameter of selectdata=True
                Default: '' = all
                
                    Example: observation='0~2,4'
    feed        Selection based on the feed 
                NOT IMPLEMENTED YET!
                Default: '' = all
    datacolumn  Which data column(s) to use for processing
                                 (case-insensitive).
                                 Default: 'corrected'
                                 Options: 'data', 'model', 'corrected',
                                 'all','float_data', 'lag_data',
                                 'float_data,data', 'lag_data,data'
                
                                    Example: datacolumn='data'
                
                                 NOTE: 'all' = whichever of the above that are
                                 present. If the requested column does not exist,
                                 the task will exit with an error.
    keepflags   Keep *completely flagged rows* instead of dropping them.
                Default: True (keep completely flagged rows in
                the output)
                Options: True|False
                
                Keepflags has no effect on partially flagged
                rows. All of the channels and correlations of a
                row must be flagged for it to be droppable, and a
                row must be well defined to be keepable.
                
                IMPORTANT: Regardless of this parameter, flagged
                data is never included in channel averaging. On
                the other hand, partially flagged rows will
                always be included in time averaging. The average
                value of the flagged data for averages containing
                ONLY flagged data in the relevant output channel
                will be written to the output with the
                corresponding flag set to True, while only
                unflagged data is used on averages where there is
                some unflagged data with the flag set to False.
    width       Number of channels to average to form one output channel
                If a list is given, each bin will apply to one
                spw in the selection.
                Default: 1 (no channel average)
                Options: (int)|[int]
                
                   Example: chanbin=[2,3] => average 2 channels
                   of 1st selected spectral window and 3 in the
                   second one.
    timebin     Bin width for time averaging
                Default: '0s'
                
                Bin width for time averaging. When timebin is
                greater than 0s, the task will average data in
                time. Flagged data will be included in the
                average calculation, unless the parameter
                keepflags is set to False. In this case only
                partially flagged rows will be used in the
                average.
    combine     Let the timebin span across scan, state or both.
                Default: '' (separate time bins by both of the
                above)
                Options: 'scan', 'state', 'state,scan'
                
                State is equivalent to sub-scans. One scan may
                have several state ids. For ALMA MSs, the
                sub-scans are limited to about 30s duration
                each. In these cases, the task will automatically
                add state to the combine parameter. To see the
                number of states in an MS, use the msmd tool. See
                help msmd.
                
                   Examples: 
                 * combine = 'scan'; can be useful when the scan
                   number goes up with each integration as in
                   many WSRT MSs.
                 * combine = ['scan', 'state']: disregard scan
                   and state numbers when time averaging.
                 * combine = 'state,scan'; same as above.
                
                NOTE: It is not possible to do time average with
                combine='scan' if the input MMS was partitioned
                with separationaxis='scan' or 'auto'. In this
                case, the task will abort with an error.

    --------- examples -----------------------------------------------------------

    
    
    For more information, see the task pages of split in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Create a visibility subset from an existing visibility set"""

    def __call__( self, vis='', outputvis='', keepmms=True, field='', spw='', scan='', antenna='', correlation='', timerange='', intent='', array='', uvrange='', observation='', feed='', datacolumn='corrected', keepflags=True, width=int(1), timebin='0s', combine='' ):
        schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'keepmms': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'scan': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'correlation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'array': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'observation': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'feed': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'datacolumn': {'type': 'cStr', 'allowed': [ 'DATA', 'model', 'corrected', 'LAG_DATA', 'lag_data', 'FLOAT_DATA,DATA', 'FLOAT_DATA', 'CORRECTED', 'lag_data,data', 'float_data', 'float_data,data', 'DATA,MODEL,CORRECTED', 'ALL', 'MODEL', 'all', 'data,model,corrected', 'LAG_DATA,DATA', 'data' ]}, 'keepflags': {'type': 'cBool'}, 'width': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'timebin': {'type': 'cStr'}, 'combine': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}}
        doc = {'vis': vis, 'outputvis': outputvis, 'keepmms': keepmms, 'field': field, 'spw': spw, 'scan': scan, 'antenna': antenna, 'correlation': correlation, 'timerange': timerange, 'intent': intent, 'array': array, 'uvrange': uvrange, 'observation': observation, 'feed': feed, 'datacolumn': datacolumn, 'keepflags': keepflags, 'width': width, 'timebin': timebin, 'combine': combine}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _logging_state_ = _start_log( 'split', [ 'vis=' + repr(_pc.document['vis']), 'outputvis=' + repr(_pc.document['outputvis']), 'keepmms=' + repr(_pc.document['keepmms']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'scan=' + repr(_pc.document['scan']), 'antenna=' + repr(_pc.document['antenna']), 'correlation=' + repr(_pc.document['correlation']), 'timerange=' + repr(_pc.document['timerange']), 'intent=' + repr(_pc.document['intent']), 'array=' + repr(_pc.document['array']), 'uvrange=' + repr(_pc.document['uvrange']), 'observation=' + repr(_pc.document['observation']), 'feed=' + repr(_pc.document['feed']), 'datacolumn=' + repr(_pc.document['datacolumn']), 'keepflags=' + repr(_pc.document['keepflags']), 'width=' + repr(_pc.document['width']), 'timebin=' + repr(_pc.document['timebin']), 'combine=' + repr(_pc.document['combine']) ] )
        return _end_log( _logging_state_, 'split', _split_t( _pc.document['vis'], _pc.document['outputvis'], _pc.document['keepmms'], _pc.document['field'], _pc.document['spw'], _pc.document['scan'], _pc.document['antenna'], _pc.document['correlation'], _pc.document['timerange'], _pc.document['intent'], _pc.document['array'], _pc.document['uvrange'], _pc.document['observation'], _pc.document['feed'], _pc.document['datacolumn'], _pc.document['keepflags'], _pc.document['width'], _pc.document['timebin'], _pc.document['combine'] ) )

split = _split( )

