"""
Container for Avro schemas.
"""

import copy
import json
from collections import OrderedDict
from pathlib import Path
from typing import Optional

from avro_preprocessor.avro_domain import Avro
from avro_preprocessor.avro_naming import AvroNaming
from avro_preprocessor.avro_paths import AvroPaths
from avro_preprocessor.colored_json import ColoredJson

__author__ = "Nicola Bova"
__copyright__ = "Copyright 2018, Jaumo GmbH"
__email__ = "nicola.bova@jaumo.com"


class SchemasContainer:
    """
    A memory container from schemas.
    """

    def __init__(
            self,
            paths: AvroPaths,
            verbose: bool = True,
    ) -> None:
        self.paths: AvroPaths = paths
        self.verbose: bool = verbose
        self.original: OrderedDict = OrderedDict()
        self.processed: OrderedDict = OrderedDict()
        self.autogenerated_keys: OrderedDict = OrderedDict()

        self.modules: OrderedDict = OrderedDict()

    def read_schemas(self) -> None:
        """
        Reads schemas from disk
        """
        self.paths.traverse_path(
            self.paths.input_path, self.paths.input_schema_file_extension, self._get_schema)

        self.processed = copy.deepcopy(self.original)

        if self.verbose:
            print('')

    def _get_schema(self, path: Path) -> None:
        schema_text = path.read_text()
        try:
            schema = json.loads(schema_text, object_pairs_hook=OrderedDict)
        except json.decoder.JSONDecodeError as exc:
            print('Error while processing schema', path)
            raise exc
        namespace = str(
            Path(
                str(path.absolute())
                .replace(str(Path(self.paths.input_path).absolute()) + '/', '')
                .replace('/', '.')
            )
            .with_suffix('')
        )

        self._store_schema(schema, namespace)

        if self.verbose:
            print('Reading', path, ' -> ', namespace)

    def _store_schema(self, schema: OrderedDict, namespace: str) -> None:
        schema_doc = schema[Avro.Doc] if isinstance(schema[Avro.Doc], str) \
            else ' '.join(schema[Avro.Doc])

        # if we run the preprocessor with the KeyGenerator module and then re-run it again
        # we need to recognize the autogenerated key schemas and store them
        # in the right container
        if schema_doc.startswith(AvroNaming.autogenerated_key_doc):
            self.autogenerated_keys[namespace] = schema
        else:
            self.original[namespace] = schema

    def write_schemas(self) -> None:
        """
        Writes schemas to disk.
        """
        # let's cleanup the output schema directory first
        AvroPaths.reset_directory(self.paths.output_path)

        schemas_and_keys = list(self.processed.items()) + list(self.autogenerated_keys.items())

        for name, schema in schemas_and_keys:
            schema_text = json.dumps(schema, indent=ColoredJson.json_indent)
            path = self.paths.to_output_path(name)
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(schema_text)

    def print_schemas(self, how: str = 'json', indent: Optional[int] = None) -> None:
        """
        Print all schemas.
        :param how: 'json' or 'dict'
        :param indent: how much to indent printed JSONs
        """
        def print_schema(schema_name: str, data: OrderedDict) -> None:
            value = ColoredJson.highlight_json(data, indent) if how == 'json' else data
            print(schema_name, value)

        print('#### ORIGINAL SCHEMAS ####')
        for name, schema in self.original.items():
            print_schema(name, schema)

        print('#### PROCESSED SCHEMAS ####')
        for name, schema in self.processed.items():
            print_schema(name, schema)
