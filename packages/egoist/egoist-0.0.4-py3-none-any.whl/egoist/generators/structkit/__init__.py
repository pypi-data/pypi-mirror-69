from __future__ import annotations
import typing as t

import logging
import pathlib
import contextlib
from egoist.app import App
from egoist import types
from egoist.langhelpers import get_path_from_function_name


if t.TYPE_CHECKING:
    from egoist.runtime import Env
    from egoist.internal.prestringutil import Module
    from egoist.go.resolver import Resolver

logger = logging.getLogger(__name__)


def walk(fns: t.Dict[str, types.Command], *, root: t.Union[str, pathlib.Path]) -> None:
    from egoist.components.fs import open_fs

    with open_fs(root=root) as fs:
        for name, fn in fns.items():
            logger.debug("walk %s", name)
            fpath = f"{get_path_from_function_name(name)}.go"
            with fs.open_file_with_tracking(fpath, "w", target=fn):
                fn()


@contextlib.contextmanager
def structkit(
    env: Env,
    classes: t.List[t.Type[t.Any]],
    dry_run: bool,
    *,
    resolver: t.Optional[Resolver] = None,
) -> t.Iterator[Module]:
    if dry_run:
        logger.debug("dry run, %s skipped", __name__)
        yield env.m
        return

    from egoist.go.types import get_gopackage
    from egoist.go.resolver import get_resolver
    from egoist.go import walker
    from egoist.generators.structkit import _emit
    from . import runtime

    m = env.m
    resolver = resolver or get_resolver(m)
    ctx = walker.Context(
        m=m, resolver=resolver, _metadata_handler=runtime._default_metadata_handler
    )

    yield m
    m.import_("")
    m.stmt(f"// this file is generated by {__name__}")
    m.sep()

    w = ctx.get_metashape_walker(classes)
    for item in walker.walk(w, metadata_handler=ctx.metadata_handler):
        gopackage = get_gopackage(item.type_)
        if gopackage is not None:
            continue

        if item.is_enums:
            _emit.emit_enums(ctx, item.type_)
            m.sep()
        elif item.is_union:
            _emit.emit_union(ctx, item)
            m.sep()
        else:
            _emit.emit_struct(ctx, item)
            m.sep()
            if item.fields:
                _emit.emit_unmarshalJSON(ctx, item)
            m.sep()


def includeme(app: App) -> None:
    app.include("egoist.components.fs")
