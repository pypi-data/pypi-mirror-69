Metadata-Version: 2.1
Name: decorated-registry
Version: 0.0.2
Summary: Decorator-based registry for objects with arbitrary payloads
Home-page: https://github.com/andreycizov/python-decorated_registry
License: MIT
Keywords: registry,decorator,generic,register
Author: Andrey Cizov
Author-email: acizov@gmail.com
Requires-Python: >=3.6,<4.0
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: License :: OSI Approved :: MIT License
Classifier: Natural Language :: English
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Requires-Dist: dataclasses (>0.1); python_version < "3.7"
Project-URL: Documentation, https://github.com/andreycizov/python-decorated_registry
Project-URL: Repository, https://github.com/andreycizov/python-decorated_registry
Description-Content-Type: text/markdown

decorated_registry
==================

Implementation of generalised registries for Python.

Allows you to seamlessly create registries of tests, modules, DSLs and RPCs.

Supports arguments and fully typed.

Example
-------

```python
from typing import List, Type
from dataclasses import dataclass
from decorated_registry import Registry, ConstructorPayloadFactory

# framework/abstract.py

@dataclass
class ModuleConfig:
    init_priority: int = -1


class Module:
    pass

# framework/registry.py

application_module: Registry[ModuleConfig, Type[Module]] = Registry(
    payload_factory=ConstructorPayloadFactory(dict)
)

# authentication_mod/impl.py

@application_module
class AuthenticationModule(Module):
    pass


# database_mod/impl.pu

@application_module(init_priority=2)
class DatabaseSessionModule(Module):
    pass

# framework/app.py

def load_modules() -> List[Module]:
    rtn = []
    # ensure modules are loaded in the order given by `ModuleConfig.priority`
    modules_priority = sorted(application_module.items, key=lambda x: x.payload.init_priority)
    for x in modules_priority:
        module_cls: Type[Module] = x.value
        module = module_cls()
        rtn.append(module)
    return rtn


# framework/main.py

def main():
    modules = load_modules()


if __name__ == '__main__':
    main()
```

