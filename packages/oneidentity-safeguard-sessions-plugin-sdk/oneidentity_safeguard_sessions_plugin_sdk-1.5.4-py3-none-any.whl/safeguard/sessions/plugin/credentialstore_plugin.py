#
# Copyright (c) 2006-2020 Balabit
# All Rights Reserved.
#
"""
.. py:module:: safeguard.sessions.plugin.credentialstore_plugin
    :synopsis: Credential store plugin base class

CredentialStorePlugin way of working
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When SPS calls the CredentialStorePlugin, it does so by creating a CredentialStorePlugin (or more likely derived class)
instance. The initialization of the instance processes the given plugin configuration and sets the logging level
appropriately.

On the new plugin instance SPS will make a call to ``get_password_list`` and/or ``get_private_key_list`` to fetch
passwords and ssh private keys to be used against the target server of the user session. If the authentication on the
server is successful, then SPS will once again instantiate the plugin and call ``authentication_completed``. Note that
this step is not called if the authentication fails. When the session is closed, SPS will call the ``session_ended``
method of yet another instance of the plugin.

In all cases CredentialStorePlugin implements the methods above and  first collects the input parameters in
:class:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>` and sets up
:py:attr:`self.cookie <CredentialStorePlugin.cookie>`.

When self is set up, CredentialStorePlugin calls the user defined implementation in
:meth:`do_get_password_list() <CredentialStorePlugin.do_get_password_list>`,
:meth:`do_get_private_key_list() <CredentialStorePlugin.do_get_private_key_list>` for all account, asset pairs
generated by :meth:`_generate_accounts() <CredentialStorePlugin._generate_accounts>`,
:meth:`_generate_assets() <CredentialStorePlugin._generate_assets>` methods until either a credential is found or
there are no more accounts to check. The :py:attr:`self.account <CredentialStorePlugin.account>` and
:py:attr:`self.asset <CredentialStorePlugin.asset>` attributes are set to the account, asset to be checked out and
are also put into the cookie so they are available in the later plugin invocations.

The :meth:`do_authentication_completed() <CredentialStorePlugin.do_authentication_completed>` and
:meth:`do_session_ended() <CredentialStorePlugin.do_session_ended>` may be implemented to implement different
methods regarding successful authentication on the target server and at the end of the session.

To ensure that credentials are checked in even in the case of failed target server authentication, the
:meth:`do_check_in_credential() <CredentialStorePlugin.do_check_in_credential>` method should be implemented which is
called in these cases:

* ``authentication_completed`` when authentication on the target server was successful,
* ``get_password_list`` when a private key was checked out previously, but was not successfully used on the target
  server,
* ``session_ended`` when authentication on the target server failed.


CredentialStorePlugin methods and attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"""
from .connection_info import ConnectionInfo
from .plugin_base import cookie_property, PluginBase


class CredentialStorePlugin(PluginBase):
    """
    The :class:`CredentialStorePlugin` class implements the common functionality of credential store plugins.
    The following methods and attributes are available outside the constructor - on top of the ones inherited from
    :class:`PluginBase <safeguard.sessions.plugin.plugin_base.PluginBase` class:

    *New in version 1.2.0.*

    .. py:attribute:: connection

        The :py:attr:`self.connection <safeguard.sessions.plugin.connection_info.ConnectionInfo>` provides a read-only
        view of the parameters passed to the currently executing plugin hook, e.g. :meth:`do_get_password_list`.

    .. py:attribute:: cookie

    The :py:attr:`self.cookie <cookie>` attribute is a dict that retains its contents between invocations of
    :meth:`do_get_password_list`, :meth:`do_get_private_key_list`, :meth:`do_authentication_completed`,
    :meth:`do_check_in_credential` and :meth:`do_session_ended`. This is the way to pass data between these functions.

    When the plugin returns the contents are automatically returned to SPS.

    .. py:attribute:: session_cookie

    The :py:attr:`self.session_cookie <session_cookie>` is similar to :py:attr:`self.cookie <cookie>`, but it is
    also visible in other plugins in the same session. When the plugin returns the contents are automatically
    returned to SPS.

    .. py:attribute:: account

    The :py:attr:`self.account <account>` attribute contains the account identifier that should be checked out.
    This value is also kept in the cookie. The list of candidates is generated by the :meth:`_generate_accounts`
    method.

    .. py:attribute:: asset

    The :py:attr:`self.asset <asset>` attribute contains the asset identifier that should be checked out.
    This value is also kept in the cookie. The list of candidates is generated by the :meth:`_generate_assets`
    method.
    """

    def __init__(self, configuration, defaults=None, logger=None):
        super().__init__(configuration, defaults, logger)

    CHECK_IN_TRIGGER_SECTION = "check-in-trigger"
    CHECK_IN_TRIGGER_SESSION_ENDED = "session-ended"
    CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED = "authentication-completed"

    def do_get_password_list(self):
        """
        The :meth:`do_get_password_list` method should implement fetching passwords for the given
        :meth:`account <CredentialStorePlugin.account>` name and possible :meth:`assets <CredentialStorePlugin.assets>`
        names.

        :return: a dict containing a list of passwords: {'passwords': ['secret', 'topsecret']} or empty list [] if \
        no password could be fetched.
        """
        raise NotImplementedError("do_get_password_list")

    def do_get_private_key_list(self):
        """
        The :meth:`do_get_private_key_list` method should be implemented like :meth:`do_get_password_list`, but return
        ssh private keys instead.
        :return: a dict containing a list of ssh private keys: {'private_keys': [('ssh-rsa', 'secret-rsa-key-data'), \
        ('ssh-dss': 'secret-dsa-key-data')]} or empty list [] if no private keys could be fetched.
        """
        raise NotImplementedError("do_get_private_key_list")

    def do_authentication_completed(self):
        """
        The :meth:`do_authentication_completed` method can be used to implement logic to run in case of successful
        authentication on the target server.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    def do_check_in_credential(self):
        """
        The :meth:`do_check_in_credential` method can be used to implement logic to check-in the passwords and keys
        previously checked out by ``do_get_password_list`` or ``do_get_private_key_list``.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    def do_session_ended(self):
        """
        The :meth:`do_session_ended` method can be used to implement logic related to the end of a session.

        Note: ``self.connection`` will only contain session_id.

        :returns: None
        """
        pass

    @cookie_property
    def account(self):
        return None

    @cookie_property
    def asset(self):
        return None

    def _generate_accounts(self):
        """
        The :meth:`_generate_accounts` method generates a list of account identifiers in the credential store.

        :return: a generator of account identifiers.
        """
        yield self.connection.server_username

    def _generate_assets(self):
        """
        The :meth:`_generate_assets` method generates a list of asset identifiers in the credential store.

        :return: a generator of asset identifiers.
        """
        yield self.connection.server_hostname or self.connection.server_ip

    def get_private_key_list(
        self,
        cookie,
        session_cookie,
        # base credential store arguments
        session_id,
        protocol,
        client_ip,
        client_hostname,
        gateway_domain,
        gateway_username,
        gateway_password,
        gateway_groups,
        # get secret arguments
        server_domain,
        server_username,
        server_ip,
        server_port,
        server_hostname,
    ):
        self._setup_self(
            cookie,
            session_cookie,
            ConnectionInfo(
                session_id=session_id,
                protocol=protocol,
                client_ip=client_ip,
                client_hostname=client_hostname,
                gateway_domain=gateway_domain,
                gateway_username=gateway_username,
                gateway_password=gateway_password,
                gateway_groups=gateway_groups,
                server_domain=server_domain,
                server_username=server_username,
                server_ip=server_ip,
                server_port=server_port,
                server_hostname=server_hostname
            )
        )
        self._set_check_in_trigger()
        return self.finalize_hook(self.__fetch_credentials(self.do_get_private_key_list, "private_keys"))

    def get_password_list(
        self,
        cookie,
        session_cookie,
        # base credential store arguments
        session_id,
        protocol,
        client_ip,
        client_hostname,
        gateway_domain,
        gateway_username,
        gateway_password,
        gateway_groups,
        # get secret arguments
        server_domain,
        server_username,
        server_ip,
        server_port,
        server_hostname,
    ):
        self._setup_self(
            cookie,
            session_cookie,
            ConnectionInfo(
                session_id=session_id,
                protocol=protocol,
                client_ip=client_ip,
                client_hostname=client_hostname,
                gateway_domain=gateway_domain,
                gateway_username=gateway_username,
                gateway_password=gateway_password,
                gateway_groups=gateway_groups,
                server_domain=server_domain,
                server_username=server_username,
                server_ip=server_ip,
                server_port=server_port,
                server_hostname=server_hostname
            )
        )
        self._set_check_in_trigger()
        return self.finalize_hook(self.__fetch_credentials(self.do_get_password_list, "passwords"))

    def _set_check_in_trigger(self):
        choices = (self.CHECK_IN_TRIGGER_SESSION_ENDED, self.CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED)
        setting = self.plugin_configuration.getienum(
            self.CHECK_IN_TRIGGER_SECTION, self.connection.protocol.lower(), choices
        ) or self.plugin_configuration.getienum(
            self.CHECK_IN_TRIGGER_SECTION, "default", choices, default=self.CHECK_IN_TRIGGER_SESSION_ENDED
        )
        self._set_private("check_in_trigger", setting)

    def __fetch_credentials(self, method, key):
        if self.account:
            self.logger.info(
                "Executing check-in as it failed for the previous check out account={} asset={}".format(
                    self.account, self.asset
                )
            )
            self.do_check_in_credential()

        try:
            for account in self._generate_accounts():
                self.account = account
                for asset in self._generate_assets():
                    self.asset = asset
                    self.logger.info("Fetching {} for account={} asset={}".format(key, account, asset))
                    result = method()
                    if isinstance(result, dict) and result.get(key):
                        self.logger.info("Found {} for account={} asset={}".format(key, account, asset))
                        return self._add_cookies(result)
                    self.logger.info("No {} for account={} asset={}".format(key, account, asset))
        except NotImplementedError:
            self.logger.info("This plugin does not support fetching {}".format(key))
        self.account = None
        self.asset = None
        return self._add_cookies({key: []})

    def authentication_completed(self, cookie, session_cookie, session_id):
        self._setup_self(cookie, session_cookie, ConnectionInfo(session_id=session_id))
        self.do_authentication_completed()
        self.logger.info(
            "Executing check-in after successful authentication account={} asset={}".format(self.account, self.asset)
        )
        if self._get_private("check_in_trigger") != self.CHECK_IN_TRIGGER_AUTHENTICATION_COMPLETED:
            self.logger.info("Postpone check-in according to configuration")
        else:
            self.do_check_in_credential()
            self._set_private("check_in_called", True)
        return self.finalize_hook(self._add_cookies({}))

    def session_ended(self, cookie, session_cookie, session_id):
        self._setup_self(cookie, session_cookie, ConnectionInfo(session_id=session_id))
        if not self._get_private("check_in_called", False) and self.account:
            reason = (
                "postponed"
                if self._get_private("check_in_trigger") == self.CHECK_IN_TRIGGER_SESSION_ENDED
                else "missed"
            )
            self.logger.info(
                "Executing check-in as it was {} in authentication_completed account={} asset={}".format(
                    reason, self.account, self.asset
                )
            )
            self.do_check_in_credential()
            self._set_private("check_in_called", True)
        self.do_session_ended()
        return self.finalize_hook()

    def _setup_self(self, cookie, session_cookie, connection_info):
        self.connection = connection_info
        self.cookie = cookie
        self.session_cookie = session_cookie
