# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/06_data.load.ipynb (unless otherwise specified).

__all__ = ['Item', 'show_item', 'Dataset', 'item2tensor', 'rcnn_collate', 'RCNNDataLoader']

# Cell
from ..imports import *
from ..core import *
from .core import *
from .annotation import *

# Cell
@dataclass
class Item:
    img:       np.ndarray
    iid:       int
    labels:    List[int]
    iscrowds:  List[int]
    bboxes:    List[BBox]=None
    masks:     Mask=None
#     keypoints: #TODO
    @classmethod
    def from_record(cls, r):
        return cls(
            img=open_img(r.iinfo.fp),
            iid=r.iinfo.iid,
            labels=r.annot.oids,
            iscrowds=r.annot.iscrowds,
            bboxes=r.annot.bboxes,
            masks=Mask.from_segs(r.annot.segs,r.iinfo.h,r.iinfo.w) if r.annot.segs else None,
            #keypoints: TODO
        )

    def asdict(self): return self.__dict__
    # TODO: This creates a copy, is that necessary?
    def replace(self, **kwargs): return dataclasses.replace(self, **kwargs)

# Cell
def show_item(o, *, label=True, bbox=True, mask=True, catmap=None, ax=None):
    names = [catmap.i2o[i].name for i in o.labels] if notnone(catmap) else o.labels
    show_annot(im=o.img, ax=ax,
               labels=names if label else None,
               bboxes=o.bboxes if bbox else None,
               masks=o.masks if mask else None)

# Cell
class Dataset:
    def __init__(self, records, tfm=None): self.records,self.tfm = records,tfm
    def __len__(self): return len(self.records)

    def __getitem__(self, i): return self._getitem(i=i)
    def _getitem(self, i):
        item = Item.from_record(self.records[i])
        return self.tfm(item) if notnone(self.tfm) else item

    def __repr__(self): return f'<{self.__class__.__name__} with {len(self.records)} items>'

# Cell
def _sample_dsets():
    return catmap,Dataset(rtrain),Dataset(rvalid)
test_utils.sample_dsets = _sample_dsets

# Cell
_fake_box = [0,1,2,3]

# Cell
def _iid2tensor(iid): return tensor(iid, dtype=torch.int64)
def _labels2tensor(labels): return tensor(labels or [0], dtype=torch.int64)
def _iscrowds2tensor(vs): return tensor(vs or [0], dtype=torch.uint8)
def _bboxes2tensor(bxs): return tensor([o.xyxy for o in bxs] or [_fake_box], dtype=torch.float)
def _areas2tensor(bxs): return tensor([o.area for o in bxs] or [4])
def _masks2tensor(masks): return tensor(masks.data, dtype=torch.uint8)

# Cell
def item2tensor(item):
    x = im2tensor(item.img)
    y = {
        'image_id': tensor(item.iid, dtype=torch.int64),
        'labels':   _labels2tensor(item.labels),
        'iscrowd':  _iscrowds2tensor(item.iscrowds),
        'boxes':    ifnotnone(item.bboxes, _bboxes2tensor),
        'area':     ifnotnone(item.bboxes, _areas2tensor),
        'masks':    ifnotnone(item.masks, _masks2tensor),
        # TODO: Keypoints
    }
    return x, cleandict(y)

# Cell
def rcnn_collate(items):
    ts = [item2tensor(o) for o in items]
    return list(zip(*ts))

# Cell
RCNNDataLoader = partial(DataLoader, collate_fn=rcnn_collate)

# Cell
def _sample_dls():
    train_dl = RCNNDataLoader(train_ds, batch_size=2, shuffle=False, drop_last=False)
    valid_dl = RCNNDataLoader(valid_ds, batch_size=4, shuffle=False, drop_last=False)
    return catmap, train_dl, valid_dl
test_utils.sample_dls = _sample_dls