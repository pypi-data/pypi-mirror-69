#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Manage main interfaces."""

import logging
import multiprocessing
import os
import sys

from prettyetc.baseui import main as basemain
from prettyetc.etccore import __version__ as etccore_version
from prettyetc.etccore.langlib.parsers import BadInput
from prettyetc.etccore.logger import ChildLoggerHelper
from PySide2 import __version__ as pyside2_version
from PySide2.QtCore import __version__ as qt_version
from PySide2.QtWidgets import (QApplication, QErrorMessage, QFileDialog,
                               QMainWindow, QMessageBox, QStyleFactory)

from . import __version__ as qtui_version
from .components.widgets.mainwindow import Ui_MainWindow
# try relative imports
from .containers import ConfTab
from .settings import SettingsDialog

__all__ = ("WindowManager", )

INIT_TEMPLATE = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Autogenerated module, any changes will be lost."""

from .{} import {}

__all__ = ({})
'''


class WindowManager(ChildLoggerHelper, basemain.BaseMainUi, Ui_MainWindow,
                    QMainWindow):
    """Manage main window."""

    logger = None
    loggername = "qtui.mainui.window"

    @staticmethod
    def _init_qtui(  # pylint: disable=R0914
            component_path,
            design_path="design",
            locale_path="locale",
            widgets_path="widgets",
            resources_path="resources",
            project_file="project.pro",
            languages=None,
            generate_project=False,
            generate_init=False):
        """
        Initialize qt components create by exernal qt tools to be used by
        python.

        The given directory must contain 3 folder and 2 files:
            - a design path (specified by design_path parameter
                where is contained .ui files created by Qt Designer.
            - a locale path (specified by locale_path parameter)
                where is contained .ts files created by pyside2-lupdate command and
                used by qt linguist.
            - a widget path (specified by widgets_path parameter)
                where ui files will be converted by pyside2-uic to python modules.
            - a resouces path (specified by resources_path parameter)
                where is contained qrc files.
            - a compiled resouces path (specified by compiled_resource_path parameter)
                where qrc files is compiled to rcc files by pyside2-rcc
            - a qt project file (specified by project_file parameter)
                where is contained directives for pyside2-lupdate.
                It can be generated by this function if generate_project is True
            - an __init__.py file
                that import modules contained in widgets path.
                It can be generated by this function if generate_init is True
        """

        def _spawn_command(command, *args):
            # os.execvp(command, args)
            os.system("{} {}".format(command, " ".join(args)))

        design_path = os.path.join(component_path, design_path)
        locale_path = os.path.join(component_path, locale_path)
        widgets_path = os.path.join(component_path, widgets_path)
        resources_path = os.path.join(component_path, resources_path)

        project_file = os.path.join(component_path, project_file)
        if not (os.path.exists(design_path) or os.path.exists(locale_path)
                or os.path.exists(widgets_path)
                or os.path.exists(resources_path)):
            raise FileNotFoundError(
                "Given design, locale, widgets and resources directory must exists."
            )

        if not hasattr(languages, "__iter__") and generate_project:
            raise ValueError(
                "Languages must be specified when you generate a project.")

        # ui processing
        if generate_project or generate_init:
            generated_widgets = []
        for file in os.listdir(design_path):
            abspath = os.path.join(design_path, file)
            if file.endswith(".ui"):
                module_path = os.path.join(widgets_path,
                                           os.path.splitext(file)[0] + ".py")

                multiprocessing.Process(
                    target=_spawn_command,
                    args=("pyside2-uic", "--from-imports", abspath, "-o",
                          module_path)).start()
                if generate_project or generate_init:
                    generated_widgets.append(module_path)

        # resources processing
        for file in os.listdir(resources_path):
            abspath = os.path.join(resources_path, file)
            if file.endswith(".qrc"):
                compiled_path = os.path.join(
                    widgets_path,
                    os.path.splitext(file)[0] + "_rc.py")
                multiprocessing.Process(
                    target=_spawn_command,
                    args=("pyside2-rcc", abspath, "-o",
                          compiled_path)).start()

        if generate_init:
            # generate __init__ files
            dirname = os.path.split(widgets_path)[1]
            module_names = ", ".join(
                os.path.splitext(os.path.split(file)[1])[0]
                for file in generated_widgets)
            module_names_all = ", ".join(
                repr(os.path.splitext(os.path.split(file)[1])[0])
                for file in generated_widgets)
            with open(os.path.join(component_path, "__init__.py"),
                      "w") as stream:
                stream.write(
                    INIT_TEMPLATE.format(dirname, module_names,
                                         module_names_all))
            # create empty file
            open(os.path.join(widgets_path, "__init__.py"), "w")

        if generate_project:
            with open(os.path.join(component_path, project_file),
                      "w") as stream:
                stream.write(
                    "# Autogenerated project file, any changes will be lost\n")
                stream.write("SOURCES = ")  # init sources
                for abspath in generated_widgets:
                    relpath = os.path.relpath(abspath, component_path)
                    stream.write("{} ".format(relpath))
                # end sources, start languages
                stream.write("\n\nTRANSLATIONS = ")
                relpath = os.path.relpath(locale_path, component_path)
                for language in languages:
                    stream.write("{} ".format(
                        os.path.join(relpath, "{}.ts".format(language))))
                stream.write("\n")  # end languages

        multiprocessing.Process(
            target=_spawn_command,
            args=("pyside2-lupdate", "-noobsolete",
                  os.path.join(component_path, project_file))).start()
        # os.execlp("pyside2-lupdate", "-noobsolete", os.path.join(component_path, project_file))

    def __init__(self, configfactory, *args, **kwargs):
        # Load system qt plugins
        #     # for activate this you must call main script with
        #     # PYSIDE_DISABLE_INTERNAL_QT_CONF=1
        # if get_desktop_environment() == "kde":
        #     # self.logger.info("You are using KDE")
        #     try:
        #         # self.logger.debug("Try to load custom qt.conf resource")
        #         import qtui.components.widgets.qt_conf_rc as _  # pylint: disable=E0611
        #     except ImportError:
        #         # self.logger.debug("Failed to load custom qt.conf resource")
        #     else:
        #         # qfile = QFile(":/qt/etc/qt.conf")
        #         # qfile.open(QIODevice.OpenModeFlag(0x0011))
        #         # print(qfile.readAll())
        #         # self.logger.debug("Custom qt.conf resource load successfully")
        self.app = QApplication(sys.argv)
        self.app.setDesktopSettingsAware(True)
        self.confTabs = None
        self.configfactory = configfactory

        super().__init__(*args, **kwargs)
        self.logger.info("Avaiable QT styles: %s",
                         " ".join(QStyleFactory.keys()))

        self.settings_dialog = SettingsDialog(
            parent=self, apply_callback=self.apply_configs)

    # from BaseMainUi
    def show(self):
        """Run QMainWindow.show and self.app.exec()"""
        QMainWindow.show(self)
        self.app.exec_()

    def init_ui(self):
        """Call internal initializer with qt dependent arguments and init mainwindow."""
        if self.logger.isEnabledFor(logging.DEBUG):
            try:
                WindowManager._init_qtui(
                    os.path.abspath("prettyetc/qtui/components/"),
                    languages=("en_GB", "it_IT"),
                    generate_project=True,
                    generate_init=False)
            except Exception as ex:  # pylint: disable=W0703
                self.logger.debug("Failed to run _init_qtui.", exc_info=ex)
        self.setupUi(self)

        # setup tab widget
        conf_tabs = ConfTab()
        self.rootLayout.replaceWidget(self.confTabs, conf_tabs)
        conf_tabs.copy_properties(self.confTabs)
        self.confTabs.setParent(None)
        self.confTabs = conf_tabs

        # setup configs
        try:
            self.apply_configs(self.settings_dialog.settings)
        except (AttributeError, KeyError):
            self.settings_dialog.save()
            # retry apply_configs
            self.apply_configs(self.settings_dialog.settings)

    def add_root(self, root):
        self.confTabs += root

    def handle_badinput(self, path, ex: BadInput):
        """Show error dialog with the error."""
        if ex is None:
            dialog = QErrorMessage(self)
            dialog.setObjectName("openErrorDialog")
            dialog.setWindowTitle("{}: {}".format(
                self.app.translate("openErrorDialog", "Failed to open file"),
                os.path.split(path)[1]))
            dialog.showMessage("Given file has failed to be loaded.")
        dialog = QErrorMessage(self)
        dialog.setObjectName("openErrorDialog")
        dialog.setWindowTitle("{}: {}".format(
            self.app.translate("openErrorDialog", "Failed to open file"),
            os.path.split(path)[1]))
        dialog.showMessage(repr(ex))

    def apply_configs(self, settings):
        """Apply configs given from settings."""
        if settings.qtdebug is None:
            raise AttributeError(
                "qtdebug attribute doesn't exists in settings.")
        if settings.qtdebug.get("hidden actions", False):
            self.logger.debug("Show hidden actions")
            self.action_new.setDisabled(False)
            self.action_save.setDisabled(False)
            self.action_saveas.setDisabled(False)
        else:
            self.logger.debug("Hide hidden actions")
            self.action_new.setDisabled(True)
            self.action_save.setDisabled(True)
            self.action_saveas.setDisabled(True)

    # slots
    def open_confile(self, *_):
        """Called when open action is fired, it opens a file input dialog."""
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Select a config file",
            options=QFileDialog.DontUseNativeDialog)
        if os.path.isfile(filename):
            self.read_callback(self, filename, self.configfactory)

    def open_settings(self, *_):
        """Called when setting action is fired, it opens the settings dialog."""
        self.settings_dialog.show()
        self.settings_dialog.exec_()

    def open_about(self, *_):
        """Open the standard Qt about and show summary informations and library versions."""
        try:
            import homebase
        except ImportError:
            homebase = None

        message = (
            "See your configuration file using a pretty and universal interface.\n\n"
            "© Copyright 2019, trollodel.\n"
            "This Qt UI for prettyetc version {}.\n\n"
            "Used library:\n"
            "The etccore library (formally named as prettyetc-core) version {}.\n\n"
            "3rd part libraries:\n"
            "The PySide2 python binding for the Qt framework version {}.\n"
            "The Qt framework version {}.\n".format(
                qtui_version, etccore_version, pyside2_version, qt_version))
        if homebase is not None:
            message += "The homebase library version {}.\n".format(
                homebase.__version__)
        QMessageBox.about(self, "The prettyetc project\n", message)

    @staticmethod
    def main(*args, **kwargs):
        """Launch qtui, if avaiable."""
        basemain.UiLauncher.main(*args, preferred_uis=("qt", ), **kwargs)
