# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbresult

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Step(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsStep(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Step()
        x.Init(buf, n + offset)
        return x

    # Step
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Step
    def Distance(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Step
    def Duration(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Step
    def Polyline(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Coordinates(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 8
            from osrm.engine.api.fbresult.Position import Position
            obj = Position()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Step
    def CoordinatesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Step
    def CoordinatesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Step
    def Weight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # Step
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Ref(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Pronunciation(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Destinations(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Exits(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def Maneuver(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from osrm.engine.api.fbresult.StepManeuver import StepManeuver
            obj = StepManeuver()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Step
    def Intersections(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from osrm.engine.api.fbresult.Intersection import Intersection
            obj = Intersection()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Step
    def IntersectionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Step
    def IntersectionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # Step
    def RotaryName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def RotaryPronunciation(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Step
    def DrivingSide(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def StepStart(builder): builder.StartObject(16)
def StepAddDistance(builder, distance): builder.PrependFloat32Slot(0, distance, 0.0)
def StepAddDuration(builder, duration): builder.PrependFloat32Slot(1, duration, 0.0)
def StepAddPolyline(builder, polyline): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(polyline), 0)
def StepAddCoordinates(builder, coordinates): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(coordinates), 0)
def StepStartCoordinatesVector(builder, numElems): return builder.StartVector(8, numElems, 4)
def StepAddWeight(builder, weight): builder.PrependFloat32Slot(4, weight, 0.0)
def StepAddName(builder, name): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def StepAddRef(builder, ref): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(ref), 0)
def StepAddPronunciation(builder, pronunciation): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(pronunciation), 0)
def StepAddDestinations(builder, destinations): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(destinations), 0)
def StepAddExits(builder, exits): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(exits), 0)
def StepAddMode(builder, mode): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(mode), 0)
def StepAddManeuver(builder, maneuver): builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(maneuver), 0)
def StepAddIntersections(builder, intersections): builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(intersections), 0)
def StepStartIntersectionsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StepAddRotaryName(builder, rotaryName): builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(rotaryName), 0)
def StepAddRotaryPronunciation(builder, rotaryPronunciation): builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(rotaryPronunciation), 0)
def StepAddDrivingSide(builder, drivingSide): builder.PrependBoolSlot(15, drivingSide, 0)
def StepEnd(builder): return builder.EndObject()
